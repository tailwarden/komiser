{"ast":null,"code":"import _classCallCheck from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/mlabouardy/go/src/github.com/mlabouardy/komiser/dashboard/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport var ReplaySubject = /*#__PURE__*/function (_Subject) {\n  _inherits(ReplaySubject, _Subject);\n\n  var _super = _createSuper(ReplaySubject);\n\n  function ReplaySubject() {\n    var _this;\n\n    var bufferSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;\n    var windowTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n    var scheduler = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ReplaySubject);\n\n    _this = _super.call(this);\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n\n    return _this;\n  }\n\n  _createClass(ReplaySubject, [{\n    key: \"nextInfiniteTimeWindow\",\n    value: function nextInfiniteTimeWindow(value) {\n      if (!this.isStopped) {\n        var _events = this._events;\n\n        _events.push(value);\n\n        if (_events.length > this._bufferSize) {\n          _events.shift();\n        }\n      }\n\n      _get(_getPrototypeOf(ReplaySubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"nextTimeWindow\",\n    value: function nextTimeWindow(value) {\n      if (!this.isStopped) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n\n        this._trimBufferThenGetEvents();\n      }\n\n      _get(_getPrototypeOf(ReplaySubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe(subscriber) {\n      var _infiniteTimeWindow = this._infiniteTimeWindow;\n\n      var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n\n      var scheduler = this.scheduler;\n      var len = _events.length;\n      var subscription;\n\n      if (this.closed) {\n        throw new ObjectUnsubscribedError();\n      } else if (this.isStopped || this.hasError) {\n        subscription = Subscription.EMPTY;\n      } else {\n        this.observers.push(subscriber);\n        subscription = new SubjectSubscription(this, subscriber);\n      }\n\n      if (scheduler) {\n        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n      }\n\n      if (_infiniteTimeWindow) {\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n          subscriber.next(_events[i]);\n        }\n      } else {\n        for (var _i = 0; _i < len && !subscriber.closed; _i++) {\n          subscriber.next(_events[_i].value);\n        }\n      }\n\n      if (this.hasError) {\n        subscriber.error(this.thrownError);\n      } else if (this.isStopped) {\n        subscriber.complete();\n      }\n\n      return subscription;\n    }\n  }, {\n    key: \"_getNow\",\n    value: function _getNow() {\n      return (this.scheduler || queue).now();\n    }\n  }, {\n    key: \"_trimBufferThenGetEvents\",\n    value: function _trimBufferThenGetEvents() {\n      var now = this._getNow();\n\n      var _bufferSize = this._bufferSize;\n      var _windowTime = this._windowTime;\n      var _events = this._events;\n      var eventsCount = _events.length;\n      var spliceCount = 0;\n\n      while (spliceCount < eventsCount) {\n        if (now - _events[spliceCount].time < _windowTime) {\n          break;\n        }\n\n        spliceCount++;\n      }\n\n      if (eventsCount > _bufferSize) {\n        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n      }\n\n      if (spliceCount > 0) {\n        _events.splice(0, spliceCount);\n      }\n\n      return _events;\n    }\n  }]);\n\n  return ReplaySubject;\n}(Subject);\n\nvar ReplayEvent = /*#__PURE__*/_createClass(function ReplayEvent(time, value) {\n  _classCallCheck(this, ReplayEvent);\n\n  this.time = time;\n  this.value = value;\n}); //# sourceMappingURL=ReplaySubject.js.map","map":null,"metadata":{},"sourceType":"module"}