// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package elasticsearchservice

import (
	"context"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opAddTags = "AddTags"

// AddTagsRequest is a API request type for the AddTags API operation.
type AddTagsRequest struct {
	*aws.Request
	Input *AddTagsInput
	Copy  func(*AddTagsInput) AddTagsRequest
}

// Send marshals and sends the AddTags API request.
func (r AddTagsRequest) Send(ctx context.Context) (*AddTagsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AddTagsOutput), nil
}

// AddTagsRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Attaches tags to an existing Elasticsearch domain. Tags are a set of case-sensitive
// key value pairs. An Elasticsearch domain may have up to 10 tags. See  Tagging
// Amazon Elasticsearch Service Domains for more information. (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains.html#es-managedomains-awsresorcetagging)
//
//    // Example sending a request using the AddTagsRequest method.
//    req := client.AddTagsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) AddTagsRequest(input *AddTagsInput) AddTagsRequest {
	op := &aws.Operation{
		Name:       opAddTags,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/tags",
	}

	if input == nil {
		input = &AddTagsInput{}
	}

	output := &AddTagsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return AddTagsRequest{Request: req, Input: input, Copy: c.AddTagsRequest}
}

const opCancelElasticsearchServiceSoftwareUpdate = "CancelElasticsearchServiceSoftwareUpdate"

// CancelElasticsearchServiceSoftwareUpdateRequest is a API request type for the CancelElasticsearchServiceSoftwareUpdate API operation.
type CancelElasticsearchServiceSoftwareUpdateRequest struct {
	*aws.Request
	Input *CancelElasticsearchServiceSoftwareUpdateInput
	Copy  func(*CancelElasticsearchServiceSoftwareUpdateInput) CancelElasticsearchServiceSoftwareUpdateRequest
}

// Send marshals and sends the CancelElasticsearchServiceSoftwareUpdate API request.
func (r CancelElasticsearchServiceSoftwareUpdateRequest) Send(ctx context.Context) (*CancelElasticsearchServiceSoftwareUpdateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CancelElasticsearchServiceSoftwareUpdateOutput), nil
}

// CancelElasticsearchServiceSoftwareUpdateRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Cancels a scheduled service software update for an Amazon ES domain. You
// can only perform this operation before the AutomatedUpdateDate and when the
// UpdateStatus is in the PENDING_UPDATE state.
//
//    // Example sending a request using the CancelElasticsearchServiceSoftwareUpdateRequest method.
//    req := client.CancelElasticsearchServiceSoftwareUpdateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) CancelElasticsearchServiceSoftwareUpdateRequest(input *CancelElasticsearchServiceSoftwareUpdateInput) CancelElasticsearchServiceSoftwareUpdateRequest {
	op := &aws.Operation{
		Name:       opCancelElasticsearchServiceSoftwareUpdate,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/es/serviceSoftwareUpdate/cancel",
	}

	if input == nil {
		input = &CancelElasticsearchServiceSoftwareUpdateInput{}
	}

	output := &CancelElasticsearchServiceSoftwareUpdateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CancelElasticsearchServiceSoftwareUpdateRequest{Request: req, Input: input, Copy: c.CancelElasticsearchServiceSoftwareUpdateRequest}
}

const opCreateElasticsearchDomain = "CreateElasticsearchDomain"

// CreateElasticsearchDomainRequest is a API request type for the CreateElasticsearchDomain API operation.
type CreateElasticsearchDomainRequest struct {
	*aws.Request
	Input *CreateElasticsearchDomainInput
	Copy  func(*CreateElasticsearchDomainInput) CreateElasticsearchDomainRequest
}

// Send marshals and sends the CreateElasticsearchDomain API request.
func (r CreateElasticsearchDomainRequest) Send(ctx context.Context) (*CreateElasticsearchDomainOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateElasticsearchDomainOutput), nil
}

// CreateElasticsearchDomainRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Creates a new Elasticsearch domain. For more information, see Creating Elasticsearch
// Domains (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomains)
// in the Amazon Elasticsearch Service Developer Guide.
//
//    // Example sending a request using the CreateElasticsearchDomainRequest method.
//    req := client.CreateElasticsearchDomainRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) CreateElasticsearchDomainRequest(input *CreateElasticsearchDomainInput) CreateElasticsearchDomainRequest {
	op := &aws.Operation{
		Name:       opCreateElasticsearchDomain,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/es/domain",
	}

	if input == nil {
		input = &CreateElasticsearchDomainInput{}
	}

	output := &CreateElasticsearchDomainOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateElasticsearchDomainRequest{Request: req, Input: input, Copy: c.CreateElasticsearchDomainRequest}
}

const opDeleteElasticsearchDomain = "DeleteElasticsearchDomain"

// DeleteElasticsearchDomainRequest is a API request type for the DeleteElasticsearchDomain API operation.
type DeleteElasticsearchDomainRequest struct {
	*aws.Request
	Input *DeleteElasticsearchDomainInput
	Copy  func(*DeleteElasticsearchDomainInput) DeleteElasticsearchDomainRequest
}

// Send marshals and sends the DeleteElasticsearchDomain API request.
func (r DeleteElasticsearchDomainRequest) Send(ctx context.Context) (*DeleteElasticsearchDomainOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteElasticsearchDomainOutput), nil
}

// DeleteElasticsearchDomainRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Permanently deletes the specified Elasticsearch domain and all of its data.
// Once a domain is deleted, it cannot be recovered.
//
//    // Example sending a request using the DeleteElasticsearchDomainRequest method.
//    req := client.DeleteElasticsearchDomainRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) DeleteElasticsearchDomainRequest(input *DeleteElasticsearchDomainInput) DeleteElasticsearchDomainRequest {
	op := &aws.Operation{
		Name:       opDeleteElasticsearchDomain,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2015-01-01/es/domain/{DomainName}",
	}

	if input == nil {
		input = &DeleteElasticsearchDomainInput{}
	}

	output := &DeleteElasticsearchDomainOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteElasticsearchDomainRequest{Request: req, Input: input, Copy: c.DeleteElasticsearchDomainRequest}
}

const opDeleteElasticsearchServiceRole = "DeleteElasticsearchServiceRole"

// DeleteElasticsearchServiceRoleRequest is a API request type for the DeleteElasticsearchServiceRole API operation.
type DeleteElasticsearchServiceRoleRequest struct {
	*aws.Request
	Input *DeleteElasticsearchServiceRoleInput
	Copy  func(*DeleteElasticsearchServiceRoleInput) DeleteElasticsearchServiceRoleRequest
}

// Send marshals and sends the DeleteElasticsearchServiceRole API request.
func (r DeleteElasticsearchServiceRoleRequest) Send(ctx context.Context) (*DeleteElasticsearchServiceRoleOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteElasticsearchServiceRoleOutput), nil
}

// DeleteElasticsearchServiceRoleRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Deletes the service-linked role that Elasticsearch Service uses to manage
// and maintain VPC domains. Role deletion will fail if any existing VPC domains
// use the role. You must delete any such Elasticsearch domains before deleting
// the role. See Deleting Elasticsearch Service Role (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-enabling-slr)
// in VPC Endpoints for Amazon Elasticsearch Service Domains.
//
//    // Example sending a request using the DeleteElasticsearchServiceRoleRequest method.
//    req := client.DeleteElasticsearchServiceRoleRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) DeleteElasticsearchServiceRoleRequest(input *DeleteElasticsearchServiceRoleInput) DeleteElasticsearchServiceRoleRequest {
	op := &aws.Operation{
		Name:       opDeleteElasticsearchServiceRole,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2015-01-01/es/role",
	}

	if input == nil {
		input = &DeleteElasticsearchServiceRoleInput{}
	}

	output := &DeleteElasticsearchServiceRoleOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteElasticsearchServiceRoleRequest{Request: req, Input: input, Copy: c.DeleteElasticsearchServiceRoleRequest}
}

const opDescribeElasticsearchDomain = "DescribeElasticsearchDomain"

// DescribeElasticsearchDomainRequest is a API request type for the DescribeElasticsearchDomain API operation.
type DescribeElasticsearchDomainRequest struct {
	*aws.Request
	Input *DescribeElasticsearchDomainInput
	Copy  func(*DescribeElasticsearchDomainInput) DescribeElasticsearchDomainRequest
}

// Send marshals and sends the DescribeElasticsearchDomain API request.
func (r DescribeElasticsearchDomainRequest) Send(ctx context.Context) (*DescribeElasticsearchDomainOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeElasticsearchDomainOutput), nil
}

// DescribeElasticsearchDomainRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Returns domain configuration information about the specified Elasticsearch
// domain, including the domain ID, domain endpoint, and domain ARN.
//
//    // Example sending a request using the DescribeElasticsearchDomainRequest method.
//    req := client.DescribeElasticsearchDomainRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) DescribeElasticsearchDomainRequest(input *DescribeElasticsearchDomainInput) DescribeElasticsearchDomainRequest {
	op := &aws.Operation{
		Name:       opDescribeElasticsearchDomain,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/domain/{DomainName}",
	}

	if input == nil {
		input = &DescribeElasticsearchDomainInput{}
	}

	output := &DescribeElasticsearchDomainOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeElasticsearchDomainRequest{Request: req, Input: input, Copy: c.DescribeElasticsearchDomainRequest}
}

const opDescribeElasticsearchDomainConfig = "DescribeElasticsearchDomainConfig"

// DescribeElasticsearchDomainConfigRequest is a API request type for the DescribeElasticsearchDomainConfig API operation.
type DescribeElasticsearchDomainConfigRequest struct {
	*aws.Request
	Input *DescribeElasticsearchDomainConfigInput
	Copy  func(*DescribeElasticsearchDomainConfigInput) DescribeElasticsearchDomainConfigRequest
}

// Send marshals and sends the DescribeElasticsearchDomainConfig API request.
func (r DescribeElasticsearchDomainConfigRequest) Send(ctx context.Context) (*DescribeElasticsearchDomainConfigOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeElasticsearchDomainConfigOutput), nil
}

// DescribeElasticsearchDomainConfigRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Provides cluster configuration information about the specified Elasticsearch
// domain, such as the state, creation date, update version, and update date
// for cluster options.
//
//    // Example sending a request using the DescribeElasticsearchDomainConfigRequest method.
//    req := client.DescribeElasticsearchDomainConfigRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) DescribeElasticsearchDomainConfigRequest(input *DescribeElasticsearchDomainConfigInput) DescribeElasticsearchDomainConfigRequest {
	op := &aws.Operation{
		Name:       opDescribeElasticsearchDomainConfig,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/domain/{DomainName}/config",
	}

	if input == nil {
		input = &DescribeElasticsearchDomainConfigInput{}
	}

	output := &DescribeElasticsearchDomainConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeElasticsearchDomainConfigRequest{Request: req, Input: input, Copy: c.DescribeElasticsearchDomainConfigRequest}
}

const opDescribeElasticsearchDomains = "DescribeElasticsearchDomains"

// DescribeElasticsearchDomainsRequest is a API request type for the DescribeElasticsearchDomains API operation.
type DescribeElasticsearchDomainsRequest struct {
	*aws.Request
	Input *DescribeElasticsearchDomainsInput
	Copy  func(*DescribeElasticsearchDomainsInput) DescribeElasticsearchDomainsRequest
}

// Send marshals and sends the DescribeElasticsearchDomains API request.
func (r DescribeElasticsearchDomainsRequest) Send(ctx context.Context) (*DescribeElasticsearchDomainsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeElasticsearchDomainsOutput), nil
}

// DescribeElasticsearchDomainsRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Returns domain configuration information about the specified Elasticsearch
// domains, including the domain ID, domain endpoint, and domain ARN.
//
//    // Example sending a request using the DescribeElasticsearchDomainsRequest method.
//    req := client.DescribeElasticsearchDomainsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) DescribeElasticsearchDomainsRequest(input *DescribeElasticsearchDomainsInput) DescribeElasticsearchDomainsRequest {
	op := &aws.Operation{
		Name:       opDescribeElasticsearchDomains,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/es/domain-info",
	}

	if input == nil {
		input = &DescribeElasticsearchDomainsInput{}
	}

	output := &DescribeElasticsearchDomainsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeElasticsearchDomainsRequest{Request: req, Input: input, Copy: c.DescribeElasticsearchDomainsRequest}
}

const opDescribeElasticsearchInstanceTypeLimits = "DescribeElasticsearchInstanceTypeLimits"

// DescribeElasticsearchInstanceTypeLimitsRequest is a API request type for the DescribeElasticsearchInstanceTypeLimits API operation.
type DescribeElasticsearchInstanceTypeLimitsRequest struct {
	*aws.Request
	Input *DescribeElasticsearchInstanceTypeLimitsInput
	Copy  func(*DescribeElasticsearchInstanceTypeLimitsInput) DescribeElasticsearchInstanceTypeLimitsRequest
}

// Send marshals and sends the DescribeElasticsearchInstanceTypeLimits API request.
func (r DescribeElasticsearchInstanceTypeLimitsRequest) Send(ctx context.Context) (*DescribeElasticsearchInstanceTypeLimitsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeElasticsearchInstanceTypeLimitsOutput), nil
}

// DescribeElasticsearchInstanceTypeLimitsRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Describe Elasticsearch Limits for a given InstanceType and ElasticsearchVersion.
// When modifying existing Domain, specify the DomainName to know what Limits
// are supported for modifying.
//
//    // Example sending a request using the DescribeElasticsearchInstanceTypeLimitsRequest method.
//    req := client.DescribeElasticsearchInstanceTypeLimitsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) DescribeElasticsearchInstanceTypeLimitsRequest(input *DescribeElasticsearchInstanceTypeLimitsInput) DescribeElasticsearchInstanceTypeLimitsRequest {
	op := &aws.Operation{
		Name:       opDescribeElasticsearchInstanceTypeLimits,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/instanceTypeLimits/{ElasticsearchVersion}/{InstanceType}",
	}

	if input == nil {
		input = &DescribeElasticsearchInstanceTypeLimitsInput{}
	}

	output := &DescribeElasticsearchInstanceTypeLimitsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeElasticsearchInstanceTypeLimitsRequest{Request: req, Input: input, Copy: c.DescribeElasticsearchInstanceTypeLimitsRequest}
}

const opDescribeReservedElasticsearchInstanceOfferings = "DescribeReservedElasticsearchInstanceOfferings"

// DescribeReservedElasticsearchInstanceOfferingsRequest is a API request type for the DescribeReservedElasticsearchInstanceOfferings API operation.
type DescribeReservedElasticsearchInstanceOfferingsRequest struct {
	*aws.Request
	Input *DescribeReservedElasticsearchInstanceOfferingsInput
	Copy  func(*DescribeReservedElasticsearchInstanceOfferingsInput) DescribeReservedElasticsearchInstanceOfferingsRequest
}

// Send marshals and sends the DescribeReservedElasticsearchInstanceOfferings API request.
func (r DescribeReservedElasticsearchInstanceOfferingsRequest) Send(ctx context.Context) (*DescribeReservedElasticsearchInstanceOfferingsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeReservedElasticsearchInstanceOfferingsOutput), nil
}

// DescribeReservedElasticsearchInstanceOfferingsRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Lists available reserved Elasticsearch instance offerings.
//
//    // Example sending a request using the DescribeReservedElasticsearchInstanceOfferingsRequest method.
//    req := client.DescribeReservedElasticsearchInstanceOfferingsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) DescribeReservedElasticsearchInstanceOfferingsRequest(input *DescribeReservedElasticsearchInstanceOfferingsInput) DescribeReservedElasticsearchInstanceOfferingsRequest {
	op := &aws.Operation{
		Name:       opDescribeReservedElasticsearchInstanceOfferings,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/reservedInstanceOfferings",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeReservedElasticsearchInstanceOfferingsInput{}
	}

	output := &DescribeReservedElasticsearchInstanceOfferingsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeReservedElasticsearchInstanceOfferingsRequest{Request: req, Input: input, Copy: c.DescribeReservedElasticsearchInstanceOfferingsRequest}
}

// Paginate pages iterates over the pages of a DescribeReservedElasticsearchInstanceOfferingsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeReservedElasticsearchInstanceOfferings operation.
//		req := client.DescribeReservedElasticsearchInstanceOfferingsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeReservedElasticsearchInstanceOfferingsRequest) Paginate(opts ...aws.Option) DescribeReservedElasticsearchInstanceOfferingsPager {
	return DescribeReservedElasticsearchInstanceOfferingsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *DescribeReservedElasticsearchInstanceOfferingsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// DescribeReservedElasticsearchInstanceOfferingsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeReservedElasticsearchInstanceOfferingsPager struct {
	aws.Pager
}

func (p *DescribeReservedElasticsearchInstanceOfferingsPager) CurrentPage() *DescribeReservedElasticsearchInstanceOfferingsOutput {
	return p.Pager.CurrentPage().(*DescribeReservedElasticsearchInstanceOfferingsOutput)
}

const opDescribeReservedElasticsearchInstances = "DescribeReservedElasticsearchInstances"

// DescribeReservedElasticsearchInstancesRequest is a API request type for the DescribeReservedElasticsearchInstances API operation.
type DescribeReservedElasticsearchInstancesRequest struct {
	*aws.Request
	Input *DescribeReservedElasticsearchInstancesInput
	Copy  func(*DescribeReservedElasticsearchInstancesInput) DescribeReservedElasticsearchInstancesRequest
}

// Send marshals and sends the DescribeReservedElasticsearchInstances API request.
func (r DescribeReservedElasticsearchInstancesRequest) Send(ctx context.Context) (*DescribeReservedElasticsearchInstancesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeReservedElasticsearchInstancesOutput), nil
}

// DescribeReservedElasticsearchInstancesRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Returns information about reserved Elasticsearch instances for this account.
//
//    // Example sending a request using the DescribeReservedElasticsearchInstancesRequest method.
//    req := client.DescribeReservedElasticsearchInstancesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) DescribeReservedElasticsearchInstancesRequest(input *DescribeReservedElasticsearchInstancesInput) DescribeReservedElasticsearchInstancesRequest {
	op := &aws.Operation{
		Name:       opDescribeReservedElasticsearchInstances,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/reservedInstances",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeReservedElasticsearchInstancesInput{}
	}

	output := &DescribeReservedElasticsearchInstancesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeReservedElasticsearchInstancesRequest{Request: req, Input: input, Copy: c.DescribeReservedElasticsearchInstancesRequest}
}

// Paginate pages iterates over the pages of a DescribeReservedElasticsearchInstancesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeReservedElasticsearchInstances operation.
//		req := client.DescribeReservedElasticsearchInstancesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *DescribeReservedElasticsearchInstancesRequest) Paginate(opts ...aws.Option) DescribeReservedElasticsearchInstancesPager {
	return DescribeReservedElasticsearchInstancesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *DescribeReservedElasticsearchInstancesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// DescribeReservedElasticsearchInstancesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type DescribeReservedElasticsearchInstancesPager struct {
	aws.Pager
}

func (p *DescribeReservedElasticsearchInstancesPager) CurrentPage() *DescribeReservedElasticsearchInstancesOutput {
	return p.Pager.CurrentPage().(*DescribeReservedElasticsearchInstancesOutput)
}

const opGetCompatibleElasticsearchVersions = "GetCompatibleElasticsearchVersions"

// GetCompatibleElasticsearchVersionsRequest is a API request type for the GetCompatibleElasticsearchVersions API operation.
type GetCompatibleElasticsearchVersionsRequest struct {
	*aws.Request
	Input *GetCompatibleElasticsearchVersionsInput
	Copy  func(*GetCompatibleElasticsearchVersionsInput) GetCompatibleElasticsearchVersionsRequest
}

// Send marshals and sends the GetCompatibleElasticsearchVersions API request.
func (r GetCompatibleElasticsearchVersionsRequest) Send(ctx context.Context) (*GetCompatibleElasticsearchVersionsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetCompatibleElasticsearchVersionsOutput), nil
}

// GetCompatibleElasticsearchVersionsRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Returns a list of upgrade compatible Elastisearch versions. You can optionally
// pass a DomainName to get all upgrade compatible Elasticsearch versions for
// that specific domain.
//
//    // Example sending a request using the GetCompatibleElasticsearchVersionsRequest method.
//    req := client.GetCompatibleElasticsearchVersionsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) GetCompatibleElasticsearchVersionsRequest(input *GetCompatibleElasticsearchVersionsInput) GetCompatibleElasticsearchVersionsRequest {
	op := &aws.Operation{
		Name:       opGetCompatibleElasticsearchVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/compatibleVersions",
	}

	if input == nil {
		input = &GetCompatibleElasticsearchVersionsInput{}
	}

	output := &GetCompatibleElasticsearchVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetCompatibleElasticsearchVersionsRequest{Request: req, Input: input, Copy: c.GetCompatibleElasticsearchVersionsRequest}
}

const opGetUpgradeHistory = "GetUpgradeHistory"

// GetUpgradeHistoryRequest is a API request type for the GetUpgradeHistory API operation.
type GetUpgradeHistoryRequest struct {
	*aws.Request
	Input *GetUpgradeHistoryInput
	Copy  func(*GetUpgradeHistoryInput) GetUpgradeHistoryRequest
}

// Send marshals and sends the GetUpgradeHistory API request.
func (r GetUpgradeHistoryRequest) Send(ctx context.Context) (*GetUpgradeHistoryOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetUpgradeHistoryOutput), nil
}

// GetUpgradeHistoryRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Retrieves the complete history of the last 10 upgrades that were performed
// on the domain.
//
//    // Example sending a request using the GetUpgradeHistoryRequest method.
//    req := client.GetUpgradeHistoryRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) GetUpgradeHistoryRequest(input *GetUpgradeHistoryInput) GetUpgradeHistoryRequest {
	op := &aws.Operation{
		Name:       opGetUpgradeHistory,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/upgradeDomain/{DomainName}/history",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetUpgradeHistoryInput{}
	}

	output := &GetUpgradeHistoryOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetUpgradeHistoryRequest{Request: req, Input: input, Copy: c.GetUpgradeHistoryRequest}
}

// Paginate pages iterates over the pages of a GetUpgradeHistoryRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetUpgradeHistory operation.
//		req := client.GetUpgradeHistoryRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetUpgradeHistoryRequest) Paginate(opts ...aws.Option) GetUpgradeHistoryPager {
	return GetUpgradeHistoryPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetUpgradeHistoryInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetUpgradeHistoryPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetUpgradeHistoryPager struct {
	aws.Pager
}

func (p *GetUpgradeHistoryPager) CurrentPage() *GetUpgradeHistoryOutput {
	return p.Pager.CurrentPage().(*GetUpgradeHistoryOutput)
}

const opGetUpgradeStatus = "GetUpgradeStatus"

// GetUpgradeStatusRequest is a API request type for the GetUpgradeStatus API operation.
type GetUpgradeStatusRequest struct {
	*aws.Request
	Input *GetUpgradeStatusInput
	Copy  func(*GetUpgradeStatusInput) GetUpgradeStatusRequest
}

// Send marshals and sends the GetUpgradeStatus API request.
func (r GetUpgradeStatusRequest) Send(ctx context.Context) (*GetUpgradeStatusOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetUpgradeStatusOutput), nil
}

// GetUpgradeStatusRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Retrieves the latest status of the last upgrade or upgrade eligibility check
// that was performed on the domain.
//
//    // Example sending a request using the GetUpgradeStatusRequest method.
//    req := client.GetUpgradeStatusRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) GetUpgradeStatusRequest(input *GetUpgradeStatusInput) GetUpgradeStatusRequest {
	op := &aws.Operation{
		Name:       opGetUpgradeStatus,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/upgradeDomain/{DomainName}/status",
	}

	if input == nil {
		input = &GetUpgradeStatusInput{}
	}

	output := &GetUpgradeStatusOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetUpgradeStatusRequest{Request: req, Input: input, Copy: c.GetUpgradeStatusRequest}
}

const opListDomainNames = "ListDomainNames"

// ListDomainNamesRequest is a API request type for the ListDomainNames API operation.
type ListDomainNamesRequest struct {
	*aws.Request
	Input *ListDomainNamesInput
	Copy  func(*ListDomainNamesInput) ListDomainNamesRequest
}

// Send marshals and sends the ListDomainNames API request.
func (r ListDomainNamesRequest) Send(ctx context.Context) (*ListDomainNamesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListDomainNamesOutput), nil
}

// ListDomainNamesRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Returns the name of all Elasticsearch domains owned by the current user's
// account.
//
//    // Example sending a request using the ListDomainNamesRequest method.
//    req := client.ListDomainNamesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) ListDomainNamesRequest(input *ListDomainNamesInput) ListDomainNamesRequest {
	op := &aws.Operation{
		Name:       opListDomainNames,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/domain",
	}

	if input == nil {
		input = &ListDomainNamesInput{}
	}

	output := &ListDomainNamesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListDomainNamesRequest{Request: req, Input: input, Copy: c.ListDomainNamesRequest}
}

const opListElasticsearchInstanceTypes = "ListElasticsearchInstanceTypes"

// ListElasticsearchInstanceTypesRequest is a API request type for the ListElasticsearchInstanceTypes API operation.
type ListElasticsearchInstanceTypesRequest struct {
	*aws.Request
	Input *ListElasticsearchInstanceTypesInput
	Copy  func(*ListElasticsearchInstanceTypesInput) ListElasticsearchInstanceTypesRequest
}

// Send marshals and sends the ListElasticsearchInstanceTypes API request.
func (r ListElasticsearchInstanceTypesRequest) Send(ctx context.Context) (*ListElasticsearchInstanceTypesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListElasticsearchInstanceTypesOutput), nil
}

// ListElasticsearchInstanceTypesRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// List all Elasticsearch instance types that are supported for given ElasticsearchVersion
//
//    // Example sending a request using the ListElasticsearchInstanceTypesRequest method.
//    req := client.ListElasticsearchInstanceTypesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) ListElasticsearchInstanceTypesRequest(input *ListElasticsearchInstanceTypesInput) ListElasticsearchInstanceTypesRequest {
	op := &aws.Operation{
		Name:       opListElasticsearchInstanceTypes,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/instanceTypes/{ElasticsearchVersion}",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListElasticsearchInstanceTypesInput{}
	}

	output := &ListElasticsearchInstanceTypesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListElasticsearchInstanceTypesRequest{Request: req, Input: input, Copy: c.ListElasticsearchInstanceTypesRequest}
}

// Paginate pages iterates over the pages of a ListElasticsearchInstanceTypesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListElasticsearchInstanceTypes operation.
//		req := client.ListElasticsearchInstanceTypesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListElasticsearchInstanceTypesRequest) Paginate(opts ...aws.Option) ListElasticsearchInstanceTypesPager {
	return ListElasticsearchInstanceTypesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListElasticsearchInstanceTypesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListElasticsearchInstanceTypesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListElasticsearchInstanceTypesPager struct {
	aws.Pager
}

func (p *ListElasticsearchInstanceTypesPager) CurrentPage() *ListElasticsearchInstanceTypesOutput {
	return p.Pager.CurrentPage().(*ListElasticsearchInstanceTypesOutput)
}

const opListElasticsearchVersions = "ListElasticsearchVersions"

// ListElasticsearchVersionsRequest is a API request type for the ListElasticsearchVersions API operation.
type ListElasticsearchVersionsRequest struct {
	*aws.Request
	Input *ListElasticsearchVersionsInput
	Copy  func(*ListElasticsearchVersionsInput) ListElasticsearchVersionsRequest
}

// Send marshals and sends the ListElasticsearchVersions API request.
func (r ListElasticsearchVersionsRequest) Send(ctx context.Context) (*ListElasticsearchVersionsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListElasticsearchVersionsOutput), nil
}

// ListElasticsearchVersionsRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// List all supported Elasticsearch versions
//
//    // Example sending a request using the ListElasticsearchVersionsRequest method.
//    req := client.ListElasticsearchVersionsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) ListElasticsearchVersionsRequest(input *ListElasticsearchVersionsInput) ListElasticsearchVersionsRequest {
	op := &aws.Operation{
		Name:       opListElasticsearchVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/es/versions",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListElasticsearchVersionsInput{}
	}

	output := &ListElasticsearchVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListElasticsearchVersionsRequest{Request: req, Input: input, Copy: c.ListElasticsearchVersionsRequest}
}

// Paginate pages iterates over the pages of a ListElasticsearchVersionsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListElasticsearchVersions operation.
//		req := client.ListElasticsearchVersionsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListElasticsearchVersionsRequest) Paginate(opts ...aws.Option) ListElasticsearchVersionsPager {
	return ListElasticsearchVersionsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListElasticsearchVersionsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListElasticsearchVersionsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListElasticsearchVersionsPager struct {
	aws.Pager
}

func (p *ListElasticsearchVersionsPager) CurrentPage() *ListElasticsearchVersionsOutput {
	return p.Pager.CurrentPage().(*ListElasticsearchVersionsOutput)
}

const opListTags = "ListTags"

// ListTagsRequest is a API request type for the ListTags API operation.
type ListTagsRequest struct {
	*aws.Request
	Input *ListTagsInput
	Copy  func(*ListTagsInput) ListTagsRequest
}

// Send marshals and sends the ListTags API request.
func (r ListTagsRequest) Send(ctx context.Context) (*ListTagsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTagsOutput), nil
}

// ListTagsRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Returns all tags for the given Elasticsearch domain.
//
//    // Example sending a request using the ListTagsRequest method.
//    req := client.ListTagsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) ListTagsRequest(input *ListTagsInput) ListTagsRequest {
	op := &aws.Operation{
		Name:       opListTags,
		HTTPMethod: "GET",
		HTTPPath:   "/2015-01-01/tags/",
	}

	if input == nil {
		input = &ListTagsInput{}
	}

	output := &ListTagsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTagsRequest{Request: req, Input: input, Copy: c.ListTagsRequest}
}

const opPurchaseReservedElasticsearchInstanceOffering = "PurchaseReservedElasticsearchInstanceOffering"

// PurchaseReservedElasticsearchInstanceOfferingRequest is a API request type for the PurchaseReservedElasticsearchInstanceOffering API operation.
type PurchaseReservedElasticsearchInstanceOfferingRequest struct {
	*aws.Request
	Input *PurchaseReservedElasticsearchInstanceOfferingInput
	Copy  func(*PurchaseReservedElasticsearchInstanceOfferingInput) PurchaseReservedElasticsearchInstanceOfferingRequest
}

// Send marshals and sends the PurchaseReservedElasticsearchInstanceOffering API request.
func (r PurchaseReservedElasticsearchInstanceOfferingRequest) Send(ctx context.Context) (*PurchaseReservedElasticsearchInstanceOfferingOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PurchaseReservedElasticsearchInstanceOfferingOutput), nil
}

// PurchaseReservedElasticsearchInstanceOfferingRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Allows you to purchase reserved Elasticsearch instances.
//
//    // Example sending a request using the PurchaseReservedElasticsearchInstanceOfferingRequest method.
//    req := client.PurchaseReservedElasticsearchInstanceOfferingRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) PurchaseReservedElasticsearchInstanceOfferingRequest(input *PurchaseReservedElasticsearchInstanceOfferingInput) PurchaseReservedElasticsearchInstanceOfferingRequest {
	op := &aws.Operation{
		Name:       opPurchaseReservedElasticsearchInstanceOffering,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/es/purchaseReservedInstanceOffering",
	}

	if input == nil {
		input = &PurchaseReservedElasticsearchInstanceOfferingInput{}
	}

	output := &PurchaseReservedElasticsearchInstanceOfferingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PurchaseReservedElasticsearchInstanceOfferingRequest{Request: req, Input: input, Copy: c.PurchaseReservedElasticsearchInstanceOfferingRequest}
}

const opRemoveTags = "RemoveTags"

// RemoveTagsRequest is a API request type for the RemoveTags API operation.
type RemoveTagsRequest struct {
	*aws.Request
	Input *RemoveTagsInput
	Copy  func(*RemoveTagsInput) RemoveTagsRequest
}

// Send marshals and sends the RemoveTags API request.
func (r RemoveTagsRequest) Send(ctx context.Context) (*RemoveTagsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RemoveTagsOutput), nil
}

// RemoveTagsRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Removes the specified set of tags from the specified Elasticsearch domain.
//
//    // Example sending a request using the RemoveTagsRequest method.
//    req := client.RemoveTagsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) RemoveTagsRequest(input *RemoveTagsInput) RemoveTagsRequest {
	op := &aws.Operation{
		Name:       opRemoveTags,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/tags-removal",
	}

	if input == nil {
		input = &RemoveTagsInput{}
	}

	output := &RemoveTagsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return RemoveTagsRequest{Request: req, Input: input, Copy: c.RemoveTagsRequest}
}

const opStartElasticsearchServiceSoftwareUpdate = "StartElasticsearchServiceSoftwareUpdate"

// StartElasticsearchServiceSoftwareUpdateRequest is a API request type for the StartElasticsearchServiceSoftwareUpdate API operation.
type StartElasticsearchServiceSoftwareUpdateRequest struct {
	*aws.Request
	Input *StartElasticsearchServiceSoftwareUpdateInput
	Copy  func(*StartElasticsearchServiceSoftwareUpdateInput) StartElasticsearchServiceSoftwareUpdateRequest
}

// Send marshals and sends the StartElasticsearchServiceSoftwareUpdate API request.
func (r StartElasticsearchServiceSoftwareUpdateRequest) Send(ctx context.Context) (*StartElasticsearchServiceSoftwareUpdateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*StartElasticsearchServiceSoftwareUpdateOutput), nil
}

// StartElasticsearchServiceSoftwareUpdateRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Schedules a service software update for an Amazon ES domain.
//
//    // Example sending a request using the StartElasticsearchServiceSoftwareUpdateRequest method.
//    req := client.StartElasticsearchServiceSoftwareUpdateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) StartElasticsearchServiceSoftwareUpdateRequest(input *StartElasticsearchServiceSoftwareUpdateInput) StartElasticsearchServiceSoftwareUpdateRequest {
	op := &aws.Operation{
		Name:       opStartElasticsearchServiceSoftwareUpdate,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/es/serviceSoftwareUpdate/start",
	}

	if input == nil {
		input = &StartElasticsearchServiceSoftwareUpdateInput{}
	}

	output := &StartElasticsearchServiceSoftwareUpdateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return StartElasticsearchServiceSoftwareUpdateRequest{Request: req, Input: input, Copy: c.StartElasticsearchServiceSoftwareUpdateRequest}
}

const opUpdateElasticsearchDomainConfig = "UpdateElasticsearchDomainConfig"

// UpdateElasticsearchDomainConfigRequest is a API request type for the UpdateElasticsearchDomainConfig API operation.
type UpdateElasticsearchDomainConfigRequest struct {
	*aws.Request
	Input *UpdateElasticsearchDomainConfigInput
	Copy  func(*UpdateElasticsearchDomainConfigInput) UpdateElasticsearchDomainConfigRequest
}

// Send marshals and sends the UpdateElasticsearchDomainConfig API request.
func (r UpdateElasticsearchDomainConfigRequest) Send(ctx context.Context) (*UpdateElasticsearchDomainConfigOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateElasticsearchDomainConfigOutput), nil
}

// UpdateElasticsearchDomainConfigRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Modifies the cluster configuration of the specified Elasticsearch domain,
// setting as setting the instance type and the number of instances.
//
//    // Example sending a request using the UpdateElasticsearchDomainConfigRequest method.
//    req := client.UpdateElasticsearchDomainConfigRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) UpdateElasticsearchDomainConfigRequest(input *UpdateElasticsearchDomainConfigInput) UpdateElasticsearchDomainConfigRequest {
	op := &aws.Operation{
		Name:       opUpdateElasticsearchDomainConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/es/domain/{DomainName}/config",
	}

	if input == nil {
		input = &UpdateElasticsearchDomainConfigInput{}
	}

	output := &UpdateElasticsearchDomainConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateElasticsearchDomainConfigRequest{Request: req, Input: input, Copy: c.UpdateElasticsearchDomainConfigRequest}
}

const opUpgradeElasticsearchDomain = "UpgradeElasticsearchDomain"

// UpgradeElasticsearchDomainRequest is a API request type for the UpgradeElasticsearchDomain API operation.
type UpgradeElasticsearchDomainRequest struct {
	*aws.Request
	Input *UpgradeElasticsearchDomainInput
	Copy  func(*UpgradeElasticsearchDomainInput) UpgradeElasticsearchDomainRequest
}

// Send marshals and sends the UpgradeElasticsearchDomain API request.
func (r UpgradeElasticsearchDomainRequest) Send(ctx context.Context) (*UpgradeElasticsearchDomainOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpgradeElasticsearchDomainOutput), nil
}

// UpgradeElasticsearchDomainRequest returns a request value for making API operation for
// Amazon Elasticsearch Service.
//
// Allows you to either upgrade your domain or perform an Upgrade eligibility
// check to a compatible Elasticsearch version.
//
//    // Example sending a request using the UpgradeElasticsearchDomainRequest method.
//    req := client.UpgradeElasticsearchDomainRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *ElasticsearchService) UpgradeElasticsearchDomainRequest(input *UpgradeElasticsearchDomainInput) UpgradeElasticsearchDomainRequest {
	op := &aws.Operation{
		Name:       opUpgradeElasticsearchDomain,
		HTTPMethod: "POST",
		HTTPPath:   "/2015-01-01/es/upgradeDomain",
	}

	if input == nil {
		input = &UpgradeElasticsearchDomainInput{}
	}

	output := &UpgradeElasticsearchDomainOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpgradeElasticsearchDomainRequest{Request: req, Input: input, Copy: c.UpgradeElasticsearchDomainRequest}
}

// The configured access rules for the domain's document and search endpoints,
// and the current status of those rules.
type AccessPoliciesStatus struct {
	_ struct{} `type:"structure"`

	// The access policy configured for the Elasticsearch domain. Access policies
	// may be resource-based, IP-based, or IAM-based. See  Configuring Access Policies
	// (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-access-policies)for
	// more information.
	//
	// Options is a required field
	Options *string `type:"string" required:"true"`

	// The status of the access policy for the Elasticsearch domain. See OptionStatus
	// for the status information that's included.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s AccessPoliciesStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AccessPoliciesStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AccessPoliciesStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := *s.Options

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Options", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Container for the parameters to the AddTags operation. Specify the tags that
// you want to attach to the Elasticsearch domain.
type AddTagsInput struct {
	_ struct{} `type:"structure"`

	// Specify the ARN for which you want to add the tags.
	//
	// ARN is a required field
	ARN *string `type:"string" required:"true"`

	// List of Tag that need to be added for the Elasticsearch domain.
	//
	// TagList is a required field
	TagList []Tag `type:"list" required:"true"`
}

// String returns the string representation
func (s AddTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AddTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AddTagsInput"}

	if s.ARN == nil {
		invalidParams.Add(aws.NewErrParamRequired("ARN"))
	}

	if s.TagList == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagList"))
	}
	if s.TagList != nil {
		for i, v := range s.TagList {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TagList", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddTagsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ARN != nil {
		v := *s.ARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TagList) > 0 {
		v := s.TagList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TagList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type AddTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s AddTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AddTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AddTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AddTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// List of limits that are specific to a given InstanceType and for each of
// it's InstanceRole .
type AdditionalLimit struct {
	_ struct{} `type:"structure"`

	// Name of Additional Limit is specific to a given InstanceType and for each
	// of it's InstanceRole etc. Attributes and their details: MaximumNumberOfDataNodesSupported
	// This attribute will be present in Master node only to specify how much data
	// nodes upto which given ESPartitionInstanceTypecan support as master node. MaximumNumberOfDataNodesWithoutMasterNode
	// This attribute will be present in Data node only to specify how much data
	// nodes of given ESPartitionInstanceType
	LimitName *string `type:"string"`

	// Value for given AdditionalLimit$LimitName .
	LimitValues []string `type:"list"`
}

// String returns the string representation
func (s AdditionalLimit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AdditionalLimit) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AdditionalLimit) MarshalFields(e protocol.FieldEncoder) error {
	if s.LimitName != nil {
		v := *s.LimitName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LimitName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.LimitValues) > 0 {
		v := s.LimitValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "LimitValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Status of the advanced options for the specified Elasticsearch domain. Currently,
// the following advanced options are available:
//
//    * Option to allow references to indices in an HTTP request body. Must
//    be false when configuring access to individual sub-resources. By default,
//    the value is true. See Configuration Advanced Options (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-advanced-options)
//    for more information.
//    * Option to specify the percentage of heap space that is allocated to
//    field data. By default, this setting is unbounded.
// For more information, see Configuring Advanced Options (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-advanced-options).
type AdvancedOptionsStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the status of advanced options for the specified Elasticsearch
	// domain.
	//
	// Options is a required field
	Options map[string]string `type:"map" required:"true"`

	// Specifies the status of OptionStatus for advanced options for the specified
	// Elasticsearch domain.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s AdvancedOptionsStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AdvancedOptionsStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AdvancedOptionsStatus) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Options) > 0 {
		v := s.Options

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Options", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Container for the parameters to the CancelElasticsearchServiceSoftwareUpdate
// operation. Specifies the name of the Elasticsearch domain that you wish to
// cancel a service software update on.
type CancelElasticsearchServiceSoftwareUpdateInput struct {
	_ struct{} `type:"structure"`

	// The name of the domain that you want to stop the latest service software
	// update on.
	//
	// DomainName is a required field
	DomainName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s CancelElasticsearchServiceSoftwareUpdateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelElasticsearchServiceSoftwareUpdateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CancelElasticsearchServiceSoftwareUpdateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CancelElasticsearchServiceSoftwareUpdateInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelElasticsearchServiceSoftwareUpdateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The result of a CancelElasticsearchServiceSoftwareUpdate operation. Contains
// the status of the update.
type CancelElasticsearchServiceSoftwareUpdateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current status of the Elasticsearch service software update.
	ServiceSoftwareOptions *ServiceSoftwareOptions `type:"structure"`
}

// String returns the string representation
func (s CancelElasticsearchServiceSoftwareUpdateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancelElasticsearchServiceSoftwareUpdateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CancelElasticsearchServiceSoftwareUpdateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CancelElasticsearchServiceSoftwareUpdateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ServiceSoftwareOptions != nil {
		v := s.ServiceSoftwareOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ServiceSoftwareOptions", v, metadata)
	}
	return nil
}

// Options to specify the Cognito user and identity pools for Kibana authentication.
// For more information, see Amazon Cognito Authentication for Kibana (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-cognito-auth.html).
type CognitoOptions struct {
	_ struct{} `type:"structure"`

	// Specifies the option to enable Cognito for Kibana authentication.
	Enabled *bool `type:"boolean"`

	// Specifies the Cognito identity pool ID for Kibana authentication.
	IdentityPoolId *string `min:"1" type:"string"`

	// Specifies the role ARN that provides Elasticsearch permissions for accessing
	// Cognito resources.
	RoleArn *string `min:"20" type:"string"`

	// Specifies the Cognito user pool ID for Kibana authentication.
	UserPoolId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s CognitoOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CognitoOptions) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CognitoOptions) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CognitoOptions"}
	if s.IdentityPoolId != nil && len(*s.IdentityPoolId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("IdentityPoolId", 1))
	}
	if s.RoleArn != nil && len(*s.RoleArn) < 20 {
		invalidParams.Add(aws.NewErrParamMinLen("RoleArn", 20))
	}
	if s.UserPoolId != nil && len(*s.UserPoolId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("UserPoolId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CognitoOptions) MarshalFields(e protocol.FieldEncoder) error {
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Enabled", protocol.BoolValue(v), metadata)
	}
	if s.IdentityPoolId != nil {
		v := *s.IdentityPoolId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IdentityPoolId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UserPoolId != nil {
		v := *s.UserPoolId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UserPoolId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Status of the Cognito options for the specified Elasticsearch domain.
type CognitoOptionsStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the Cognito options for the specified Elasticsearch domain.
	//
	// Options is a required field
	Options *CognitoOptions `type:"structure" required:"true"`

	// Specifies the status of the Cognito options for the specified Elasticsearch
	// domain.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s CognitoOptionsStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CognitoOptionsStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CognitoOptionsStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := s.Options

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Options", v, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// A map from an ElasticsearchVersion to a list of compatible ElasticsearchVersion
// s to which the domain can be upgraded.
type CompatibleVersionsMap struct {
	_ struct{} `type:"structure"`

	// The current version of Elasticsearch on which a domain is.
	SourceVersion *string `type:"string"`

	// List of supported elastic search versions.
	TargetVersions []string `type:"list"`
}

// String returns the string representation
func (s CompatibleVersionsMap) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CompatibleVersionsMap) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CompatibleVersionsMap) MarshalFields(e protocol.FieldEncoder) error {
	if s.SourceVersion != nil {
		v := *s.SourceVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SourceVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TargetVersions) > 0 {
		v := s.TargetVersions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TargetVersions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type CreateElasticsearchDomainInput struct {
	_ struct{} `type:"structure"`

	// IAM access policy as a JSON-formatted string.
	AccessPolicies *string `type:"string"`

	// Option to allow references to indices in an HTTP request body. Must be false
	// when configuring access to individual sub-resources. By default, the value
	// is true. See Configuration Advanced Options (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-advanced-options)
	// for more information.
	AdvancedOptions map[string]string `type:"map"`

	// Options to specify the Cognito user and identity pools for Kibana authentication.
	// For more information, see Amazon Cognito Authentication for Kibana (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-cognito-auth.html).
	CognitoOptions *CognitoOptions `type:"structure"`

	// The name of the Elasticsearch domain that you are creating. Domain names
	// are unique across the domains owned by an account within an AWS region. Domain
	// names must start with a letter or number and can contain the following characters:
	// a-z (lowercase), 0-9, and - (hyphen).
	//
	// DomainName is a required field
	DomainName *string `min:"3" type:"string" required:"true"`

	// Options to enable, disable and specify the type and size of EBS storage volumes.
	EBSOptions *EBSOptions `type:"structure"`

	// Configuration options for an Elasticsearch domain. Specifies the instance
	// type and number of instances in the domain cluster.
	ElasticsearchClusterConfig *ElasticsearchClusterConfig `type:"structure"`

	// String of format X.Y to specify version for the Elasticsearch domain eg.
	// "1.5" or "2.3". For more information, see Creating Elasticsearch Domains
	// (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomains)
	// in the Amazon Elasticsearch Service Developer Guide.
	ElasticsearchVersion *string `type:"string"`

	// Specifies the Encryption At Rest Options.
	EncryptionAtRestOptions *EncryptionAtRestOptions `type:"structure"`

	// Map of LogType and LogPublishingOption, each containing options to publish
	// a given type of Elasticsearch log.
	LogPublishingOptions map[string]LogPublishingOption `type:"map"`

	// Specifies the NodeToNodeEncryptionOptions.
	NodeToNodeEncryptionOptions *NodeToNodeEncryptionOptions `type:"structure"`

	// Option to set time, in UTC format, of the daily automated snapshot. Default
	// value is 0 hours.
	SnapshotOptions *SnapshotOptions `type:"structure"`

	// Options to specify the subnets and security groups for VPC endpoint. For
	// more information, see Creating a VPC (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-creating-vpc)
	// in VPC Endpoints for Amazon Elasticsearch Service Domains
	VPCOptions *VPCOptions `type:"structure"`
}

// String returns the string representation
func (s CreateElasticsearchDomainInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateElasticsearchDomainInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateElasticsearchDomainInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateElasticsearchDomainInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}
	if s.CognitoOptions != nil {
		if err := s.CognitoOptions.Validate(); err != nil {
			invalidParams.AddNested("CognitoOptions", err.(aws.ErrInvalidParams))
		}
	}
	if s.EncryptionAtRestOptions != nil {
		if err := s.EncryptionAtRestOptions.Validate(); err != nil {
			invalidParams.AddNested("EncryptionAtRestOptions", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateElasticsearchDomainInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccessPolicies != nil {
		v := *s.AccessPolicies

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccessPolicies", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.AdvancedOptions) > 0 {
		v := s.AdvancedOptions

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "AdvancedOptions", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.CognitoOptions != nil {
		v := s.CognitoOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CognitoOptions", v, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EBSOptions != nil {
		v := s.EBSOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EBSOptions", v, metadata)
	}
	if s.ElasticsearchClusterConfig != nil {
		v := s.ElasticsearchClusterConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ElasticsearchClusterConfig", v, metadata)
	}
	if s.ElasticsearchVersion != nil {
		v := *s.ElasticsearchVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ElasticsearchVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EncryptionAtRestOptions != nil {
		v := s.EncryptionAtRestOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EncryptionAtRestOptions", v, metadata)
	}
	if len(s.LogPublishingOptions) > 0 {
		v := s.LogPublishingOptions

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "LogPublishingOptions", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if s.NodeToNodeEncryptionOptions != nil {
		v := s.NodeToNodeEncryptionOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "NodeToNodeEncryptionOptions", v, metadata)
	}
	if s.SnapshotOptions != nil {
		v := s.SnapshotOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SnapshotOptions", v, metadata)
	}
	if s.VPCOptions != nil {
		v := s.VPCOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "VPCOptions", v, metadata)
	}
	return nil
}

// The result of a CreateElasticsearchDomain operation. Contains the status
// of the newly created Elasticsearch domain.
type CreateElasticsearchDomainOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The status of the newly created Elasticsearch domain.
	DomainStatus *ElasticsearchDomainStatus `type:"structure"`
}

// String returns the string representation
func (s CreateElasticsearchDomainOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateElasticsearchDomainOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateElasticsearchDomainOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateElasticsearchDomainOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainStatus != nil {
		v := s.DomainStatus

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DomainStatus", v, metadata)
	}
	return nil
}

// Container for the parameters to the DeleteElasticsearchDomain operation.
// Specifies the name of the Elasticsearch domain that you want to delete.
type DeleteElasticsearchDomainInput struct {
	_ struct{} `type:"structure"`

	// The name of the Elasticsearch domain that you want to permanently delete.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"DomainName" min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteElasticsearchDomainInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteElasticsearchDomainInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteElasticsearchDomainInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteElasticsearchDomainInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteElasticsearchDomainInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The result of a DeleteElasticsearchDomain request. Contains the status of
// the pending deletion, or no status if the domain and all of its resources
// have been deleted.
type DeleteElasticsearchDomainOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The status of the Elasticsearch domain being deleted.
	DomainStatus *ElasticsearchDomainStatus `type:"structure"`
}

// String returns the string representation
func (s DeleteElasticsearchDomainOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteElasticsearchDomainOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteElasticsearchDomainOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteElasticsearchDomainOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainStatus != nil {
		v := s.DomainStatus

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DomainStatus", v, metadata)
	}
	return nil
}

type DeleteElasticsearchServiceRoleInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DeleteElasticsearchServiceRoleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteElasticsearchServiceRoleInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteElasticsearchServiceRoleInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

type DeleteElasticsearchServiceRoleOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteElasticsearchServiceRoleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteElasticsearchServiceRoleOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteElasticsearchServiceRoleOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteElasticsearchServiceRoleOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Container for the parameters to the DescribeElasticsearchDomainConfig operation.
// Specifies the domain name for which you want configuration information.
type DescribeElasticsearchDomainConfigInput struct {
	_ struct{} `type:"structure"`

	// The Elasticsearch domain that you want to get information about.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"DomainName" min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeElasticsearchDomainConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeElasticsearchDomainConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeElasticsearchDomainConfigInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeElasticsearchDomainConfigInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeElasticsearchDomainConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The result of a DescribeElasticsearchDomainConfig request. Contains the configuration
// information of the requested domain.
type DescribeElasticsearchDomainConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The configuration information of the domain requested in the DescribeElasticsearchDomainConfig
	// request.
	//
	// DomainConfig is a required field
	DomainConfig *ElasticsearchDomainConfig `type:"structure" required:"true"`
}

// String returns the string representation
func (s DescribeElasticsearchDomainConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeElasticsearchDomainConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeElasticsearchDomainConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeElasticsearchDomainConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainConfig != nil {
		v := s.DomainConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DomainConfig", v, metadata)
	}
	return nil
}

// Container for the parameters to the DescribeElasticsearchDomain operation.
type DescribeElasticsearchDomainInput struct {
	_ struct{} `type:"structure"`

	// The name of the Elasticsearch domain for which you want information.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"DomainName" min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeElasticsearchDomainInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeElasticsearchDomainInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeElasticsearchDomainInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeElasticsearchDomainInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeElasticsearchDomainInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The result of a DescribeElasticsearchDomain request. Contains the status
// of the domain specified in the request.
type DescribeElasticsearchDomainOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current status of the Elasticsearch domain.
	//
	// DomainStatus is a required field
	DomainStatus *ElasticsearchDomainStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s DescribeElasticsearchDomainOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeElasticsearchDomainOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeElasticsearchDomainOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeElasticsearchDomainOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainStatus != nil {
		v := s.DomainStatus

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DomainStatus", v, metadata)
	}
	return nil
}

// Container for the parameters to the DescribeElasticsearchDomains operation.
// By default, the API returns the status of all Elasticsearch domains.
type DescribeElasticsearchDomainsInput struct {
	_ struct{} `type:"structure"`

	// The Elasticsearch domains for which you want information.
	//
	// DomainNames is a required field
	DomainNames []string `type:"list" required:"true"`
}

// String returns the string representation
func (s DescribeElasticsearchDomainsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeElasticsearchDomainsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeElasticsearchDomainsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeElasticsearchDomainsInput"}

	if s.DomainNames == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainNames"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeElasticsearchDomainsInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.DomainNames) > 0 {
		v := s.DomainNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "DomainNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// The result of a DescribeElasticsearchDomains request. Contains the status
// of the specified domains or all domains owned by the account.
type DescribeElasticsearchDomainsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The status of the domains requested in the DescribeElasticsearchDomains request.
	//
	// DomainStatusList is a required field
	DomainStatusList []ElasticsearchDomainStatus `type:"list" required:"true"`
}

// String returns the string representation
func (s DescribeElasticsearchDomainsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeElasticsearchDomainsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeElasticsearchDomainsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeElasticsearchDomainsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DomainStatusList) > 0 {
		v := s.DomainStatusList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "DomainStatusList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Container for the parameters to DescribeElasticsearchInstanceTypeLimits operation.
type DescribeElasticsearchInstanceTypeLimitsInput struct {
	_ struct{} `type:"structure"`

	// DomainName represents the name of the Domain that we are trying to modify.
	// This should be present only if we are querying for Elasticsearch Limits for
	// existing domain.
	DomainName *string `location:"querystring" locationName:"domainName" min:"3" type:"string"`

	// Version of Elasticsearch for which Limits are needed.
	//
	// ElasticsearchVersion is a required field
	ElasticsearchVersion *string `location:"uri" locationName:"ElasticsearchVersion" type:"string" required:"true"`

	// The instance type for an Elasticsearch cluster for which Elasticsearch Limits
	// are needed.
	//
	// InstanceType is a required field
	InstanceType ESPartitionInstanceType `location:"uri" locationName:"InstanceType" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s DescribeElasticsearchInstanceTypeLimitsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeElasticsearchInstanceTypeLimitsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeElasticsearchInstanceTypeLimitsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeElasticsearchInstanceTypeLimitsInput"}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if s.ElasticsearchVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("ElasticsearchVersion"))
	}
	if len(s.InstanceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("InstanceType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeElasticsearchInstanceTypeLimitsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ElasticsearchVersion != nil {
		v := *s.ElasticsearchVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ElasticsearchVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.InstanceType) > 0 {
		v := s.InstanceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "InstanceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "domainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for the parameters received from DescribeElasticsearchInstanceTypeLimits
// operation.
type DescribeElasticsearchInstanceTypeLimitsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Map of Role of the Instance and Limits that are applicable. Role performed
	// by given Instance in Elasticsearch can be one of the following: Data: If
	// the given InstanceType is used as Data node
	// Master: If the given InstanceType is used as Master node
	LimitsByRole map[string]Limits `type:"map"`
}

// String returns the string representation
func (s DescribeElasticsearchInstanceTypeLimitsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeElasticsearchInstanceTypeLimitsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeElasticsearchInstanceTypeLimitsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeElasticsearchInstanceTypeLimitsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.LimitsByRole) > 0 {
		v := s.LimitsByRole

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "LimitsByRole", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	return nil
}

// Container for parameters to DescribeReservedElasticsearchInstanceOfferings
type DescribeReservedElasticsearchInstanceOfferingsInput struct {
	_ struct{} `type:"structure"`

	// Set this value to limit the number of results returned. If not specified,
	// defaults to 100.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// NextToken should be sent in case if earlier API call produced result containing
	// NextToken. It is used for pagination.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The offering identifier filter value. Use this parameter to show only the
	// available offering that matches the specified reservation identifier.
	ReservedElasticsearchInstanceOfferingId *string `location:"querystring" locationName:"offeringId" type:"string"`
}

// String returns the string representation
func (s DescribeReservedElasticsearchInstanceOfferingsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeReservedElasticsearchInstanceOfferingsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeReservedElasticsearchInstanceOfferingsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ReservedElasticsearchInstanceOfferingId != nil {
		v := *s.ReservedElasticsearchInstanceOfferingId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "offeringId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for results from DescribeReservedElasticsearchInstanceOfferings
type DescribeReservedElasticsearchInstanceOfferingsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Provides an identifier to allow retrieval of paginated results.
	NextToken *string `type:"string"`

	// List of reserved Elasticsearch instance offerings
	ReservedElasticsearchInstanceOfferings []ReservedElasticsearchInstanceOffering `type:"list"`
}

// String returns the string representation
func (s DescribeReservedElasticsearchInstanceOfferingsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeReservedElasticsearchInstanceOfferingsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeReservedElasticsearchInstanceOfferingsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeReservedElasticsearchInstanceOfferingsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ReservedElasticsearchInstanceOfferings) > 0 {
		v := s.ReservedElasticsearchInstanceOfferings

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ReservedElasticsearchInstanceOfferings", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Container for parameters to DescribeReservedElasticsearchInstances
type DescribeReservedElasticsearchInstancesInput struct {
	_ struct{} `type:"structure"`

	// Set this value to limit the number of results returned. If not specified,
	// defaults to 100.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// NextToken should be sent in case if earlier API call produced result containing
	// NextToken. It is used for pagination.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`

	// The reserved instance identifier filter value. Use this parameter to show
	// only the reservation that matches the specified reserved Elasticsearch instance
	// ID.
	ReservedElasticsearchInstanceId *string `location:"querystring" locationName:"reservationId" type:"string"`
}

// String returns the string representation
func (s DescribeReservedElasticsearchInstancesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeReservedElasticsearchInstancesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeReservedElasticsearchInstancesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ReservedElasticsearchInstanceId != nil {
		v := *s.ReservedElasticsearchInstanceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "reservationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for results from DescribeReservedElasticsearchInstances
type DescribeReservedElasticsearchInstancesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Provides an identifier to allow retrieval of paginated results.
	NextToken *string `type:"string"`

	// List of reserved Elasticsearch instances.
	ReservedElasticsearchInstances []ReservedElasticsearchInstance `type:"list"`
}

// String returns the string representation
func (s DescribeReservedElasticsearchInstancesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeReservedElasticsearchInstancesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeReservedElasticsearchInstancesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeReservedElasticsearchInstancesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ReservedElasticsearchInstances) > 0 {
		v := s.ReservedElasticsearchInstances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ReservedElasticsearchInstances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type DomainInfo struct {
	_ struct{} `type:"structure"`

	// Specifies the DomainName.
	DomainName *string `min:"3" type:"string"`
}

// String returns the string representation
func (s DomainInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DomainInfo) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DomainInfo) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Options to enable, disable, and specify the properties of EBS storage volumes.
// For more information, see  Configuring EBS-based Storage (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-ebs).
type EBSOptions struct {
	_ struct{} `type:"structure"`

	// Specifies whether EBS-based storage is enabled.
	EBSEnabled *bool `type:"boolean"`

	// Specifies the IOPD for a Provisioned IOPS EBS volume (SSD).
	Iops *int64 `type:"integer"`

	// Integer to specify the size of an EBS volume.
	VolumeSize *int64 `type:"integer"`

	// Specifies the volume type for EBS-based storage.
	VolumeType VolumeType `type:"string" enum:"true"`
}

// String returns the string representation
func (s EBSOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EBSOptions) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EBSOptions) MarshalFields(e protocol.FieldEncoder) error {
	if s.EBSEnabled != nil {
		v := *s.EBSEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EBSEnabled", protocol.BoolValue(v), metadata)
	}
	if s.Iops != nil {
		v := *s.Iops

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Iops", protocol.Int64Value(v), metadata)
	}
	if s.VolumeSize != nil {
		v := *s.VolumeSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VolumeSize", protocol.Int64Value(v), metadata)
	}
	if len(s.VolumeType) > 0 {
		v := s.VolumeType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VolumeType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Status of the EBS options for the specified Elasticsearch domain.
type EBSOptionsStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the EBS options for the specified Elasticsearch domain.
	//
	// Options is a required field
	Options *EBSOptions `type:"structure" required:"true"`

	// Specifies the status of the EBS options for the specified Elasticsearch domain.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s EBSOptionsStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EBSOptionsStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EBSOptionsStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := s.Options

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Options", v, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Specifies the configuration for the domain cluster, such as the type and
// number of instances.
type ElasticsearchClusterConfig struct {
	_ struct{} `type:"structure"`

	// Total number of dedicated master nodes, active and on standby, for the cluster.
	DedicatedMasterCount *int64 `type:"integer"`

	// A boolean value to indicate whether a dedicated master node is enabled. See
	// About Dedicated Master Nodes (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains.html#es-managedomains-dedicatedmasternodes)
	// for more information.
	DedicatedMasterEnabled *bool `type:"boolean"`

	// The instance type for a dedicated master node.
	DedicatedMasterType ESPartitionInstanceType `type:"string" enum:"true"`

	// The number of instances in the specified domain cluster.
	InstanceCount *int64 `type:"integer"`

	// The instance type for an Elasticsearch cluster.
	InstanceType ESPartitionInstanceType `type:"string" enum:"true"`

	// A boolean value to indicate whether zone awareness is enabled. See About
	// Zone Awareness (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains.html#es-managedomains-zoneawareness)
	// for more information.
	ZoneAwarenessEnabled *bool `type:"boolean"`
}

// String returns the string representation
func (s ElasticsearchClusterConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ElasticsearchClusterConfig) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ElasticsearchClusterConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.DedicatedMasterCount != nil {
		v := *s.DedicatedMasterCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DedicatedMasterCount", protocol.Int64Value(v), metadata)
	}
	if s.DedicatedMasterEnabled != nil {
		v := *s.DedicatedMasterEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DedicatedMasterEnabled", protocol.BoolValue(v), metadata)
	}
	if len(s.DedicatedMasterType) > 0 {
		v := s.DedicatedMasterType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DedicatedMasterType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.InstanceCount != nil {
		v := *s.InstanceCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InstanceCount", protocol.Int64Value(v), metadata)
	}
	if len(s.InstanceType) > 0 {
		v := s.InstanceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InstanceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.ZoneAwarenessEnabled != nil {
		v := *s.ZoneAwarenessEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ZoneAwarenessEnabled", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Specifies the configuration status for the specified Elasticsearch domain.
type ElasticsearchClusterConfigStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the cluster configuration for the specified Elasticsearch domain.
	//
	// Options is a required field
	Options *ElasticsearchClusterConfig `type:"structure" required:"true"`

	// Specifies the status of the configuration for the specified Elasticsearch
	// domain.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s ElasticsearchClusterConfigStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ElasticsearchClusterConfigStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ElasticsearchClusterConfigStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := s.Options

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Options", v, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// The configuration of an Elasticsearch domain.
type ElasticsearchDomainConfig struct {
	_ struct{} `type:"structure"`

	// IAM access policy as a JSON-formatted string.
	AccessPolicies *AccessPoliciesStatus `type:"structure"`

	// Specifies the AdvancedOptions for the domain. See Configuring Advanced Options
	// (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-advanced-options)
	// for more information.
	AdvancedOptions *AdvancedOptionsStatus `type:"structure"`

	// The CognitoOptions for the specified domain. For more information, see Amazon
	// Cognito Authentication for Kibana (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-cognito-auth.html).
	CognitoOptions *CognitoOptionsStatus `type:"structure"`

	// Specifies the EBSOptions for the Elasticsearch domain.
	EBSOptions *EBSOptionsStatus `type:"structure"`

	// Specifies the ElasticsearchClusterConfig for the Elasticsearch domain.
	ElasticsearchClusterConfig *ElasticsearchClusterConfigStatus `type:"structure"`

	// String of format X.Y to specify version for the Elasticsearch domain.
	ElasticsearchVersion *ElasticsearchVersionStatus `type:"structure"`

	// Specifies the EncryptionAtRestOptions for the Elasticsearch domain.
	EncryptionAtRestOptions *EncryptionAtRestOptionsStatus `type:"structure"`

	// Log publishing options for the given domain.
	LogPublishingOptions *LogPublishingOptionsStatus `type:"structure"`

	// Specifies the NodeToNodeEncryptionOptions for the Elasticsearch domain.
	NodeToNodeEncryptionOptions *NodeToNodeEncryptionOptionsStatus `type:"structure"`

	// Specifies the SnapshotOptions for the Elasticsearch domain.
	SnapshotOptions *SnapshotOptionsStatus `type:"structure"`

	// The VPCOptions for the specified domain. For more information, see VPC Endpoints
	// for Amazon Elasticsearch Service Domains (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html).
	VPCOptions *VPCDerivedInfoStatus `type:"structure"`
}

// String returns the string representation
func (s ElasticsearchDomainConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ElasticsearchDomainConfig) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ElasticsearchDomainConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccessPolicies != nil {
		v := s.AccessPolicies

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AccessPolicies", v, metadata)
	}
	if s.AdvancedOptions != nil {
		v := s.AdvancedOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AdvancedOptions", v, metadata)
	}
	if s.CognitoOptions != nil {
		v := s.CognitoOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CognitoOptions", v, metadata)
	}
	if s.EBSOptions != nil {
		v := s.EBSOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EBSOptions", v, metadata)
	}
	if s.ElasticsearchClusterConfig != nil {
		v := s.ElasticsearchClusterConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ElasticsearchClusterConfig", v, metadata)
	}
	if s.ElasticsearchVersion != nil {
		v := s.ElasticsearchVersion

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ElasticsearchVersion", v, metadata)
	}
	if s.EncryptionAtRestOptions != nil {
		v := s.EncryptionAtRestOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EncryptionAtRestOptions", v, metadata)
	}
	if s.LogPublishingOptions != nil {
		v := s.LogPublishingOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LogPublishingOptions", v, metadata)
	}
	if s.NodeToNodeEncryptionOptions != nil {
		v := s.NodeToNodeEncryptionOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "NodeToNodeEncryptionOptions", v, metadata)
	}
	if s.SnapshotOptions != nil {
		v := s.SnapshotOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SnapshotOptions", v, metadata)
	}
	if s.VPCOptions != nil {
		v := s.VPCOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "VPCOptions", v, metadata)
	}
	return nil
}

// The current status of an Elasticsearch domain.
type ElasticsearchDomainStatus struct {
	_ struct{} `type:"structure"`

	// The Amazon resource name (ARN) of an Elasticsearch domain. See Identifiers
	// for IAM Entities (http://docs.aws.amazon.com/IAM/latest/UserGuide/index.html?Using_Identifiers.html)
	// in Using AWS Identity and Access Management for more information.
	//
	// ARN is a required field
	ARN *string `type:"string" required:"true"`

	// IAM access policy as a JSON-formatted string.
	AccessPolicies *string `type:"string"`

	// Specifies the status of the AdvancedOptions
	AdvancedOptions map[string]string `type:"map"`

	// The CognitoOptions for the specified domain. For more information, see Amazon
	// Cognito Authentication for Kibana (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-cognito-auth.html).
	CognitoOptions *CognitoOptions `type:"structure"`

	// The domain creation status. True if the creation of an Elasticsearch domain
	// is complete. False if domain creation is still in progress.
	Created *bool `type:"boolean"`

	// The domain deletion status. True if a delete request has been received for
	// the domain but resource cleanup is still in progress. False if the domain
	// has not been deleted. Once domain deletion is complete, the status of the
	// domain is no longer returned.
	Deleted *bool `type:"boolean"`

	// The unique identifier for the specified Elasticsearch domain.
	//
	// DomainId is a required field
	DomainId *string `min:"1" type:"string" required:"true"`

	// The name of an Elasticsearch domain. Domain names are unique across the domains
	// owned by an account within an AWS region. Domain names start with a letter
	// or number and can contain the following characters: a-z (lowercase), 0-9,
	// and - (hyphen).
	//
	// DomainName is a required field
	DomainName *string `min:"3" type:"string" required:"true"`

	// The EBSOptions for the specified domain. See Configuring EBS-based Storage
	// (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-ebs)
	// for more information.
	EBSOptions *EBSOptions `type:"structure"`

	// The type and number of instances in the domain cluster.
	//
	// ElasticsearchClusterConfig is a required field
	ElasticsearchClusterConfig *ElasticsearchClusterConfig `type:"structure" required:"true"`

	ElasticsearchVersion *string `type:"string"`

	// Specifies the status of the EncryptionAtRestOptions.
	EncryptionAtRestOptions *EncryptionAtRestOptions `type:"structure"`

	// The Elasticsearch domain endpoint that you use to submit index and search
	// requests.
	Endpoint *string `type:"string"`

	// Map containing the Elasticsearch domain endpoints used to submit index and
	// search requests. Example key, value: 'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'.
	Endpoints map[string]string `type:"map"`

	// Log publishing options for the given domain.
	LogPublishingOptions map[string]LogPublishingOption `type:"map"`

	// Specifies the status of the NodeToNodeEncryptionOptions.
	NodeToNodeEncryptionOptions *NodeToNodeEncryptionOptions `type:"structure"`

	// The status of the Elasticsearch domain configuration. True if Amazon Elasticsearch
	// Service is processing configuration changes. False if the configuration is
	// active.
	Processing *bool `type:"boolean"`

	// The current status of the Elasticsearch domain's service software.
	ServiceSoftwareOptions *ServiceSoftwareOptions `type:"structure"`

	// Specifies the status of the SnapshotOptions
	SnapshotOptions *SnapshotOptions `type:"structure"`

	// The status of an Elasticsearch domain version upgrade. True if Amazon Elasticsearch
	// Service is undergoing a version upgrade. False if the configuration is active.
	UpgradeProcessing *bool `type:"boolean"`

	// The VPCOptions for the specified domain. For more information, see VPC Endpoints
	// for Amazon Elasticsearch Service Domains (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html).
	VPCOptions *VPCDerivedInfo `type:"structure"`
}

// String returns the string representation
func (s ElasticsearchDomainStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ElasticsearchDomainStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ElasticsearchDomainStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.ARN != nil {
		v := *s.ARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AccessPolicies != nil {
		v := *s.AccessPolicies

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccessPolicies", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.AdvancedOptions) > 0 {
		v := s.AdvancedOptions

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "AdvancedOptions", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.CognitoOptions != nil {
		v := s.CognitoOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CognitoOptions", v, metadata)
	}
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Created", protocol.BoolValue(v), metadata)
	}
	if s.Deleted != nil {
		v := *s.Deleted

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Deleted", protocol.BoolValue(v), metadata)
	}
	if s.DomainId != nil {
		v := *s.DomainId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EBSOptions != nil {
		v := s.EBSOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EBSOptions", v, metadata)
	}
	if s.ElasticsearchClusterConfig != nil {
		v := s.ElasticsearchClusterConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ElasticsearchClusterConfig", v, metadata)
	}
	if s.ElasticsearchVersion != nil {
		v := *s.ElasticsearchVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ElasticsearchVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EncryptionAtRestOptions != nil {
		v := s.EncryptionAtRestOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EncryptionAtRestOptions", v, metadata)
	}
	if s.Endpoint != nil {
		v := *s.Endpoint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Endpoint", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Endpoints) > 0 {
		v := s.Endpoints

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Endpoints", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.LogPublishingOptions) > 0 {
		v := s.LogPublishingOptions

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "LogPublishingOptions", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if s.NodeToNodeEncryptionOptions != nil {
		v := s.NodeToNodeEncryptionOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "NodeToNodeEncryptionOptions", v, metadata)
	}
	if s.Processing != nil {
		v := *s.Processing

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Processing", protocol.BoolValue(v), metadata)
	}
	if s.ServiceSoftwareOptions != nil {
		v := s.ServiceSoftwareOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ServiceSoftwareOptions", v, metadata)
	}
	if s.SnapshotOptions != nil {
		v := s.SnapshotOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SnapshotOptions", v, metadata)
	}
	if s.UpgradeProcessing != nil {
		v := *s.UpgradeProcessing

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradeProcessing", protocol.BoolValue(v), metadata)
	}
	if s.VPCOptions != nil {
		v := s.VPCOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "VPCOptions", v, metadata)
	}
	return nil
}

// Status of the Elasticsearch version options for the specified Elasticsearch
// domain.
type ElasticsearchVersionStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the Elasticsearch version for the specified Elasticsearch domain.
	//
	// Options is a required field
	Options *string `type:"string" required:"true"`

	// Specifies the status of the Elasticsearch version options for the specified
	// Elasticsearch domain.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s ElasticsearchVersionStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ElasticsearchVersionStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ElasticsearchVersionStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := *s.Options

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Options", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Specifies the Encryption At Rest Options.
type EncryptionAtRestOptions struct {
	_ struct{} `type:"structure"`

	// Specifies the option to enable Encryption At Rest.
	Enabled *bool `type:"boolean"`

	// Specifies the KMS Key ID for Encryption At Rest options.
	KmsKeyId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s EncryptionAtRestOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionAtRestOptions) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *EncryptionAtRestOptions) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "EncryptionAtRestOptions"}
	if s.KmsKeyId != nil && len(*s.KmsKeyId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("KmsKeyId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EncryptionAtRestOptions) MarshalFields(e protocol.FieldEncoder) error {
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Enabled", protocol.BoolValue(v), metadata)
	}
	if s.KmsKeyId != nil {
		v := *s.KmsKeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "KmsKeyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Status of the Encryption At Rest options for the specified Elasticsearch
// domain.
type EncryptionAtRestOptionsStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the Encryption At Rest options for the specified Elasticsearch
	// domain.
	//
	// Options is a required field
	Options *EncryptionAtRestOptions `type:"structure" required:"true"`

	// Specifies the status of the Encryption At Rest options for the specified
	// Elasticsearch domain.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s EncryptionAtRestOptionsStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionAtRestOptionsStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EncryptionAtRestOptionsStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := s.Options

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Options", v, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Container for request parameters to GetCompatibleElasticsearchVersions operation.
type GetCompatibleElasticsearchVersionsInput struct {
	_ struct{} `type:"structure"`

	// The name of an Elasticsearch domain. Domain names are unique across the domains
	// owned by an account within an AWS region. Domain names start with a letter
	// or number and can contain the following characters: a-z (lowercase), 0-9,
	// and - (hyphen).
	DomainName *string `location:"querystring" locationName:"domainName" min:"3" type:"string"`
}

// String returns the string representation
func (s GetCompatibleElasticsearchVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCompatibleElasticsearchVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetCompatibleElasticsearchVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetCompatibleElasticsearchVersionsInput"}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetCompatibleElasticsearchVersionsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "domainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for response returned by GetCompatibleElasticsearchVersions operation.
type GetCompatibleElasticsearchVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A map of compatible Elasticsearch versions returned as part of the GetCompatibleElasticsearchVersions
	// operation.
	CompatibleElasticsearchVersions []CompatibleVersionsMap `type:"list"`
}

// String returns the string representation
func (s GetCompatibleElasticsearchVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCompatibleElasticsearchVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetCompatibleElasticsearchVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetCompatibleElasticsearchVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.CompatibleElasticsearchVersions) > 0 {
		v := s.CompatibleElasticsearchVersions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "CompatibleElasticsearchVersions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Container for request parameters to GetUpgradeHistory operation.
type GetUpgradeHistoryInput struct {
	_ struct{} `type:"structure"`

	// The name of an Elasticsearch domain. Domain names are unique across the domains
	// owned by an account within an AWS region. Domain names start with a letter
	// or number and can contain the following characters: a-z (lowercase), 0-9,
	// and - (hyphen).
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"DomainName" min:"3" type:"string" required:"true"`

	// Set this value to limit the number of results returned.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// Paginated APIs accepts NextToken input to returns next page results and provides
	// a NextToken output in the response which can be used by the client to retrieve
	// more results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetUpgradeHistoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUpgradeHistoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetUpgradeHistoryInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetUpgradeHistoryInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUpgradeHistoryInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for response returned by GetUpgradeHistory operation.
type GetUpgradeHistoryOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Pagination token that needs to be supplied to the next call to get the next
	// page of results
	NextToken *string `type:"string"`

	// A list of UpgradeHistory objects corresponding to each Upgrade or Upgrade
	// Eligibility Check performed on a domain returned as part of GetUpgradeHistoryResponse
	// object.
	UpgradeHistories []UpgradeHistory `type:"list"`
}

// String returns the string representation
func (s GetUpgradeHistoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUpgradeHistoryOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetUpgradeHistoryOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUpgradeHistoryOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.UpgradeHistories) > 0 {
		v := s.UpgradeHistories

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "UpgradeHistories", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Container for request parameters to GetUpgradeStatus operation.
type GetUpgradeStatusInput struct {
	_ struct{} `type:"structure"`

	// The name of an Elasticsearch domain. Domain names are unique across the domains
	// owned by an account within an AWS region. Domain names start with a letter
	// or number and can contain the following characters: a-z (lowercase), 0-9,
	// and - (hyphen).
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"DomainName" min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s GetUpgradeStatusInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUpgradeStatusInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetUpgradeStatusInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetUpgradeStatusInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUpgradeStatusInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for response returned by GetUpgradeStatus operation.
type GetUpgradeStatusOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// One of 4 statuses that a step can go through returned as part of the GetUpgradeStatusResponse
	// object. The status can take one of the following values: In Progress
	// Succeeded
	// Succeeded with Issues
	// Failed
	StepStatus UpgradeStatus `type:"string" enum:"true"`

	// A string that describes the update briefly
	UpgradeName *string `type:"string"`

	// Represents one of 3 steps that an Upgrade or Upgrade Eligibility Check does
	// through: PreUpgradeCheck
	// Snapshot
	// Upgrade
	UpgradeStep UpgradeStep `type:"string" enum:"true"`
}

// String returns the string representation
func (s GetUpgradeStatusOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUpgradeStatusOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetUpgradeStatusOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUpgradeStatusOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.StepStatus) > 0 {
		v := s.StepStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StepStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.UpgradeName != nil {
		v := *s.UpgradeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.UpgradeStep) > 0 {
		v := s.UpgradeStep

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradeStep", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// InstanceCountLimits represents the limits on number of instances that be
// created in Amazon Elasticsearch for given InstanceType.
type InstanceCountLimits struct {
	_ struct{} `type:"structure"`

	// Maximum number of Instances that can be instantiated for given InstanceType.
	MaximumInstanceCount *int64 `type:"integer"`

	// Minimum number of Instances that can be instantiated for given InstanceType.
	MinimumInstanceCount *int64 `type:"integer"`
}

// String returns the string representation
func (s InstanceCountLimits) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InstanceCountLimits) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InstanceCountLimits) MarshalFields(e protocol.FieldEncoder) error {
	if s.MaximumInstanceCount != nil {
		v := *s.MaximumInstanceCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaximumInstanceCount", protocol.Int64Value(v), metadata)
	}
	if s.MinimumInstanceCount != nil {
		v := *s.MinimumInstanceCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MinimumInstanceCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// InstanceLimits represents the list of instance related attributes that are
// available for given InstanceType.
type InstanceLimits struct {
	_ struct{} `type:"structure"`

	// InstanceCountLimits represents the limits on number of instances that be
	// created in Amazon Elasticsearch for given InstanceType.
	InstanceCountLimits *InstanceCountLimits `type:"structure"`
}

// String returns the string representation
func (s InstanceLimits) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InstanceLimits) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s InstanceLimits) MarshalFields(e protocol.FieldEncoder) error {
	if s.InstanceCountLimits != nil {
		v := s.InstanceCountLimits

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "InstanceCountLimits", v, metadata)
	}
	return nil
}

// Limits for given InstanceType and for each of it's role. Limits contains following StorageTypes,   InstanceLimitsand AdditionalLimits
type Limits struct {
	_ struct{} `type:"structure"`

	// List of additional limits that are specific to a given InstanceType and for
	// each of it's InstanceRole .
	AdditionalLimits []AdditionalLimit `type:"list"`

	// InstanceLimits represents the list of instance related attributes that are
	// available for given InstanceType.
	InstanceLimits *InstanceLimits `type:"structure"`

	// StorageType represents the list of storage related types and attributes that
	// are available for given InstanceType.
	StorageTypes []StorageType `type:"list"`
}

// String returns the string representation
func (s Limits) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Limits) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Limits) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AdditionalLimits) > 0 {
		v := s.AdditionalLimits

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AdditionalLimits", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.InstanceLimits != nil {
		v := s.InstanceLimits

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "InstanceLimits", v, metadata)
	}
	if len(s.StorageTypes) > 0 {
		v := s.StorageTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "StorageTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

type ListDomainNamesInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s ListDomainNamesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListDomainNamesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListDomainNamesInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// The result of a ListDomainNames operation. Contains the names of all Elasticsearch
// domains owned by this account.
type ListDomainNamesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// List of Elasticsearch domain names.
	DomainNames []DomainInfo `type:"list"`
}

// String returns the string representation
func (s ListDomainNamesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListDomainNamesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListDomainNamesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListDomainNamesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DomainNames) > 0 {
		v := s.DomainNames

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "DomainNames", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Container for the parameters to the ListElasticsearchInstanceTypes operation.
type ListElasticsearchInstanceTypesInput struct {
	_ struct{} `type:"structure"`

	// DomainName represents the name of the Domain that we are trying to modify.
	// This should be present only if we are querying for list of available Elasticsearch
	// instance types when modifying existing domain.
	DomainName *string `location:"querystring" locationName:"domainName" min:"3" type:"string"`

	// Version of Elasticsearch for which list of supported elasticsearch instance
	// types are needed.
	//
	// ElasticsearchVersion is a required field
	ElasticsearchVersion *string `location:"uri" locationName:"ElasticsearchVersion" type:"string" required:"true"`

	// Set this value to limit the number of results returned. Value provided must
	// be greater than 30 else it wont be honored.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// NextToken should be sent in case if earlier API call produced result containing
	// NextToken. It is used for pagination.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListElasticsearchInstanceTypesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListElasticsearchInstanceTypesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListElasticsearchInstanceTypesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListElasticsearchInstanceTypesInput"}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if s.ElasticsearchVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("ElasticsearchVersion"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListElasticsearchInstanceTypesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ElasticsearchVersion != nil {
		v := *s.ElasticsearchVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ElasticsearchVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "domainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for the parameters returned by ListElasticsearchInstanceTypes operation.
type ListElasticsearchInstanceTypesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// List of instance types supported by Amazon Elasticsearch service for given
	// ElasticsearchVersion
	ElasticsearchInstanceTypes []ESPartitionInstanceType `type:"list"`

	// In case if there are more results available NextToken would be present, make
	// further request to the same API with received NextToken to paginate remaining
	// results.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListElasticsearchInstanceTypesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListElasticsearchInstanceTypesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListElasticsearchInstanceTypesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListElasticsearchInstanceTypesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ElasticsearchInstanceTypes) > 0 {
		v := s.ElasticsearchInstanceTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ElasticsearchInstanceTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for the parameters to the ListElasticsearchVersions operation.
//  Use MaxResults to control the maximum number of results to retrieve in a
// single call.
//
//  Use NextToken in response to retrieve more results. If the received response
// does not contain a NextToken, then there are no more results to retrieve.
type ListElasticsearchVersionsInput struct {
	_ struct{} `type:"structure"`

	// Set this value to limit the number of results returned. Value provided must
	// be greater than 10 else it wont be honored.
	MaxResults *int64 `location:"querystring" locationName:"maxResults" type:"integer"`

	// Paginated APIs accepts NextToken input to returns next page results and provides
	// a NextToken output in the response which can be used by the client to retrieve
	// more results.
	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListElasticsearchVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListElasticsearchVersionsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListElasticsearchVersionsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for the parameters for response received from ListElasticsearchVersions
// operation.
type ListElasticsearchVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// List of supported elastic search versions.
	ElasticsearchVersions []string `type:"list"`

	// Paginated APIs accepts NextToken input to returns next page results and provides
	// a NextToken output in the response which can be used by the client to retrieve
	// more results.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s ListElasticsearchVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListElasticsearchVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListElasticsearchVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListElasticsearchVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ElasticsearchVersions) > 0 {
		v := s.ElasticsearchVersions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ElasticsearchVersions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for the parameters to the ListTags operation. Specify the ARN for
// the Elasticsearch domain to which the tags are attached that you want to
// view are attached.
type ListTagsInput struct {
	_ struct{} `type:"structure"`

	// Specify the ARN for the Elasticsearch domain to which the tags are attached
	// that you want to view.
	//
	// ARN is a required field
	ARN *string `location:"querystring" locationName:"arn" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTagsInput"}

	if s.ARN == nil {
		invalidParams.Add(aws.NewErrParamRequired("ARN"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ARN != nil {
		v := *s.ARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The result of a ListTags operation. Contains tags for all requested Elasticsearch
// domains.
type ListTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// List of Tag for the requested Elasticsearch domain.
	TagList []Tag `type:"list"`
}

// String returns the string representation
func (s ListTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.TagList) > 0 {
		v := s.TagList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TagList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Log Publishing option that is set for given domain. Attributes and their details: CloudWatchLogsLogGroupArn: ARN of the Cloudwatch
// log group to which log needs to be published.
// Enabled: Whether the log publishing for given log type is enabled or not
type LogPublishingOption struct {
	_ struct{} `type:"structure"`

	// ARN of the Cloudwatch log group to which log needs to be published.
	CloudWatchLogsLogGroupArn *string `type:"string"`

	// Specifies whether given log publishing option is enabled or not.
	Enabled *bool `type:"boolean"`
}

// String returns the string representation
func (s LogPublishingOption) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LogPublishingOption) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LogPublishingOption) MarshalFields(e protocol.FieldEncoder) error {
	if s.CloudWatchLogsLogGroupArn != nil {
		v := *s.CloudWatchLogsLogGroupArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CloudWatchLogsLogGroupArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Enabled", protocol.BoolValue(v), metadata)
	}
	return nil
}

// The configured log publishing options for the domain and their current status.
type LogPublishingOptionsStatus struct {
	_ struct{} `type:"structure"`

	// The log publishing options configured for the Elasticsearch domain.
	Options map[string]LogPublishingOption `type:"map"`

	// The status of the log publishing options for the Elasticsearch domain. See
	// OptionStatus for the status information that's included.
	Status *OptionStatus `type:"structure"`
}

// String returns the string representation
func (s LogPublishingOptionsStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LogPublishingOptionsStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LogPublishingOptionsStatus) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Options) > 0 {
		v := s.Options

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "Options", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Specifies the node-to-node encryption options.
type NodeToNodeEncryptionOptions struct {
	_ struct{} `type:"structure"`

	// Specify true to enable node-to-node encryption.
	Enabled *bool `type:"boolean"`
}

// String returns the string representation
func (s NodeToNodeEncryptionOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s NodeToNodeEncryptionOptions) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NodeToNodeEncryptionOptions) MarshalFields(e protocol.FieldEncoder) error {
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Enabled", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Status of the node-to-node encryption options for the specified Elasticsearch
// domain.
type NodeToNodeEncryptionOptionsStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the node-to-node encryption options for the specified Elasticsearch
	// domain.
	//
	// Options is a required field
	Options *NodeToNodeEncryptionOptions `type:"structure" required:"true"`

	// Specifies the status of the node-to-node encryption options for the specified
	// Elasticsearch domain.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s NodeToNodeEncryptionOptionsStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s NodeToNodeEncryptionOptionsStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s NodeToNodeEncryptionOptionsStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := s.Options

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Options", v, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Provides the current status of the entity.
type OptionStatus struct {
	_ struct{} `type:"structure"`

	// Timestamp which tells the creation date for the entity.
	//
	// CreationDate is a required field
	CreationDate *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Indicates whether the Elasticsearch domain is being deleted.
	PendingDeletion *bool `type:"boolean"`

	// Provides the OptionState for the Elasticsearch domain.
	//
	// State is a required field
	State OptionState `type:"string" required:"true" enum:"true"`

	// Timestamp which tells the last updated time for the entity.
	//
	// UpdateDate is a required field
	UpdateDate *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Specifies the latest version for the entity.
	UpdateVersion *int64 `type:"integer"`
}

// String returns the string representation
func (s OptionStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OptionStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s OptionStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationDate != nil {
		v := *s.CreationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.PendingDeletion != nil {
		v := *s.PendingDeletion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PendingDeletion", protocol.BoolValue(v), metadata)
	}
	if len(s.State) > 0 {
		v := s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.UpdateDate != nil {
		v := *s.UpdateDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdateDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.UpdateVersion != nil {
		v := *s.UpdateVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdateVersion", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Container for parameters to PurchaseReservedElasticsearchInstanceOffering
type PurchaseReservedElasticsearchInstanceOfferingInput struct {
	_ struct{} `type:"structure"`

	// The number of Elasticsearch instances to reserve.
	InstanceCount *int64 `min:"1" type:"integer"`

	// A customer-specified identifier to track this reservation.
	//
	// ReservationName is a required field
	ReservationName *string `min:"5" type:"string" required:"true"`

	// The ID of the reserved Elasticsearch instance offering to purchase.
	//
	// ReservedElasticsearchInstanceOfferingId is a required field
	ReservedElasticsearchInstanceOfferingId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s PurchaseReservedElasticsearchInstanceOfferingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PurchaseReservedElasticsearchInstanceOfferingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PurchaseReservedElasticsearchInstanceOfferingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PurchaseReservedElasticsearchInstanceOfferingInput"}
	if s.InstanceCount != nil && *s.InstanceCount < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("InstanceCount", 1))
	}

	if s.ReservationName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ReservationName"))
	}
	if s.ReservationName != nil && len(*s.ReservationName) < 5 {
		invalidParams.Add(aws.NewErrParamMinLen("ReservationName", 5))
	}

	if s.ReservedElasticsearchInstanceOfferingId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ReservedElasticsearchInstanceOfferingId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PurchaseReservedElasticsearchInstanceOfferingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.InstanceCount != nil {
		v := *s.InstanceCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InstanceCount", protocol.Int64Value(v), metadata)
	}
	if s.ReservationName != nil {
		v := *s.ReservationName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservationName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ReservedElasticsearchInstanceOfferingId != nil {
		v := *s.ReservedElasticsearchInstanceOfferingId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservedElasticsearchInstanceOfferingId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the output of a PurchaseReservedElasticsearchInstanceOffering
// operation.
type PurchaseReservedElasticsearchInstanceOfferingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The customer-specified identifier used to track this reservation.
	ReservationName *string `min:"5" type:"string"`

	// Details of the reserved Elasticsearch instance which was purchased.
	ReservedElasticsearchInstanceId *string `type:"string"`
}

// String returns the string representation
func (s PurchaseReservedElasticsearchInstanceOfferingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PurchaseReservedElasticsearchInstanceOfferingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PurchaseReservedElasticsearchInstanceOfferingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PurchaseReservedElasticsearchInstanceOfferingOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ReservationName != nil {
		v := *s.ReservationName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservationName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ReservedElasticsearchInstanceId != nil {
		v := *s.ReservedElasticsearchInstanceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservedElasticsearchInstanceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains the specific price and frequency of a recurring charges for a reserved
// Elasticsearch instance, or for a reserved Elasticsearch instance offering.
type RecurringCharge struct {
	_ struct{} `type:"structure"`

	// The monetary amount of the recurring charge.
	RecurringChargeAmount *float64 `type:"double"`

	// The frequency of the recurring charge.
	RecurringChargeFrequency *string `type:"string"`
}

// String returns the string representation
func (s RecurringCharge) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RecurringCharge) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RecurringCharge) MarshalFields(e protocol.FieldEncoder) error {
	if s.RecurringChargeAmount != nil {
		v := *s.RecurringChargeAmount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecurringChargeAmount", protocol.Float64Value(v), metadata)
	}
	if s.RecurringChargeFrequency != nil {
		v := *s.RecurringChargeFrequency

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecurringChargeFrequency", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for the parameters to the RemoveTags operation. Specify the ARN
// for the Elasticsearch domain from which you want to remove the specified
// TagKey.
type RemoveTagsInput struct {
	_ struct{} `type:"structure"`

	// Specifies the ARN for the Elasticsearch domain from which you want to delete
	// the specified tags.
	//
	// ARN is a required field
	ARN *string `type:"string" required:"true"`

	// Specifies the TagKey list which you want to remove from the Elasticsearch
	// domain.
	//
	// TagKeys is a required field
	TagKeys []string `type:"list" required:"true"`
}

// String returns the string representation
func (s RemoveTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RemoveTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RemoveTagsInput"}

	if s.ARN == nil {
		invalidParams.Add(aws.NewErrParamRequired("ARN"))
	}

	if s.TagKeys == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveTagsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ARN != nil {
		v := *s.ARN

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ARN", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TagKeys) > 0 {
		v := s.TagKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TagKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type RemoveTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s RemoveTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RemoveTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RemoveTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RemoveTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Details of a reserved Elasticsearch instance.
type ReservedElasticsearchInstance struct {
	_ struct{} `type:"structure"`

	// The currency code for the reserved Elasticsearch instance offering.
	CurrencyCode *string `type:"string"`

	// The duration, in seconds, for which the Elasticsearch instance is reserved.
	Duration *int64 `type:"integer"`

	// The number of Elasticsearch instances that have been reserved.
	ElasticsearchInstanceCount *int64 `type:"integer"`

	// The Elasticsearch instance type offered by the reserved instance offering.
	ElasticsearchInstanceType ESPartitionInstanceType `type:"string" enum:"true"`

	// The upfront fixed charge you will paid to purchase the specific reserved
	// Elasticsearch instance offering.
	FixedPrice *float64 `type:"double"`

	// The payment option as defined in the reserved Elasticsearch instance offering.
	PaymentOption ReservedElasticsearchInstancePaymentOption `type:"string" enum:"true"`

	// The charge to your account regardless of whether you are creating any domains
	// using the instance offering.
	RecurringCharges []RecurringCharge `type:"list"`

	// The customer-specified identifier to track this reservation.
	ReservationName *string `min:"5" type:"string"`

	// The unique identifier for the reservation.
	ReservedElasticsearchInstanceId *string `type:"string"`

	// The offering identifier.
	ReservedElasticsearchInstanceOfferingId *string `type:"string"`

	// The time the reservation started.
	StartTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The state of the reserved Elasticsearch instance.
	State *string `type:"string"`

	// The rate you are charged for each hour for the domain that is using this
	// reserved instance.
	UsagePrice *float64 `type:"double"`
}

// String returns the string representation
func (s ReservedElasticsearchInstance) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReservedElasticsearchInstance) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReservedElasticsearchInstance) MarshalFields(e protocol.FieldEncoder) error {
	if s.CurrencyCode != nil {
		v := *s.CurrencyCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CurrencyCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Duration != nil {
		v := *s.Duration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Duration", protocol.Int64Value(v), metadata)
	}
	if s.ElasticsearchInstanceCount != nil {
		v := *s.ElasticsearchInstanceCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ElasticsearchInstanceCount", protocol.Int64Value(v), metadata)
	}
	if len(s.ElasticsearchInstanceType) > 0 {
		v := s.ElasticsearchInstanceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ElasticsearchInstanceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.FixedPrice != nil {
		v := *s.FixedPrice

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FixedPrice", protocol.Float64Value(v), metadata)
	}
	if len(s.PaymentOption) > 0 {
		v := s.PaymentOption

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PaymentOption", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.RecurringCharges) > 0 {
		v := s.RecurringCharges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RecurringCharges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ReservationName != nil {
		v := *s.ReservationName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservationName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ReservedElasticsearchInstanceId != nil {
		v := *s.ReservedElasticsearchInstanceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservedElasticsearchInstanceId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ReservedElasticsearchInstanceOfferingId != nil {
		v := *s.ReservedElasticsearchInstanceOfferingId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservedElasticsearchInstanceOfferingId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartTime != nil {
		v := *s.StartTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTime", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.State != nil {
		v := *s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UsagePrice != nil {
		v := *s.UsagePrice

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UsagePrice", protocol.Float64Value(v), metadata)
	}
	return nil
}

// Details of a reserved Elasticsearch instance offering.
type ReservedElasticsearchInstanceOffering struct {
	_ struct{} `type:"structure"`

	// The currency code for the reserved Elasticsearch instance offering.
	CurrencyCode *string `type:"string"`

	// The duration, in seconds, for which the offering will reserve the Elasticsearch
	// instance.
	Duration *int64 `type:"integer"`

	// The Elasticsearch instance type offered by the reserved instance offering.
	ElasticsearchInstanceType ESPartitionInstanceType `type:"string" enum:"true"`

	// The upfront fixed charge you will pay to purchase the specific reserved Elasticsearch
	// instance offering.
	FixedPrice *float64 `type:"double"`

	// Payment option for the reserved Elasticsearch instance offering
	PaymentOption ReservedElasticsearchInstancePaymentOption `type:"string" enum:"true"`

	// The charge to your account regardless of whether you are creating any domains
	// using the instance offering.
	RecurringCharges []RecurringCharge `type:"list"`

	// The Elasticsearch reserved instance offering identifier.
	ReservedElasticsearchInstanceOfferingId *string `type:"string"`

	// The rate you are charged for each hour the domain that is using the offering
	// is running.
	UsagePrice *float64 `type:"double"`
}

// String returns the string representation
func (s ReservedElasticsearchInstanceOffering) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReservedElasticsearchInstanceOffering) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReservedElasticsearchInstanceOffering) MarshalFields(e protocol.FieldEncoder) error {
	if s.CurrencyCode != nil {
		v := *s.CurrencyCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CurrencyCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Duration != nil {
		v := *s.Duration

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Duration", protocol.Int64Value(v), metadata)
	}
	if len(s.ElasticsearchInstanceType) > 0 {
		v := s.ElasticsearchInstanceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ElasticsearchInstanceType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.FixedPrice != nil {
		v := *s.FixedPrice

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FixedPrice", protocol.Float64Value(v), metadata)
	}
	if len(s.PaymentOption) > 0 {
		v := s.PaymentOption

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PaymentOption", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.RecurringCharges) > 0 {
		v := s.RecurringCharges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "RecurringCharges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ReservedElasticsearchInstanceOfferingId != nil {
		v := *s.ReservedElasticsearchInstanceOfferingId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReservedElasticsearchInstanceOfferingId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UsagePrice != nil {
		v := *s.UsagePrice

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UsagePrice", protocol.Float64Value(v), metadata)
	}
	return nil
}

// The current options of an Elasticsearch domain service software options.
type ServiceSoftwareOptions struct {
	_ struct{} `type:"structure"`

	// Timestamp, in Epoch time, until which you can manually request a service
	// software update. After this date, we automatically update your service software.
	AutomatedUpdateDate *time.Time `type:"timestamp" timestampFormat:"unix"`

	// True if you are able to cancel your service software version update. False
	// if you are not able to cancel your service software version.
	Cancellable *bool `type:"boolean"`

	// The current service software version that is present on the domain.
	CurrentVersion *string `type:"string"`

	// The description of the UpdateStatus.
	Description *string `type:"string"`

	// The new service software version if one is available.
	NewVersion *string `type:"string"`

	// True if you are able to update you service software version. False if you
	// are not able to update your service software version.
	UpdateAvailable *bool `type:"boolean"`

	// The status of your service software update. This field can take the following
	// values: ELIGIBLE, PENDING_UPDATE, IN_PROGRESS, COMPLETED, and NOT_ELIGIBLE.
	UpdateStatus DeploymentStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s ServiceSoftwareOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ServiceSoftwareOptions) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ServiceSoftwareOptions) MarshalFields(e protocol.FieldEncoder) error {
	if s.AutomatedUpdateDate != nil {
		v := *s.AutomatedUpdateDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AutomatedUpdateDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Cancellable != nil {
		v := *s.Cancellable

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Cancellable", protocol.BoolValue(v), metadata)
	}
	if s.CurrentVersion != nil {
		v := *s.CurrentVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CurrentVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.NewVersion != nil {
		v := *s.NewVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NewVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UpdateAvailable != nil {
		v := *s.UpdateAvailable

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdateAvailable", protocol.BoolValue(v), metadata)
	}
	if len(s.UpdateStatus) > 0 {
		v := s.UpdateStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpdateStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Specifies the time, in UTC format, when the service takes a daily automated
// snapshot of the specified Elasticsearch domain. Default value is 0 hours.
type SnapshotOptions struct {
	_ struct{} `type:"structure"`

	// Specifies the time, in UTC format, when the service takes a daily automated
	// snapshot of the specified Elasticsearch domain. Default value is 0 hours.
	AutomatedSnapshotStartHour *int64 `type:"integer"`
}

// String returns the string representation
func (s SnapshotOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SnapshotOptions) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SnapshotOptions) MarshalFields(e protocol.FieldEncoder) error {
	if s.AutomatedSnapshotStartHour != nil {
		v := *s.AutomatedSnapshotStartHour

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AutomatedSnapshotStartHour", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Status of a daily automated snapshot.
type SnapshotOptionsStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the daily snapshot options specified for the Elasticsearch domain.
	//
	// Options is a required field
	Options *SnapshotOptions `type:"structure" required:"true"`

	// Specifies the status of a daily automated snapshot.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s SnapshotOptionsStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SnapshotOptionsStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SnapshotOptionsStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := s.Options

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Options", v, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Container for the parameters to the StartElasticsearchServiceSoftwareUpdate
// operation. Specifies the name of the Elasticsearch domain that you wish to
// schedule a service software update on.
type StartElasticsearchServiceSoftwareUpdateInput struct {
	_ struct{} `type:"structure"`

	// The name of the domain that you want to update to the latest service software.
	//
	// DomainName is a required field
	DomainName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s StartElasticsearchServiceSoftwareUpdateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartElasticsearchServiceSoftwareUpdateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *StartElasticsearchServiceSoftwareUpdateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "StartElasticsearchServiceSoftwareUpdateInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartElasticsearchServiceSoftwareUpdateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The result of a StartElasticsearchServiceSoftwareUpdate operation. Contains
// the status of the update.
type StartElasticsearchServiceSoftwareUpdateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current status of the Elasticsearch service software update.
	ServiceSoftwareOptions *ServiceSoftwareOptions `type:"structure"`
}

// String returns the string representation
func (s StartElasticsearchServiceSoftwareUpdateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StartElasticsearchServiceSoftwareUpdateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s StartElasticsearchServiceSoftwareUpdateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StartElasticsearchServiceSoftwareUpdateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ServiceSoftwareOptions != nil {
		v := s.ServiceSoftwareOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ServiceSoftwareOptions", v, metadata)
	}
	return nil
}

// StorageTypes represents the list of storage related types and their attributes
// that are available for given InstanceType.
type StorageType struct {
	_ struct{} `type:"structure"`

	// SubType of the given storage type. List of available sub-storage options:
	// For "instance" storageType we wont have any storageSubType, in case of "ebs"
	// storageType we will have following valid storageSubTypes standard
	// gp2
	// io1
	//  Refer VolumeType for more information regarding above EBS storage options.
	StorageSubTypeName *string `type:"string"`

	// List of limits that are applicable for given storage type.
	StorageTypeLimits []StorageTypeLimit `type:"list"`

	// Type of the storage. List of available storage options: instance
	//  Inbuilt storage available for the given Instance ebs
	//  Elastic block storage that would be attached to the given Instance
	StorageTypeName *string `type:"string"`
}

// String returns the string representation
func (s StorageType) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StorageType) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StorageType) MarshalFields(e protocol.FieldEncoder) error {
	if s.StorageSubTypeName != nil {
		v := *s.StorageSubTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageSubTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.StorageTypeLimits) > 0 {
		v := s.StorageTypeLimits

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "StorageTypeLimits", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.StorageTypeName != nil {
		v := *s.StorageTypeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageTypeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Limits that are applicable for given storage type.
type StorageTypeLimit struct {
	_ struct{} `type:"structure"`

	// Name of storage limits that are applicable for given storage type. If StorageType
	// is ebs, following storage options are applicable MinimumVolumeSize
	//  Minimum amount of volume size that is applicable for given storage type.It
	// can be empty if it is not applicable. MaximumVolumeSize
	//  Maximum amount of volume size that is applicable for given storage type.It
	// can be empty if it is not applicable. MaximumIops
	//  Maximum amount of Iops that is applicable for given storage type.It can
	// be empty if it is not applicable. MinimumIops
	//  Minimum amount of Iops that is applicable for given storage type.It can
	// be empty if it is not applicable.
	LimitName *string `type:"string"`

	// Values for the StorageTypeLimit$LimitName .
	LimitValues []string `type:"list"`
}

// String returns the string representation
func (s StorageTypeLimit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StorageTypeLimit) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StorageTypeLimit) MarshalFields(e protocol.FieldEncoder) error {
	if s.LimitName != nil {
		v := *s.LimitName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LimitName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.LimitValues) > 0 {
		v := s.LimitValues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "LimitValues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Specifies a key value pair for a resource tag.
type Tag struct {
	_ struct{} `type:"structure"`

	// Specifies the TagKey, the name of the tag. Tag keys must be unique for the
	// Elasticsearch domain to which they are attached.
	//
	// Key is a required field
	Key *string `min:"1" type:"string" required:"true"`

	// Specifies the TagValue, the value assigned to the corresponding tag key.
	// Tag values can be null and do not have to be unique in a tag set. For example,
	// you can have a key value pair in a tag set of project : Trinity and cost-center
	// : Trinity
	//
	// Value is a required field
	Value *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Tag) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Tag) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Tag) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Tag"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Tag) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for the parameters to the UpdateElasticsearchDomain operation.
// Specifies the type and number of instances in the domain cluster.
type UpdateElasticsearchDomainConfigInput struct {
	_ struct{} `type:"structure"`

	// IAM access policy as a JSON-formatted string.
	AccessPolicies *string `type:"string"`

	// Modifies the advanced option to allow references to indices in an HTTP request
	// body. Must be false when configuring access to individual sub-resources.
	// By default, the value is true. See Configuration Advanced Options (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-advanced-options)
	// for more information.
	AdvancedOptions map[string]string `type:"map"`

	// Options to specify the Cognito user and identity pools for Kibana authentication.
	// For more information, see Amazon Cognito Authentication for Kibana (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-cognito-auth.html).
	CognitoOptions *CognitoOptions `type:"structure"`

	// The name of the Elasticsearch domain that you are updating.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"DomainName" min:"3" type:"string" required:"true"`

	// Specify the type and size of the EBS volume that you want to use.
	EBSOptions *EBSOptions `type:"structure"`

	// The type and number of instances to instantiate for the domain cluster.
	ElasticsearchClusterConfig *ElasticsearchClusterConfig `type:"structure"`

	// Map of LogType and LogPublishingOption, each containing options to publish
	// a given type of Elasticsearch log.
	LogPublishingOptions map[string]LogPublishingOption `type:"map"`

	// Option to set the time, in UTC format, for the daily automated snapshot.
	// Default value is 0 hours.
	SnapshotOptions *SnapshotOptions `type:"structure"`

	// Options to specify the subnets and security groups for VPC endpoint. For
	// more information, see Creating a VPC (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-creating-vpc)
	// in VPC Endpoints for Amazon Elasticsearch Service Domains
	VPCOptions *VPCOptions `type:"structure"`
}

// String returns the string representation
func (s UpdateElasticsearchDomainConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateElasticsearchDomainConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateElasticsearchDomainConfigInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateElasticsearchDomainConfigInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}
	if s.CognitoOptions != nil {
		if err := s.CognitoOptions.Validate(); err != nil {
			invalidParams.AddNested("CognitoOptions", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateElasticsearchDomainConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AccessPolicies != nil {
		v := *s.AccessPolicies

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "AccessPolicies", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.AdvancedOptions) > 0 {
		v := s.AdvancedOptions

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "AdvancedOptions", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.CognitoOptions != nil {
		v := s.CognitoOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CognitoOptions", v, metadata)
	}
	if s.EBSOptions != nil {
		v := s.EBSOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "EBSOptions", v, metadata)
	}
	if s.ElasticsearchClusterConfig != nil {
		v := s.ElasticsearchClusterConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ElasticsearchClusterConfig", v, metadata)
	}
	if len(s.LogPublishingOptions) > 0 {
		v := s.LogPublishingOptions

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "LogPublishingOptions", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if s.SnapshotOptions != nil {
		v := s.SnapshotOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "SnapshotOptions", v, metadata)
	}
	if s.VPCOptions != nil {
		v := s.VPCOptions

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "VPCOptions", v, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The result of an UpdateElasticsearchDomain request. Contains the status of
// the Elasticsearch domain being updated.
type UpdateElasticsearchDomainConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The status of the updated Elasticsearch domain.
	//
	// DomainConfig is a required field
	DomainConfig *ElasticsearchDomainConfig `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateElasticsearchDomainConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateElasticsearchDomainConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateElasticsearchDomainConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateElasticsearchDomainConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainConfig != nil {
		v := s.DomainConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DomainConfig", v, metadata)
	}
	return nil
}

// Container for request parameters to UpgradeElasticsearchDomain operation.
type UpgradeElasticsearchDomainInput struct {
	_ struct{} `type:"structure"`

	// The name of an Elasticsearch domain. Domain names are unique across the domains
	// owned by an account within an AWS region. Domain names start with a letter
	// or number and can contain the following characters: a-z (lowercase), 0-9,
	// and - (hyphen).
	//
	// DomainName is a required field
	DomainName *string `min:"3" type:"string" required:"true"`

	// This flag, when set to True, indicates that an Upgrade Eligibility Check
	// needs to be performed. This will not actually perform the Upgrade.
	PerformCheckOnly *bool `type:"boolean"`

	// The version of Elasticsearch that you intend to upgrade the domain to.
	//
	// TargetVersion is a required field
	TargetVersion *string `type:"string" required:"true"`
}

// String returns the string representation
func (s UpgradeElasticsearchDomainInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpgradeElasticsearchDomainInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpgradeElasticsearchDomainInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpgradeElasticsearchDomainInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}
	if s.DomainName != nil && len(*s.DomainName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("DomainName", 3))
	}

	if s.TargetVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetVersion"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpgradeElasticsearchDomainInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PerformCheckOnly != nil {
		v := *s.PerformCheckOnly

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PerformCheckOnly", protocol.BoolValue(v), metadata)
	}
	if s.TargetVersion != nil {
		v := *s.TargetVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Container for response returned by UpgradeElasticsearchDomain operation.
type UpgradeElasticsearchDomainOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The name of an Elasticsearch domain. Domain names are unique across the domains
	// owned by an account within an AWS region. Domain names start with a letter
	// or number and can contain the following characters: a-z (lowercase), 0-9,
	// and - (hyphen).
	DomainName *string `min:"3" type:"string"`

	// This flag, when set to True, indicates that an Upgrade Eligibility Check
	// needs to be performed. This will not actually perform the Upgrade.
	PerformCheckOnly *bool `type:"boolean"`

	// The version of Elasticsearch that you intend to upgrade the domain to.
	TargetVersion *string `type:"string"`
}

// String returns the string representation
func (s UpgradeElasticsearchDomainOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpgradeElasticsearchDomainOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpgradeElasticsearchDomainOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpgradeElasticsearchDomainOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PerformCheckOnly != nil {
		v := *s.PerformCheckOnly

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PerformCheckOnly", protocol.BoolValue(v), metadata)
	}
	if s.TargetVersion != nil {
		v := *s.TargetVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// History of the last 10 Upgrades and Upgrade Eligibility Checks.
type UpgradeHistory struct {
	_ struct{} `type:"structure"`

	// UTC Timestamp at which the Upgrade API call was made in "yyyy-MM-ddTHH:mm:ssZ"
	// format.
	StartTimestamp *time.Time `type:"timestamp" timestampFormat:"unix"`

	// A list of UpgradeStepItem s representing information about each step performed
	// as pard of a specific Upgrade or Upgrade Eligibility Check.
	StepsList []UpgradeStepItem `type:"list"`

	// A string that describes the update briefly
	UpgradeName *string `type:"string"`

	// The overall status of the update. The status can take one of the following
	// values: In Progress
	// Succeeded
	// Succeeded with Issues
	// Failed
	UpgradeStatus UpgradeStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s UpgradeHistory) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpgradeHistory) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpgradeHistory) MarshalFields(e protocol.FieldEncoder) error {
	if s.StartTimestamp != nil {
		v := *s.StartTimestamp

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StartTimestamp", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.StepsList) > 0 {
		v := s.StepsList

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "StepsList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.UpgradeName != nil {
		v := *s.UpgradeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.UpgradeStatus) > 0 {
		v := s.UpgradeStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradeStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Represents a single step of the Upgrade or Upgrade Eligibility Check workflow.
type UpgradeStepItem struct {
	_ struct{} `type:"structure"`

	// A list of strings containing detailed information about the errors encountered
	// in a particular step.
	Issues []string `type:"list"`

	// The Floating point value representing progress percentage of a particular
	// step.
	ProgressPercent *float64 `type:"double"`

	// Represents one of 3 steps that an Upgrade or Upgrade Eligibility Check does
	// through: PreUpgradeCheck
	// Snapshot
	// Upgrade
	UpgradeStep UpgradeStep `type:"string" enum:"true"`

	// The status of a particular step during an upgrade. The status can take one
	// of the following values: In Progress
	// Succeeded
	// Succeeded with Issues
	// Failed
	UpgradeStepStatus UpgradeStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s UpgradeStepItem) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpgradeStepItem) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpgradeStepItem) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Issues) > 0 {
		v := s.Issues

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Issues", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ProgressPercent != nil {
		v := *s.ProgressPercent

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ProgressPercent", protocol.Float64Value(v), metadata)
	}
	if len(s.UpgradeStep) > 0 {
		v := s.UpgradeStep

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradeStep", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.UpgradeStepStatus) > 0 {
		v := s.UpgradeStepStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UpgradeStepStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Options to specify the subnets and security groups for VPC endpoint. For
// more information, see  VPC Endpoints for Amazon Elasticsearch Service Domains
// (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html).
type VPCDerivedInfo struct {
	_ struct{} `type:"structure"`

	// The availability zones for the Elasticsearch domain. Exists only if the domain
	// was created with VPCOptions.
	AvailabilityZones []string `type:"list"`

	// Specifies the security groups for VPC endpoint.
	SecurityGroupIds []string `type:"list"`

	// Specifies the subnets for VPC endpoint.
	SubnetIds []string `type:"list"`

	// The VPC Id for the Elasticsearch domain. Exists only if the domain was created
	// with VPCOptions.
	VPCId *string `type:"string"`
}

// String returns the string representation
func (s VPCDerivedInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VPCDerivedInfo) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VPCDerivedInfo) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.AvailabilityZones) > 0 {
		v := s.AvailabilityZones

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AvailabilityZones", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.SecurityGroupIds) > 0 {
		v := s.SecurityGroupIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SecurityGroupIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.SubnetIds) > 0 {
		v := s.SubnetIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SubnetIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.VPCId != nil {
		v := *s.VPCId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VPCId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Status of the VPC options for the specified Elasticsearch domain.
type VPCDerivedInfoStatus struct {
	_ struct{} `type:"structure"`

	// Specifies the VPC options for the specified Elasticsearch domain.
	//
	// Options is a required field
	Options *VPCDerivedInfo `type:"structure" required:"true"`

	// Specifies the status of the VPC options for the specified Elasticsearch domain.
	//
	// Status is a required field
	Status *OptionStatus `type:"structure" required:"true"`
}

// String returns the string representation
func (s VPCDerivedInfoStatus) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VPCDerivedInfoStatus) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VPCDerivedInfoStatus) MarshalFields(e protocol.FieldEncoder) error {
	if s.Options != nil {
		v := s.Options

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Options", v, metadata)
	}
	if s.Status != nil {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Status", v, metadata)
	}
	return nil
}

// Options to specify the subnets and security groups for VPC endpoint. For
// more information, see  VPC Endpoints for Amazon Elasticsearch Service Domains
// (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html).
type VPCOptions struct {
	_ struct{} `type:"structure"`

	// Specifies the security groups for VPC endpoint.
	SecurityGroupIds []string `type:"list"`

	// Specifies the subnets for VPC endpoint.
	SubnetIds []string `type:"list"`
}

// String returns the string representation
func (s VPCOptions) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VPCOptions) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VPCOptions) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.SecurityGroupIds) > 0 {
		v := s.SecurityGroupIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SecurityGroupIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.SubnetIds) > 0 {
		v := s.SubnetIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "SubnetIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type DeploymentStatus string

// Enum values for DeploymentStatus
const (
	DeploymentStatusPendingUpdate DeploymentStatus = "PENDING_UPDATE"
	DeploymentStatusInProgress    DeploymentStatus = "IN_PROGRESS"
	DeploymentStatusCompleted     DeploymentStatus = "COMPLETED"
	DeploymentStatusNotEligible   DeploymentStatus = "NOT_ELIGIBLE"
	DeploymentStatusEligible      DeploymentStatus = "ELIGIBLE"
)

func (enum DeploymentStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DeploymentStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ESPartitionInstanceType string

// Enum values for ESPartitionInstanceType
const (
	ESPartitionInstanceTypeM3MediumElasticsearch   ESPartitionInstanceType = "m3.medium.elasticsearch"
	ESPartitionInstanceTypeM3LargeElasticsearch    ESPartitionInstanceType = "m3.large.elasticsearch"
	ESPartitionInstanceTypeM3XlargeElasticsearch   ESPartitionInstanceType = "m3.xlarge.elasticsearch"
	ESPartitionInstanceTypeM32xlargeElasticsearch  ESPartitionInstanceType = "m3.2xlarge.elasticsearch"
	ESPartitionInstanceTypeM4LargeElasticsearch    ESPartitionInstanceType = "m4.large.elasticsearch"
	ESPartitionInstanceTypeM4XlargeElasticsearch   ESPartitionInstanceType = "m4.xlarge.elasticsearch"
	ESPartitionInstanceTypeM42xlargeElasticsearch  ESPartitionInstanceType = "m4.2xlarge.elasticsearch"
	ESPartitionInstanceTypeM44xlargeElasticsearch  ESPartitionInstanceType = "m4.4xlarge.elasticsearch"
	ESPartitionInstanceTypeM410xlargeElasticsearch ESPartitionInstanceType = "m4.10xlarge.elasticsearch"
	ESPartitionInstanceTypeT2MicroElasticsearch    ESPartitionInstanceType = "t2.micro.elasticsearch"
	ESPartitionInstanceTypeT2SmallElasticsearch    ESPartitionInstanceType = "t2.small.elasticsearch"
	ESPartitionInstanceTypeT2MediumElasticsearch   ESPartitionInstanceType = "t2.medium.elasticsearch"
	ESPartitionInstanceTypeR3LargeElasticsearch    ESPartitionInstanceType = "r3.large.elasticsearch"
	ESPartitionInstanceTypeR3XlargeElasticsearch   ESPartitionInstanceType = "r3.xlarge.elasticsearch"
	ESPartitionInstanceTypeR32xlargeElasticsearch  ESPartitionInstanceType = "r3.2xlarge.elasticsearch"
	ESPartitionInstanceTypeR34xlargeElasticsearch  ESPartitionInstanceType = "r3.4xlarge.elasticsearch"
	ESPartitionInstanceTypeR38xlargeElasticsearch  ESPartitionInstanceType = "r3.8xlarge.elasticsearch"
	ESPartitionInstanceTypeI2XlargeElasticsearch   ESPartitionInstanceType = "i2.xlarge.elasticsearch"
	ESPartitionInstanceTypeI22xlargeElasticsearch  ESPartitionInstanceType = "i2.2xlarge.elasticsearch"
	ESPartitionInstanceTypeD2XlargeElasticsearch   ESPartitionInstanceType = "d2.xlarge.elasticsearch"
	ESPartitionInstanceTypeD22xlargeElasticsearch  ESPartitionInstanceType = "d2.2xlarge.elasticsearch"
	ESPartitionInstanceTypeD24xlargeElasticsearch  ESPartitionInstanceType = "d2.4xlarge.elasticsearch"
	ESPartitionInstanceTypeD28xlargeElasticsearch  ESPartitionInstanceType = "d2.8xlarge.elasticsearch"
	ESPartitionInstanceTypeC4LargeElasticsearch    ESPartitionInstanceType = "c4.large.elasticsearch"
	ESPartitionInstanceTypeC4XlargeElasticsearch   ESPartitionInstanceType = "c4.xlarge.elasticsearch"
	ESPartitionInstanceTypeC42xlargeElasticsearch  ESPartitionInstanceType = "c4.2xlarge.elasticsearch"
	ESPartitionInstanceTypeC44xlargeElasticsearch  ESPartitionInstanceType = "c4.4xlarge.elasticsearch"
	ESPartitionInstanceTypeC48xlargeElasticsearch  ESPartitionInstanceType = "c4.8xlarge.elasticsearch"
	ESPartitionInstanceTypeR4LargeElasticsearch    ESPartitionInstanceType = "r4.large.elasticsearch"
	ESPartitionInstanceTypeR4XlargeElasticsearch   ESPartitionInstanceType = "r4.xlarge.elasticsearch"
	ESPartitionInstanceTypeR42xlargeElasticsearch  ESPartitionInstanceType = "r4.2xlarge.elasticsearch"
	ESPartitionInstanceTypeR44xlargeElasticsearch  ESPartitionInstanceType = "r4.4xlarge.elasticsearch"
	ESPartitionInstanceTypeR48xlargeElasticsearch  ESPartitionInstanceType = "r4.8xlarge.elasticsearch"
	ESPartitionInstanceTypeR416xlargeElasticsearch ESPartitionInstanceType = "r4.16xlarge.elasticsearch"
	ESPartitionInstanceTypeI3LargeElasticsearch    ESPartitionInstanceType = "i3.large.elasticsearch"
	ESPartitionInstanceTypeI3XlargeElasticsearch   ESPartitionInstanceType = "i3.xlarge.elasticsearch"
	ESPartitionInstanceTypeI32xlargeElasticsearch  ESPartitionInstanceType = "i3.2xlarge.elasticsearch"
	ESPartitionInstanceTypeI34xlargeElasticsearch  ESPartitionInstanceType = "i3.4xlarge.elasticsearch"
	ESPartitionInstanceTypeI38xlargeElasticsearch  ESPartitionInstanceType = "i3.8xlarge.elasticsearch"
	ESPartitionInstanceTypeI316xlargeElasticsearch ESPartitionInstanceType = "i3.16xlarge.elasticsearch"
)

func (enum ESPartitionInstanceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ESPartitionInstanceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// Type of Log File, it can be one of the following: INDEX_SLOW_LOGS: Index
// slow logs contain insert requests that took more time than configured index
// query log threshold to execute.
// SEARCH_SLOW_LOGS: Search slow logs contain search queries that took more
// time than configured search query log threshold to execute.
// ES_APPLICATION_LOGS: Elasticsearch application logs contain information about
// errors and warnings raised during the operation of the service and can be
// useful for troubleshooting.
type LogType string

// Enum values for LogType
const (
	LogTypeIndexSlowLogs     LogType = "INDEX_SLOW_LOGS"
	LogTypeSearchSlowLogs    LogType = "SEARCH_SLOW_LOGS"
	LogTypeEsApplicationLogs LogType = "ES_APPLICATION_LOGS"
)

func (enum LogType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum LogType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The state of a requested change. One of the following:
//
//    * Processing: The request change is still in-process.
//    * Active: The request change is processed and deployed to the Elasticsearch
//    domain.
type OptionState string

// Enum values for OptionState
const (
	OptionStateRequiresIndexDocuments OptionState = "RequiresIndexDocuments"
	OptionStateProcessing             OptionState = "Processing"
	OptionStateActive                 OptionState = "Active"
)

func (enum OptionState) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum OptionState) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ReservedElasticsearchInstancePaymentOption string

// Enum values for ReservedElasticsearchInstancePaymentOption
const (
	ReservedElasticsearchInstancePaymentOptionAllUpfront     ReservedElasticsearchInstancePaymentOption = "ALL_UPFRONT"
	ReservedElasticsearchInstancePaymentOptionPartialUpfront ReservedElasticsearchInstancePaymentOption = "PARTIAL_UPFRONT"
	ReservedElasticsearchInstancePaymentOptionNoUpfront      ReservedElasticsearchInstancePaymentOption = "NO_UPFRONT"
)

func (enum ReservedElasticsearchInstancePaymentOption) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReservedElasticsearchInstancePaymentOption) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type UpgradeStatus string

// Enum values for UpgradeStatus
const (
	UpgradeStatusInProgress          UpgradeStatus = "IN_PROGRESS"
	UpgradeStatusSucceeded           UpgradeStatus = "SUCCEEDED"
	UpgradeStatusSucceededWithIssues UpgradeStatus = "SUCCEEDED_WITH_ISSUES"
	UpgradeStatusFailed              UpgradeStatus = "FAILED"
)

func (enum UpgradeStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum UpgradeStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type UpgradeStep string

// Enum values for UpgradeStep
const (
	UpgradeStepPreUpgradeCheck UpgradeStep = "PRE_UPGRADE_CHECK"
	UpgradeStepSnapshot        UpgradeStep = "SNAPSHOT"
	UpgradeStepUpgrade         UpgradeStep = "UPGRADE"
)

func (enum UpgradeStep) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum UpgradeStep) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The type of EBS volume, standard, gp2, or io1. See Configuring EBS-based
// Storage (http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-createupdatedomains.html#es-createdomain-configure-ebs)for
// more information.
type VolumeType string

// Enum values for VolumeType
const (
	VolumeTypeStandard VolumeType = "standard"
	VolumeTypeGp2      VolumeType = "gp2"
	VolumeTypeIo1      VolumeType = "io1"
)

func (enum VolumeType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum VolumeType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
