// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package dynamodb

import (
	"context"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/jsonrpc"
)

const opBatchGetItem = "BatchGetItem"

// BatchGetItemRequest is a API request type for the BatchGetItem API operation.
type BatchGetItemRequest struct {
	*aws.Request
	Input *BatchGetItemInput
	Copy  func(*BatchGetItemInput) BatchGetItemRequest
}

// Send marshals and sends the BatchGetItem API request.
func (r BatchGetItemRequest) Send(ctx context.Context) (*BatchGetItemOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*BatchGetItemOutput), nil
}

// BatchGetItemRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// The BatchGetItem operation returns the attributes of one or more items from
// one or more tables. You identify requested items by primary key.
//
// A single operation can retrieve up to 16 MB of data, which can contain as
// many as 100 items. BatchGetItem will return a partial result if the response
// size limit is exceeded, the table's provisioned throughput is exceeded, or
// an internal processing failure occurs. If a partial result is returned, the
// operation returns a value for UnprocessedKeys. You can use this value to
// retry the operation starting with the next item to get.
//
// If you request more than 100 items BatchGetItem will return a ValidationException
// with the message "Too many items requested for the BatchGetItem call".
//
// For example, if you ask to retrieve 100 items, but each individual item is
// 300 KB in size, the system returns 52 items (so as not to exceed the 16 MB
// limit). It also returns an appropriate UnprocessedKeys value so you can get
// the next page of results. If desired, your application can include its own
// logic to assemble the pages of results into one data set.
//
// If none of the items can be processed due to insufficient provisioned throughput
// on all of the tables in the request, then BatchGetItem will return a ProvisionedThroughputExceededException.
// If at least one of the items is successfully processed, then BatchGetItem
// completes successfully, while returning the keys of the unread items in UnprocessedKeys.
//
// If DynamoDB returns any unprocessed items, you should retry the batch operation
// on those items. However, we strongly recommend that you use an exponential
// backoff algorithm. If you retry the batch operation immediately, the underlying
// read or write requests can still fail due to throttling on the individual
// tables. If you delay the batch operation using exponential backoff, the individual
// requests in the batch are much more likely to succeed.
//
// For more information, see Batch Operations and Error Handling (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOperations)
// in the Amazon DynamoDB Developer Guide.
//
// By default, BatchGetItem performs eventually consistent reads on every table
// in the request. If you want strongly consistent reads instead, you can set
// ConsistentRead to true for any or all tables.
//
// In order to minimize response latency, BatchGetItem retrieves items in parallel.
//
// When designing your application, keep in mind that DynamoDB does not return
// items in any particular order. To help parse the response by item, include
// the primary key values for the items in your request in the ProjectionExpression
// parameter.
//
// If a requested item does not exist, it is not returned in the result. Requests
// for nonexistent items consume the minimum read capacity units according to
// the type of read. For more information, see Capacity Units Calculations (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#CapacityUnitCalculations)
// in the Amazon DynamoDB Developer Guide.
//
//    // Example sending a request using the BatchGetItemRequest method.
//    req := client.BatchGetItemRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchGetItem
func (c *DynamoDB) BatchGetItemRequest(input *BatchGetItemInput) BatchGetItemRequest {
	op := &aws.Operation{
		Name:       opBatchGetItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"RequestItems"},
			OutputTokens:    []string{"UnprocessedKeys"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &BatchGetItemInput{}
	}

	output := &BatchGetItemOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return BatchGetItemRequest{Request: req, Input: input, Copy: c.BatchGetItemRequest}
}

// Paginate pages iterates over the pages of a BatchGetItemRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a BatchGetItem operation.
//		req := client.BatchGetItemRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *BatchGetItemRequest) Paginate(opts ...aws.Option) BatchGetItemPager {
	return BatchGetItemPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *BatchGetItemInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// BatchGetItemPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type BatchGetItemPager struct {
	aws.Pager
}

func (p *BatchGetItemPager) CurrentPage() *BatchGetItemOutput {
	return p.Pager.CurrentPage().(*BatchGetItemOutput)
}

const opBatchWriteItem = "BatchWriteItem"

// BatchWriteItemRequest is a API request type for the BatchWriteItem API operation.
type BatchWriteItemRequest struct {
	*aws.Request
	Input *BatchWriteItemInput
	Copy  func(*BatchWriteItemInput) BatchWriteItemRequest
}

// Send marshals and sends the BatchWriteItem API request.
func (r BatchWriteItemRequest) Send(ctx context.Context) (*BatchWriteItemOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*BatchWriteItemOutput), nil
}

// BatchWriteItemRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// The BatchWriteItem operation puts or deletes multiple items in one or more
// tables. A single call to BatchWriteItem can write up to 16 MB of data, which
// can comprise as many as 25 put or delete requests. Individual items to be
// written can be as large as 400 KB.
//
// BatchWriteItem cannot update items. To update items, use the UpdateItem action.
//
// The individual PutItem and DeleteItem operations specified in BatchWriteItem
// are atomic; however BatchWriteItem as a whole is not. If any requested operations
// fail because the table's provisioned throughput is exceeded or an internal
// processing failure occurs, the failed operations are returned in the UnprocessedItems
// response parameter. You can investigate and optionally resend the requests.
// Typically, you would call BatchWriteItem in a loop. Each iteration would
// check for unprocessed items and submit a new BatchWriteItem request with
// those unprocessed items until all items have been processed.
//
// Note that if none of the items can be processed due to insufficient provisioned
// throughput on all of the tables in the request, then BatchWriteItem will
// return a ProvisionedThroughputExceededException.
//
// If DynamoDB returns any unprocessed items, you should retry the batch operation
// on those items. However, we strongly recommend that you use an exponential
// backoff algorithm. If you retry the batch operation immediately, the underlying
// read or write requests can still fail due to throttling on the individual
// tables. If you delay the batch operation using exponential backoff, the individual
// requests in the batch are much more likely to succeed.
//
// For more information, see Batch Operations and Error Handling (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOperations)
// in the Amazon DynamoDB Developer Guide.
//
// With BatchWriteItem, you can efficiently write or delete large amounts of
// data, such as from Amazon Elastic MapReduce (EMR), or copy data from another
// database into DynamoDB. In order to improve performance with these large-scale
// operations, BatchWriteItem does not behave in the same way as individual
// PutItem and DeleteItem calls would. For example, you cannot specify conditions
// on individual put and delete requests, and BatchWriteItem does not return
// deleted items in the response.
//
// If you use a programming language that supports concurrency, you can use
// threads to write items in parallel. Your application must include the necessary
// logic to manage the threads. With languages that don't support threading,
// you must update or delete the specified items one at a time. In both situations,
// BatchWriteItem performs the specified put and delete operations in parallel,
// giving you the power of the thread pool approach without having to introduce
// complexity into your application.
//
// Parallel processing reduces latency, but each specified put and delete request
// consumes the same number of write capacity units whether it is processed
// in parallel or not. Delete operations on nonexistent items consume one write
// capacity unit.
//
// If one or more of the following is true, DynamoDB rejects the entire batch
// write operation:
//
//    * One or more tables specified in the BatchWriteItem request does not
//    exist.
//
//    * Primary key attributes specified on an item in the request do not match
//    those in the corresponding table's primary key schema.
//
//    * You try to perform multiple operations on the same item in the same
//    BatchWriteItem request. For example, you cannot put and delete the same
//    item in the same BatchWriteItem request.
//
//    *  Your request contains at least two items with identical hash and range
//    keys (which essentially is two put operations).
//
//    * There are more than 25 requests in the batch.
//
//    * Any individual item in a batch exceeds 400 KB.
//
//    * The total request size exceeds 16 MB.
//
//    // Example sending a request using the BatchWriteItemRequest method.
//    req := client.BatchWriteItemRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchWriteItem
func (c *DynamoDB) BatchWriteItemRequest(input *BatchWriteItemInput) BatchWriteItemRequest {
	op := &aws.Operation{
		Name:       opBatchWriteItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchWriteItemInput{}
	}

	output := &BatchWriteItemOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return BatchWriteItemRequest{Request: req, Input: input, Copy: c.BatchWriteItemRequest}
}

const opCreateBackup = "CreateBackup"

// CreateBackupRequest is a API request type for the CreateBackup API operation.
type CreateBackupRequest struct {
	*aws.Request
	Input *CreateBackupInput
	Copy  func(*CreateBackupInput) CreateBackupRequest
}

// Send marshals and sends the CreateBackup API request.
func (r CreateBackupRequest) Send(ctx context.Context) (*CreateBackupOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateBackupOutput), nil
}

// CreateBackupRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Creates a backup for an existing table.
//
// Each time you create an On-Demand Backup, the entire table data is backed
// up. There is no limit to the number of on-demand backups that can be taken.
//
// When you create an On-Demand Backup, a time marker of the request is cataloged,
// and the backup is created asynchronously, by applying all changes until the
// time of the request to the last full table snapshot. Backup requests are
// processed instantaneously and become available for restore within minutes.
//
// You can call CreateBackup at a maximum rate of 50 times per second.
//
// All backups in DynamoDB work without consuming any provisioned throughput
// on the table.
//
// If you submit a backup request on 2018-12-14 at 14:25:00, the backup is guaranteed
// to contain all data committed to the table up to 14:24:00, and data committed
// after 14:26:00 will not be. The backup may or may not contain data modifications
// made between 14:24:00 and 14:26:00. On-Demand Backup does not support causal
// consistency.
//
// Along with data, the following are also included on the backups:
//
//    * Global secondary indexes (GSIs)
//
//    * Local secondary indexes (LSIs)
//
//    * Streams
//
//    * Provisioned read and write capacity
//
//    // Example sending a request using the CreateBackupRequest method.
//    req := client.CreateBackupRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateBackup
func (c *DynamoDB) CreateBackupRequest(input *CreateBackupInput) CreateBackupRequest {
	op := &aws.Operation{
		Name:       opCreateBackup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateBackupInput{}
	}

	output := &CreateBackupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBackupRequest{Request: req, Input: input, Copy: c.CreateBackupRequest}
}

const opCreateGlobalTable = "CreateGlobalTable"

// CreateGlobalTableRequest is a API request type for the CreateGlobalTable API operation.
type CreateGlobalTableRequest struct {
	*aws.Request
	Input *CreateGlobalTableInput
	Copy  func(*CreateGlobalTableInput) CreateGlobalTableRequest
}

// Send marshals and sends the CreateGlobalTable API request.
func (r CreateGlobalTableRequest) Send(ctx context.Context) (*CreateGlobalTableOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateGlobalTableOutput), nil
}

// CreateGlobalTableRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Creates a global table from an existing table. A global table creates a replication
// relationship between two or more DynamoDB tables with the same table name
// in the provided regions.
//
// If you want to add a new replica table to a global table, each of the following
// conditions must be true:
//
//    * The table must have the same primary key as all of the other replicas.
//
//    * The table must have the same name as all of the other replicas.
//
//    * The table must have DynamoDB Streams enabled, with the stream containing
//    both the new and the old images of the item.
//
//    * None of the replica tables in the global table can contain any data.
//
// If global secondary indexes are specified, then the following conditions
// must also be met:
//
//    *  The global secondary indexes must have the same name.
//
//    *  The global secondary indexes must have the same hash key and sort key
//    (if present).
//
// Write capacity settings should be set consistently across your replica tables
// and secondary indexes. DynamoDB strongly recommends enabling auto scaling
// to manage the write capacity settings for all of your global tables replicas
// and indexes.
//
//  If you prefer to manage write capacity settings manually, you should provision
// equal replicated write capacity units to your replica tables. You should
// also provision equal replicated write capacity units to matching secondary
// indexes across your global table.
//
//    // Example sending a request using the CreateGlobalTableRequest method.
//    req := client.CreateGlobalTableRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateGlobalTable
func (c *DynamoDB) CreateGlobalTableRequest(input *CreateGlobalTableInput) CreateGlobalTableRequest {
	op := &aws.Operation{
		Name:       opCreateGlobalTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateGlobalTableInput{}
	}

	output := &CreateGlobalTableOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateGlobalTableRequest{Request: req, Input: input, Copy: c.CreateGlobalTableRequest}
}

const opCreateTable = "CreateTable"

// CreateTableRequest is a API request type for the CreateTable API operation.
type CreateTableRequest struct {
	*aws.Request
	Input *CreateTableInput
	Copy  func(*CreateTableInput) CreateTableRequest
}

// Send marshals and sends the CreateTable API request.
func (r CreateTableRequest) Send(ctx context.Context) (*CreateTableOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTableOutput), nil
}

// CreateTableRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// The CreateTable operation adds a new table to your account. In an AWS account,
// table names must be unique within each region. That is, you can have two
// tables with same name if you create the tables in different regions.
//
// CreateTable is an asynchronous operation. Upon receiving a CreateTable request,
// DynamoDB immediately returns a response with a TableStatus of CREATING. After
// the table is created, DynamoDB sets the TableStatus to ACTIVE. You can perform
// read and write operations only on an ACTIVE table.
//
// You can optionally define secondary indexes on the new table, as part of
// the CreateTable operation. If you want to create multiple tables with secondary
// indexes on them, you must create the tables sequentially. Only one table
// with secondary indexes can be in the CREATING state at any given time.
//
// You can use the DescribeTable action to check the table status.
//
//    // Example sending a request using the CreateTableRequest method.
//    req := client.CreateTableRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateTable
func (c *DynamoDB) CreateTableRequest(input *CreateTableInput) CreateTableRequest {
	op := &aws.Operation{
		Name:       opCreateTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateTableInput{}
	}

	output := &CreateTableOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTableRequest{Request: req, Input: input, Copy: c.CreateTableRequest}
}

const opDeleteBackup = "DeleteBackup"

// DeleteBackupRequest is a API request type for the DeleteBackup API operation.
type DeleteBackupRequest struct {
	*aws.Request
	Input *DeleteBackupInput
	Copy  func(*DeleteBackupInput) DeleteBackupRequest
}

// Send marshals and sends the DeleteBackup API request.
func (r DeleteBackupRequest) Send(ctx context.Context) (*DeleteBackupOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBackupOutput), nil
}

// DeleteBackupRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Deletes an existing backup of a table.
//
// You can call DeleteBackup at a maximum rate of 10 times per second.
//
//    // Example sending a request using the DeleteBackupRequest method.
//    req := client.DeleteBackupRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteBackup
func (c *DynamoDB) DeleteBackupRequest(input *DeleteBackupInput) DeleteBackupRequest {
	op := &aws.Operation{
		Name:       opDeleteBackup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteBackupInput{}
	}

	output := &DeleteBackupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBackupRequest{Request: req, Input: input, Copy: c.DeleteBackupRequest}
}

const opDeleteItem = "DeleteItem"

// DeleteItemRequest is a API request type for the DeleteItem API operation.
type DeleteItemRequest struct {
	*aws.Request
	Input *DeleteItemInput
	Copy  func(*DeleteItemInput) DeleteItemRequest
}

// Send marshals and sends the DeleteItem API request.
func (r DeleteItemRequest) Send(ctx context.Context) (*DeleteItemOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteItemOutput), nil
}

// DeleteItemRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Deletes a single item in a table by primary key. You can perform a conditional
// delete operation that deletes the item if it exists, or if it has an expected
// attribute value.
//
// In addition to deleting an item, you can also return the item's attribute
// values in the same operation, using the ReturnValues parameter.
//
// Unless you specify conditions, the DeleteItem is an idempotent operation;
// running it multiple times on the same item or attribute does not result in
// an error response.
//
// Conditional deletes are useful for deleting items only if specific conditions
// are met. If those conditions are met, DynamoDB performs the delete. Otherwise,
// the item is not deleted.
//
//    // Example sending a request using the DeleteItemRequest method.
//    req := client.DeleteItemRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteItem
func (c *DynamoDB) DeleteItemRequest(input *DeleteItemInput) DeleteItemRequest {
	op := &aws.Operation{
		Name:       opDeleteItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteItemInput{}
	}

	output := &DeleteItemOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteItemRequest{Request: req, Input: input, Copy: c.DeleteItemRequest}
}

const opDeleteTable = "DeleteTable"

// DeleteTableRequest is a API request type for the DeleteTable API operation.
type DeleteTableRequest struct {
	*aws.Request
	Input *DeleteTableInput
	Copy  func(*DeleteTableInput) DeleteTableRequest
}

// Send marshals and sends the DeleteTable API request.
func (r DeleteTableRequest) Send(ctx context.Context) (*DeleteTableOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTableOutput), nil
}

// DeleteTableRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// The DeleteTable operation deletes a table and all of its items. After a DeleteTable
// request, the specified table is in the DELETING state until DynamoDB completes
// the deletion. If the table is in the ACTIVE state, you can delete it. If
// a table is in CREATING or UPDATING states, then DynamoDB returns a ResourceInUseException.
// If the specified table does not exist, DynamoDB returns a ResourceNotFoundException.
// If table is already in the DELETING state, no error is returned.
//
// DynamoDB might continue to accept data read and write operations, such as
// GetItem and PutItem, on a table in the DELETING state until the table deletion
// is complete.
//
// When you delete a table, any indexes on that table are also deleted.
//
// If you have DynamoDB Streams enabled on the table, then the corresponding
// stream on that table goes into the DISABLED state, and the stream is automatically
// deleted after 24 hours.
//
// Use the DescribeTable action to check the status of the table.
//
//    // Example sending a request using the DeleteTableRequest method.
//    req := client.DeleteTableRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteTable
func (c *DynamoDB) DeleteTableRequest(input *DeleteTableInput) DeleteTableRequest {
	op := &aws.Operation{
		Name:       opDeleteTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteTableInput{}
	}

	output := &DeleteTableOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTableRequest{Request: req, Input: input, Copy: c.DeleteTableRequest}
}

const opDescribeBackup = "DescribeBackup"

// DescribeBackupRequest is a API request type for the DescribeBackup API operation.
type DescribeBackupRequest struct {
	*aws.Request
	Input *DescribeBackupInput
	Copy  func(*DescribeBackupInput) DescribeBackupRequest
}

// Send marshals and sends the DescribeBackup API request.
func (r DescribeBackupRequest) Send(ctx context.Context) (*DescribeBackupOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeBackupOutput), nil
}

// DescribeBackupRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Describes an existing backup of a table.
//
// You can call DescribeBackup at a maximum rate of 10 times per second.
//
//    // Example sending a request using the DescribeBackupRequest method.
//    req := client.DescribeBackupRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeBackup
func (c *DynamoDB) DescribeBackupRequest(input *DescribeBackupInput) DescribeBackupRequest {
	op := &aws.Operation{
		Name:       opDescribeBackup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeBackupInput{}
	}

	output := &DescribeBackupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeBackupRequest{Request: req, Input: input, Copy: c.DescribeBackupRequest}
}

const opDescribeContinuousBackups = "DescribeContinuousBackups"

// DescribeContinuousBackupsRequest is a API request type for the DescribeContinuousBackups API operation.
type DescribeContinuousBackupsRequest struct {
	*aws.Request
	Input *DescribeContinuousBackupsInput
	Copy  func(*DescribeContinuousBackupsInput) DescribeContinuousBackupsRequest
}

// Send marshals and sends the DescribeContinuousBackups API request.
func (r DescribeContinuousBackupsRequest) Send(ctx context.Context) (*DescribeContinuousBackupsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeContinuousBackupsOutput), nil
}

// DescribeContinuousBackupsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Checks the status of continuous backups and point in time recovery on the
// specified table. Continuous backups are ENABLED on all tables at table creation.
// If point in time recovery is enabled, PointInTimeRecoveryStatus will be set
// to ENABLED.
//
// Once continuous backups and point in time recovery are enabled, you can restore
// to any point in time within EarliestRestorableDateTime and LatestRestorableDateTime.
//
// LatestRestorableDateTime is typically 5 minutes before the current time.
// You can restore your table to any point in time during the last 35 days.
//
// You can call DescribeContinuousBackups at a maximum rate of 10 times per
// second.
//
//    // Example sending a request using the DescribeContinuousBackupsRequest method.
//    req := client.DescribeContinuousBackupsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeContinuousBackups
func (c *DynamoDB) DescribeContinuousBackupsRequest(input *DescribeContinuousBackupsInput) DescribeContinuousBackupsRequest {
	op := &aws.Operation{
		Name:       opDescribeContinuousBackups,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeContinuousBackupsInput{}
	}

	output := &DescribeContinuousBackupsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeContinuousBackupsRequest{Request: req, Input: input, Copy: c.DescribeContinuousBackupsRequest}
}

const opDescribeEndpoints = "DescribeEndpoints"

// DescribeEndpointsRequest is a API request type for the DescribeEndpoints API operation.
type DescribeEndpointsRequest struct {
	*aws.Request
	Input *DescribeEndpointsInput
	Copy  func(*DescribeEndpointsInput) DescribeEndpointsRequest
}

// Send marshals and sends the DescribeEndpoints API request.
func (r DescribeEndpointsRequest) Send(ctx context.Context) (*DescribeEndpointsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeEndpointsOutput), nil
}

// DescribeEndpointsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
//    // Example sending a request using the DescribeEndpointsRequest method.
//    req := client.DescribeEndpointsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeEndpoints
func (c *DynamoDB) DescribeEndpointsRequest(input *DescribeEndpointsInput) DescribeEndpointsRequest {
	op := &aws.Operation{
		Name:       opDescribeEndpoints,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeEndpointsInput{}
	}

	output := &DescribeEndpointsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeEndpointsRequest{Request: req, Input: input, Copy: c.DescribeEndpointsRequest}
}

const opDescribeGlobalTable = "DescribeGlobalTable"

// DescribeGlobalTableRequest is a API request type for the DescribeGlobalTable API operation.
type DescribeGlobalTableRequest struct {
	*aws.Request
	Input *DescribeGlobalTableInput
	Copy  func(*DescribeGlobalTableInput) DescribeGlobalTableRequest
}

// Send marshals and sends the DescribeGlobalTable API request.
func (r DescribeGlobalTableRequest) Send(ctx context.Context) (*DescribeGlobalTableOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeGlobalTableOutput), nil
}

// DescribeGlobalTableRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Returns information about the specified global table.
//
//    // Example sending a request using the DescribeGlobalTableRequest method.
//    req := client.DescribeGlobalTableRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTable
func (c *DynamoDB) DescribeGlobalTableRequest(input *DescribeGlobalTableInput) DescribeGlobalTableRequest {
	op := &aws.Operation{
		Name:       opDescribeGlobalTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeGlobalTableInput{}
	}

	output := &DescribeGlobalTableOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeGlobalTableRequest{Request: req, Input: input, Copy: c.DescribeGlobalTableRequest}
}

const opDescribeGlobalTableSettings = "DescribeGlobalTableSettings"

// DescribeGlobalTableSettingsRequest is a API request type for the DescribeGlobalTableSettings API operation.
type DescribeGlobalTableSettingsRequest struct {
	*aws.Request
	Input *DescribeGlobalTableSettingsInput
	Copy  func(*DescribeGlobalTableSettingsInput) DescribeGlobalTableSettingsRequest
}

// Send marshals and sends the DescribeGlobalTableSettings API request.
func (r DescribeGlobalTableSettingsRequest) Send(ctx context.Context) (*DescribeGlobalTableSettingsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeGlobalTableSettingsOutput), nil
}

// DescribeGlobalTableSettingsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Describes region specific settings for a global table.
//
//    // Example sending a request using the DescribeGlobalTableSettingsRequest method.
//    req := client.DescribeGlobalTableSettingsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTableSettings
func (c *DynamoDB) DescribeGlobalTableSettingsRequest(input *DescribeGlobalTableSettingsInput) DescribeGlobalTableSettingsRequest {
	op := &aws.Operation{
		Name:       opDescribeGlobalTableSettings,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeGlobalTableSettingsInput{}
	}

	output := &DescribeGlobalTableSettingsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeGlobalTableSettingsRequest{Request: req, Input: input, Copy: c.DescribeGlobalTableSettingsRequest}
}

const opDescribeLimits = "DescribeLimits"

// DescribeLimitsRequest is a API request type for the DescribeLimits API operation.
type DescribeLimitsRequest struct {
	*aws.Request
	Input *DescribeLimitsInput
	Copy  func(*DescribeLimitsInput) DescribeLimitsRequest
}

// Send marshals and sends the DescribeLimits API request.
func (r DescribeLimitsRequest) Send(ctx context.Context) (*DescribeLimitsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeLimitsOutput), nil
}

// DescribeLimitsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Returns the current provisioned-capacity limits for your AWS account in a
// region, both for the region as a whole and for any one DynamoDB table that
// you create there.
//
// When you establish an AWS account, the account has initial limits on the
// maximum read capacity units and write capacity units that you can provision
// across all of your DynamoDB tables in a given region. Also, there are per-table
// limits that apply when you create a table there. For more information, see
// Limits (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
// page in the Amazon DynamoDB Developer Guide.
//
// Although you can increase these limits by filing a case at AWS Support Center
// (https://console.aws.amazon.com/support/home#/), obtaining the increase is
// not instantaneous. The DescribeLimits action lets you write code to compare
// the capacity you are currently using to those limits imposed by your account
// so that you have enough time to apply for an increase before you hit a limit.
//
// For example, you could use one of the AWS SDKs to do the following:
//
// Call DescribeLimits for a particular region to obtain your current account
// limits on provisioned capacity there.
//
// Create a variable to hold the aggregate read capacity units provisioned for
// all your tables in that region, and one to hold the aggregate write capacity
// units. Zero them both.
//
// Call ListTables to obtain a list of all your DynamoDB tables.
//
// For each table name listed by ListTables, do the following:
//
// Call DescribeTable with the table name.
//
// Use the data returned by DescribeTable to add the read capacity units and
// write capacity units provisioned for the table itself to your variables.
//
// If the table has one or more global secondary indexes (GSIs), loop over these
// GSIs and add their provisioned capacity values to your variables as well.
//
// Report the account limits for that region returned by DescribeLimits, along
// with the total current provisioned capacity levels you have calculated.
//
// This will let you see whether you are getting close to your account-level
// limits.
//
// The per-table limits apply only when you are creating a new table. They restrict
// the sum of the provisioned capacity of the new table itself and all its global
// secondary indexes.
//
// For existing tables and their GSIs, DynamoDB will not let you increase provisioned
// capacity extremely rapidly, but the only upper limit that applies is that
// the aggregate provisioned capacity over all your tables and GSIs cannot exceed
// either of the per-account limits.
//
// DescribeLimits should only be called periodically. You can expect throttling
// errors if you call it more than once in a minute.
//
// The DescribeLimits Request element has no content.
//
//    // Example sending a request using the DescribeLimitsRequest method.
//    req := client.DescribeLimitsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeLimits
func (c *DynamoDB) DescribeLimitsRequest(input *DescribeLimitsInput) DescribeLimitsRequest {
	op := &aws.Operation{
		Name:       opDescribeLimits,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeLimitsInput{}
	}

	output := &DescribeLimitsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeLimitsRequest{Request: req, Input: input, Copy: c.DescribeLimitsRequest}
}

const opDescribeTable = "DescribeTable"

// DescribeTableRequest is a API request type for the DescribeTable API operation.
type DescribeTableRequest struct {
	*aws.Request
	Input *DescribeTableInput
	Copy  func(*DescribeTableInput) DescribeTableRequest
}

// Send marshals and sends the DescribeTable API request.
func (r DescribeTableRequest) Send(ctx context.Context) (*DescribeTableOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeTableOutput), nil
}

// DescribeTableRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Returns information about the table, including the current status of the
// table, when it was created, the primary key schema, and any indexes on the
// table.
//
// If you issue a DescribeTable request immediately after a CreateTable request,
// DynamoDB might return a ResourceNotFoundException. This is because DescribeTable
// uses an eventually consistent query, and the metadata for your table might
// not be available at that moment. Wait for a few seconds, and then try the
// DescribeTable request again.
//
//    // Example sending a request using the DescribeTableRequest method.
//    req := client.DescribeTableRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTable
func (c *DynamoDB) DescribeTableRequest(input *DescribeTableInput) DescribeTableRequest {
	op := &aws.Operation{
		Name:       opDescribeTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeTableInput{}
	}

	output := &DescribeTableOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeTableRequest{Request: req, Input: input, Copy: c.DescribeTableRequest}
}

const opDescribeTimeToLive = "DescribeTimeToLive"

// DescribeTimeToLiveRequest is a API request type for the DescribeTimeToLive API operation.
type DescribeTimeToLiveRequest struct {
	*aws.Request
	Input *DescribeTimeToLiveInput
	Copy  func(*DescribeTimeToLiveInput) DescribeTimeToLiveRequest
}

// Send marshals and sends the DescribeTimeToLive API request.
func (r DescribeTimeToLiveRequest) Send(ctx context.Context) (*DescribeTimeToLiveOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeTimeToLiveOutput), nil
}

// DescribeTimeToLiveRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Gives a description of the Time to Live (TTL) status on the specified table.
//
//    // Example sending a request using the DescribeTimeToLiveRequest method.
//    req := client.DescribeTimeToLiveRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTimeToLive
func (c *DynamoDB) DescribeTimeToLiveRequest(input *DescribeTimeToLiveInput) DescribeTimeToLiveRequest {
	op := &aws.Operation{
		Name:       opDescribeTimeToLive,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeTimeToLiveInput{}
	}

	output := &DescribeTimeToLiveOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeTimeToLiveRequest{Request: req, Input: input, Copy: c.DescribeTimeToLiveRequest}
}

const opGetItem = "GetItem"

// GetItemRequest is a API request type for the GetItem API operation.
type GetItemRequest struct {
	*aws.Request
	Input *GetItemInput
	Copy  func(*GetItemInput) GetItemRequest
}

// Send marshals and sends the GetItem API request.
func (r GetItemRequest) Send(ctx context.Context) (*GetItemOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetItemOutput), nil
}

// GetItemRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// The GetItem operation returns a set of attributes for the item with the given
// primary key. If there is no matching item, GetItem does not return any data
// and there will be no Item element in the response.
//
// GetItem provides an eventually consistent read by default. If your application
// requires a strongly consistent read, set ConsistentRead to true. Although
// a strongly consistent read might take more time than an eventually consistent
// read, it always returns the last updated value.
//
//    // Example sending a request using the GetItemRequest method.
//    req := client.GetItemRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GetItem
func (c *DynamoDB) GetItemRequest(input *GetItemInput) GetItemRequest {
	op := &aws.Operation{
		Name:       opGetItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetItemInput{}
	}

	output := &GetItemOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetItemRequest{Request: req, Input: input, Copy: c.GetItemRequest}
}

const opListBackups = "ListBackups"

// ListBackupsRequest is a API request type for the ListBackups API operation.
type ListBackupsRequest struct {
	*aws.Request
	Input *ListBackupsInput
	Copy  func(*ListBackupsInput) ListBackupsRequest
}

// Send marshals and sends the ListBackups API request.
func (r ListBackupsRequest) Send(ctx context.Context) (*ListBackupsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBackupsOutput), nil
}

// ListBackupsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// List backups associated with an AWS account. To list backups for a given
// table, specify TableName. ListBackups returns a paginated list of results
// with at most 1MB worth of items in a page. You can also specify a limit for
// the maximum number of entries to be returned in a page.
//
// In the request, start time is inclusive but end time is exclusive. Note that
// these limits are for the time at which the original backup was requested.
//
// You can call ListBackups a maximum of 5 times per second.
//
//    // Example sending a request using the ListBackupsRequest method.
//    req := client.ListBackupsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListBackups
func (c *DynamoDB) ListBackupsRequest(input *ListBackupsInput) ListBackupsRequest {
	op := &aws.Operation{
		Name:       opListBackups,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListBackupsInput{}
	}

	output := &ListBackupsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBackupsRequest{Request: req, Input: input, Copy: c.ListBackupsRequest}
}

const opListGlobalTables = "ListGlobalTables"

// ListGlobalTablesRequest is a API request type for the ListGlobalTables API operation.
type ListGlobalTablesRequest struct {
	*aws.Request
	Input *ListGlobalTablesInput
	Copy  func(*ListGlobalTablesInput) ListGlobalTablesRequest
}

// Send marshals and sends the ListGlobalTables API request.
func (r ListGlobalTablesRequest) Send(ctx context.Context) (*ListGlobalTablesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListGlobalTablesOutput), nil
}

// ListGlobalTablesRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Lists all global tables that have a replica in the specified region.
//
//    // Example sending a request using the ListGlobalTablesRequest method.
//    req := client.ListGlobalTablesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListGlobalTables
func (c *DynamoDB) ListGlobalTablesRequest(input *ListGlobalTablesInput) ListGlobalTablesRequest {
	op := &aws.Operation{
		Name:       opListGlobalTables,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListGlobalTablesInput{}
	}

	output := &ListGlobalTablesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListGlobalTablesRequest{Request: req, Input: input, Copy: c.ListGlobalTablesRequest}
}

const opListTables = "ListTables"

// ListTablesRequest is a API request type for the ListTables API operation.
type ListTablesRequest struct {
	*aws.Request
	Input *ListTablesInput
	Copy  func(*ListTablesInput) ListTablesRequest
}

// Send marshals and sends the ListTables API request.
func (r ListTablesRequest) Send(ctx context.Context) (*ListTablesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTablesOutput), nil
}

// ListTablesRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Returns an array of table names associated with the current account and endpoint.
// The output from ListTables is paginated, with each page returning a maximum
// of 100 table names.
//
//    // Example sending a request using the ListTablesRequest method.
//    req := client.ListTablesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTables
func (c *DynamoDB) ListTablesRequest(input *ListTablesInput) ListTablesRequest {
	op := &aws.Operation{
		Name:       opListTables,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"ExclusiveStartTableName"},
			OutputTokens:    []string{"LastEvaluatedTableName"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListTablesInput{}
	}

	output := &ListTablesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTablesRequest{Request: req, Input: input, Copy: c.ListTablesRequest}
}

// Paginate pages iterates over the pages of a ListTablesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListTables operation.
//		req := client.ListTablesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListTablesRequest) Paginate(opts ...aws.Option) ListTablesPager {
	return ListTablesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListTablesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListTablesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListTablesPager struct {
	aws.Pager
}

func (p *ListTablesPager) CurrentPage() *ListTablesOutput {
	return p.Pager.CurrentPage().(*ListTablesOutput)
}

const opListTagsOfResource = "ListTagsOfResource"

// ListTagsOfResourceRequest is a API request type for the ListTagsOfResource API operation.
type ListTagsOfResourceRequest struct {
	*aws.Request
	Input *ListTagsOfResourceInput
	Copy  func(*ListTagsOfResourceInput) ListTagsOfResourceRequest
}

// Send marshals and sends the ListTagsOfResource API request.
func (r ListTagsOfResourceRequest) Send(ctx context.Context) (*ListTagsOfResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTagsOfResourceOutput), nil
}

// ListTagsOfResourceRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// List all tags on an Amazon DynamoDB resource. You can call ListTagsOfResource
// up to 10 times per second, per account.
//
// For an overview on tagging DynamoDB resources, see Tagging for DynamoDB (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
// in the Amazon DynamoDB Developer Guide.
//
//    // Example sending a request using the ListTagsOfResourceRequest method.
//    req := client.ListTagsOfResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTagsOfResource
func (c *DynamoDB) ListTagsOfResourceRequest(input *ListTagsOfResourceInput) ListTagsOfResourceRequest {
	op := &aws.Operation{
		Name:       opListTagsOfResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListTagsOfResourceInput{}
	}

	output := &ListTagsOfResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTagsOfResourceRequest{Request: req, Input: input, Copy: c.ListTagsOfResourceRequest}
}

const opPutItem = "PutItem"

// PutItemRequest is a API request type for the PutItem API operation.
type PutItemRequest struct {
	*aws.Request
	Input *PutItemInput
	Copy  func(*PutItemInput) PutItemRequest
}

// Send marshals and sends the PutItem API request.
func (r PutItemRequest) Send(ctx context.Context) (*PutItemOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*PutItemOutput), nil
}

// PutItemRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Creates a new item, or replaces an old item with a new item. If an item that
// has the same primary key as the new item already exists in the specified
// table, the new item completely replaces the existing item. You can perform
// a conditional put operation (add a new item if one with the specified primary
// key doesn't exist), or replace an existing item if it has certain attribute
// values. You can return the item's attribute values in the same operation,
// using the ReturnValues parameter.
//
// This topic provides general information about the PutItem API.
//
// For information on how to call the PutItem API using the AWS SDK in specific
// languages, see the following:
//
//  PutItem in the AWS Command Line Interface  (http://docs.aws.amazon.com/goto/aws-cli/dynamodb-2012-08-10/PutItem)
//
//  PutItem in the AWS SDK for .NET  (http://docs.aws.amazon.com/goto/DotNetSDKV3/dynamodb-2012-08-10/PutItem)
//
//  PutItem in the AWS SDK for C++  (http://docs.aws.amazon.com/goto/SdkForCpp/dynamodb-2012-08-10/PutItem)
//
//  PutItem in the AWS SDK for Go  (http://docs.aws.amazon.com/goto/SdkForGoV1/dynamodb-2012-08-10/PutItem)
//
//  PutItem in the AWS SDK for Java  (http://docs.aws.amazon.com/goto/SdkForJava/dynamodb-2012-08-10/PutItem)
//
//  PutItem in the AWS SDK for JavaScript  (http://docs.aws.amazon.com/goto/AWSJavaScriptSDK/dynamodb-2012-08-10/PutItem)
//
//  PutItem in the AWS SDK for PHP V3  (http://docs.aws.amazon.com/goto/SdkForPHPV3/dynamodb-2012-08-10/PutItem)
//
//  PutItem in the AWS SDK for Python  (http://docs.aws.amazon.com/goto/boto3/dynamodb-2012-08-10/PutItem)
//
//  PutItem in the AWS SDK for Ruby V2  (http://docs.aws.amazon.com/goto/SdkForRubyV2/dynamodb-2012-08-10/PutItem)
//
// When you add an item, the primary key attribute(s) are the only required
// attributes. Attribute values cannot be null. String and Binary type attributes
// must have lengths greater than zero. Set type attributes cannot be empty.
// Requests with empty values will be rejected with a ValidationException exception.
//
// To prevent a new item from replacing an existing item, use a conditional
// expression that contains the attribute_not_exists function with the name
// of the attribute being used as the partition key for the table. Since every
// record must contain that attribute, the attribute_not_exists function will
// only succeed if no matching item exists.
//
// For more information about PutItem, see Working with Items (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html)
// in the Amazon DynamoDB Developer Guide.
//
//    // Example sending a request using the PutItemRequest method.
//    req := client.PutItemRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/PutItem
func (c *DynamoDB) PutItemRequest(input *PutItemInput) PutItemRequest {
	op := &aws.Operation{
		Name:       opPutItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PutItemInput{}
	}

	output := &PutItemOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutItemRequest{Request: req, Input: input, Copy: c.PutItemRequest}
}

const opQuery = "Query"

// QueryRequest is a API request type for the Query API operation.
type QueryRequest struct {
	*aws.Request
	Input *QueryInput
	Copy  func(*QueryInput) QueryRequest
}

// Send marshals and sends the Query API request.
func (r QueryRequest) Send(ctx context.Context) (*QueryOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*QueryOutput), nil
}

// QueryRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// The Query operation finds items based on primary key values. You can query
// any table or secondary index that has a composite primary key (a partition
// key and a sort key).
//
// Use the KeyConditionExpression parameter to provide a specific value for
// the partition key. The Query operation will return all of the items from
// the table or index with that partition key value. You can optionally narrow
// the scope of the Query operation by specifying a sort key value and a comparison
// operator in KeyConditionExpression. To further refine the Query results,
// you can optionally provide a FilterExpression. A FilterExpression determines
// which items within the results should be returned to you. All of the other
// results are discarded.
//
// A Query operation always returns a result set. If no matching items are found,
// the result set will be empty. Queries that do not return results consume
// the minimum number of read capacity units for that type of read operation.
//
// DynamoDB calculates the number of read capacity units consumed based on item
// size, not on the amount of data that is returned to an application. The number
// of capacity units consumed will be the same whether you request all of the
// attributes (the default behavior) or just some of them (using a projection
// expression). The number will also be the same whether or not you use a FilterExpression.
//
// Query results are always sorted by the sort key value. If the data type of
// the sort key is Number, the results are returned in numeric order; otherwise,
// the results are returned in order of UTF-8 bytes. By default, the sort order
// is ascending. To reverse the order, set the ScanIndexForward parameter to
// false.
//
// A single Query operation will read up to the maximum number of items set
// (if using the Limit parameter) or a maximum of 1 MB of data and then apply
// any filtering to the results using FilterExpression. If LastEvaluatedKey
// is present in the response, you will need to paginate the result set. For
// more information, see Paginating the Results (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.Pagination)
// in the Amazon DynamoDB Developer Guide.
//
// FilterExpression is applied after a Query finishes, but before the results
// are returned. A FilterExpression cannot contain partition key or sort key
// attributes. You need to specify those attributes in the KeyConditionExpression.
//
// A Query operation can return an empty result set and a LastEvaluatedKey if
// all the items read for the page of results are filtered out.
//
// You can query a table, a local secondary index, or a global secondary index.
// For a query on a table or on a local secondary index, you can set the ConsistentRead
// parameter to true and obtain a strongly consistent result. Global secondary
// indexes support eventually consistent reads only, so do not specify ConsistentRead
// when querying a global secondary index.
//
//    // Example sending a request using the QueryRequest method.
//    req := client.QueryRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Query
func (c *DynamoDB) QueryRequest(input *QueryInput) QueryRequest {
	op := &aws.Operation{
		Name:       opQuery,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"ExclusiveStartKey"},
			OutputTokens:    []string{"LastEvaluatedKey"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &QueryInput{}
	}

	output := &QueryOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return QueryRequest{Request: req, Input: input, Copy: c.QueryRequest}
}

// Paginate pages iterates over the pages of a QueryRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a Query operation.
//		req := client.QueryRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *QueryRequest) Paginate(opts ...aws.Option) QueryPager {
	return QueryPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *QueryInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// QueryPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type QueryPager struct {
	aws.Pager
}

func (p *QueryPager) CurrentPage() *QueryOutput {
	return p.Pager.CurrentPage().(*QueryOutput)
}

const opRestoreTableFromBackup = "RestoreTableFromBackup"

// RestoreTableFromBackupRequest is a API request type for the RestoreTableFromBackup API operation.
type RestoreTableFromBackupRequest struct {
	*aws.Request
	Input *RestoreTableFromBackupInput
	Copy  func(*RestoreTableFromBackupInput) RestoreTableFromBackupRequest
}

// Send marshals and sends the RestoreTableFromBackup API request.
func (r RestoreTableFromBackupRequest) Send(ctx context.Context) (*RestoreTableFromBackupOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RestoreTableFromBackupOutput), nil
}

// RestoreTableFromBackupRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Creates a new table from an existing backup. Any number of users can execute
// up to 4 concurrent restores (any type of restore) in a given account.
//
// You can call RestoreTableFromBackup at a maximum rate of 10 times per second.
//
// You must manually set up the following on the restored table:
//
//    * Auto scaling policies
//
//    * IAM policies
//
//    * Cloudwatch metrics and alarms
//
//    * Tags
//
//    * Stream settings
//
//    * Time to Live (TTL) settings
//
//    // Example sending a request using the RestoreTableFromBackupRequest method.
//    req := client.RestoreTableFromBackupRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableFromBackup
func (c *DynamoDB) RestoreTableFromBackupRequest(input *RestoreTableFromBackupInput) RestoreTableFromBackupRequest {
	op := &aws.Operation{
		Name:       opRestoreTableFromBackup,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RestoreTableFromBackupInput{}
	}

	output := &RestoreTableFromBackupOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RestoreTableFromBackupRequest{Request: req, Input: input, Copy: c.RestoreTableFromBackupRequest}
}

const opRestoreTableToPointInTime = "RestoreTableToPointInTime"

// RestoreTableToPointInTimeRequest is a API request type for the RestoreTableToPointInTime API operation.
type RestoreTableToPointInTimeRequest struct {
	*aws.Request
	Input *RestoreTableToPointInTimeInput
	Copy  func(*RestoreTableToPointInTimeInput) RestoreTableToPointInTimeRequest
}

// Send marshals and sends the RestoreTableToPointInTime API request.
func (r RestoreTableToPointInTimeRequest) Send(ctx context.Context) (*RestoreTableToPointInTimeOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RestoreTableToPointInTimeOutput), nil
}

// RestoreTableToPointInTimeRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Restores the specified table to the specified point in time within EarliestRestorableDateTime
// and LatestRestorableDateTime. You can restore your table to any point in
// time during the last 35 days. Any number of users can execute up to 4 concurrent
// restores (any type of restore) in a given account.
//
// When you restore using point in time recovery, DynamoDB restores your table
// data to the state based on the selected date and time (day:hour:minute:second)
// to a new table.
//
// Along with data, the following are also included on the new restored table
// using point in time recovery:
//
//    * Global secondary indexes (GSIs)
//
//    * Local secondary indexes (LSIs)
//
//    * Provisioned read and write capacity
//
//    * Encryption settings
//
//  All these settings come from the current settings of the source table at
//    the time of restore.
//
// You must manually set up the following on the restored table:
//
//    * Auto scaling policies
//
//    * IAM policies
//
//    * Cloudwatch metrics and alarms
//
//    * Tags
//
//    * Stream settings
//
//    * Time to Live (TTL) settings
//
//    * Point in time recovery settings
//
//    // Example sending a request using the RestoreTableToPointInTimeRequest method.
//    req := client.RestoreTableToPointInTimeRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableToPointInTime
func (c *DynamoDB) RestoreTableToPointInTimeRequest(input *RestoreTableToPointInTimeInput) RestoreTableToPointInTimeRequest {
	op := &aws.Operation{
		Name:       opRestoreTableToPointInTime,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &RestoreTableToPointInTimeInput{}
	}

	output := &RestoreTableToPointInTimeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RestoreTableToPointInTimeRequest{Request: req, Input: input, Copy: c.RestoreTableToPointInTimeRequest}
}

const opScan = "Scan"

// ScanRequest is a API request type for the Scan API operation.
type ScanRequest struct {
	*aws.Request
	Input *ScanInput
	Copy  func(*ScanInput) ScanRequest
}

// Send marshals and sends the Scan API request.
func (r ScanRequest) Send(ctx context.Context) (*ScanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ScanOutput), nil
}

// ScanRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// The Scan operation returns one or more items and item attributes by accessing
// every item in a table or a secondary index. To have DynamoDB return fewer
// items, you can provide a FilterExpression operation.
//
// If the total number of scanned items exceeds the maximum data set size limit
// of 1 MB, the scan stops and results are returned to the user as a LastEvaluatedKey
// value to continue the scan in a subsequent operation. The results also include
// the number of items exceeding the limit. A scan can result in no table data
// meeting the filter criteria.
//
// A single Scan operation will read up to the maximum number of items set (if
// using the Limit parameter) or a maximum of 1 MB of data and then apply any
// filtering to the results using FilterExpression. If LastEvaluatedKey is present
// in the response, you will need to paginate the result set. For more information,
// see Paginating the Results (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.Pagination)
// in the Amazon DynamoDB Developer Guide.
//
// Scan operations proceed sequentially; however, for faster performance on
// a large table or secondary index, applications can request a parallel Scan
// operation by providing the Segment and TotalSegments parameters. For more
// information, see Parallel Scan (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.ParallelScan)
// in the Amazon DynamoDB Developer Guide.
//
// Scan uses eventually consistent reads when accessing the data in a table;
// therefore, the result set might not include the changes to data in the table
// immediately before the operation began. If you need a consistent copy of
// the data, as of the time that the Scan begins, you can set the ConsistentRead
// parameter to true.
//
//    // Example sending a request using the ScanRequest method.
//    req := client.ScanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Scan
func (c *DynamoDB) ScanRequest(input *ScanInput) ScanRequest {
	op := &aws.Operation{
		Name:       opScan,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"ExclusiveStartKey"},
			OutputTokens:    []string{"LastEvaluatedKey"},
			LimitToken:      "Limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ScanInput{}
	}

	output := &ScanOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ScanRequest{Request: req, Input: input, Copy: c.ScanRequest}
}

// Paginate pages iterates over the pages of a ScanRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a Scan operation.
//		req := client.ScanRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ScanRequest) Paginate(opts ...aws.Option) ScanPager {
	return ScanPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ScanInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ScanPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ScanPager struct {
	aws.Pager
}

func (p *ScanPager) CurrentPage() *ScanOutput {
	return p.Pager.CurrentPage().(*ScanOutput)
}

const opTagResource = "TagResource"

// TagResourceRequest is a API request type for the TagResource API operation.
type TagResourceRequest struct {
	*aws.Request
	Input *TagResourceInput
	Copy  func(*TagResourceInput) TagResourceRequest
}

// Send marshals and sends the TagResource API request.
func (r TagResourceRequest) Send(ctx context.Context) (*TagResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TagResourceOutput), nil
}

// TagResourceRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Associate a set of tags with an Amazon DynamoDB resource. You can then activate
// these user-defined tags so that they appear on the Billing and Cost Management
// console for cost allocation tracking. You can call TagResource up to 5 times
// per second, per account.
//
// For an overview on tagging DynamoDB resources, see Tagging for DynamoDB (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
// in the Amazon DynamoDB Developer Guide.
//
//    // Example sending a request using the TagResourceRequest method.
//    req := client.TagResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TagResource
func (c *DynamoDB) TagResourceRequest(input *TagResourceInput) TagResourceRequest {
	op := &aws.Operation{
		Name:       opTagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TagResourceInput{}
	}

	output := &TagResourceOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(jsonrpc.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return TagResourceRequest{Request: req, Input: input, Copy: c.TagResourceRequest}
}

const opTransactGetItems = "TransactGetItems"

// TransactGetItemsRequest is a API request type for the TransactGetItems API operation.
type TransactGetItemsRequest struct {
	*aws.Request
	Input *TransactGetItemsInput
	Copy  func(*TransactGetItemsInput) TransactGetItemsRequest
}

// Send marshals and sends the TransactGetItems API request.
func (r TransactGetItemsRequest) Send(ctx context.Context) (*TransactGetItemsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TransactGetItemsOutput), nil
}

// TransactGetItemsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// TransactGetItems is a synchronous operation that atomically retrieves multiple
// items from one or more tables (but not from indexes) in a single account
// and region. A TransactGetItems call can contain up to 10 TransactGetItem
// objects, each of which contains a Get structure that specifies an item to
// retrieve from a table in the account and region. A call to TransactGetItems
// cannot retrieve items from tables in more than one AWS account or region.
//
// DynamoDB rejects the entire TransactGetItems request if any of the following
// is true:
//
//    * A conflicting operation is in the process of updating an item to be
//    read.
//
//    * There is insufficient provisioned capacity for the transaction to be
//    completed.
//
//    * There is a user error, such as an invalid data format.
//
//    // Example sending a request using the TransactGetItemsRequest method.
//    req := client.TransactGetItemsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactGetItems
func (c *DynamoDB) TransactGetItemsRequest(input *TransactGetItemsInput) TransactGetItemsRequest {
	op := &aws.Operation{
		Name:       opTransactGetItems,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TransactGetItemsInput{}
	}

	output := &TransactGetItemsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TransactGetItemsRequest{Request: req, Input: input, Copy: c.TransactGetItemsRequest}
}

const opTransactWriteItems = "TransactWriteItems"

// TransactWriteItemsRequest is a API request type for the TransactWriteItems API operation.
type TransactWriteItemsRequest struct {
	*aws.Request
	Input *TransactWriteItemsInput
	Copy  func(*TransactWriteItemsInput) TransactWriteItemsRequest
}

// Send marshals and sends the TransactWriteItems API request.
func (r TransactWriteItemsRequest) Send(ctx context.Context) (*TransactWriteItemsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TransactWriteItemsOutput), nil
}

// TransactWriteItemsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// TransactWriteItems is a synchronous write operation that groups up to 10
// action requests. These actions can target items in different tables, but
// not in different AWS accounts or regions, and no two actions can target the
// same item. For example, you cannot both ConditionCheck and Update the same
// item.
//
// The actions are completed atomically so that either all of them succeed,
// or all of them fail. They are defined by the following objects:
//
//    * Put   Initiates a PutItem operation to write a new item. This structure
//    specifies the primary key of the item to be written, the name of the table
//    to write it in, an optional condition expression that must be satisfied
//    for the write to succeed, a list of the item's attributes, and a field
//    indicating whether or not to retrieve the item's attributes if the condition
//    is not met.
//
//    * Update   Initiates an UpdateItem operation to update an existing
//    item. This structure specifies the primary key of the item to be updated,
//    the name of the table where it resides, an optional condition expression
//    that must be satisfied for the update to succeed, an expression that defines
//    one or more attributes to be updated, and a field indicating whether or
//    not to retrieve the item's attributes if the condition is not met.
//
//    * Delete   Initiates a DeleteItem operation to delete an existing item.
//    This structure specifies the primary key of the item to be deleted, the
//    name of the table where it resides, an optional condition expression that
//    must be satisfied for the deletion to succeed, and a field indicating
//    whether or not to retrieve the item's attributes if the condition is not
//    met.
//
//    * ConditionCheck   Applies a condition to an item that is not being
//    modified by the transaction. This structure specifies the primary key
//    of the item to be checked, the name of the table where it resides, a condition
//    expression that must be satisfied for the transaction to succeed, and
//    a field indicating whether or not to retrieve the item's attributes if
//    the condition is not met.
//
// DynamoDB rejects the entire TransactWriteItems request if any of the following
// is true:
//
//    * A condition in one of the condition expressions is not met.
//
//    * A conflicting operation is in the process of updating the same item.
//
//    * There is insufficient provisioned capacity for the transaction to be
//    completed.
//
//    * An item size becomes too large (bigger than 400 KB), a Local Secondary
//    Index (LSI) becomes too large, or a similar validation error occurs because
//    of changes made by the transaction.
//
//    * There is a user error, such as an invalid data format.
//
//    // Example sending a request using the TransactWriteItemsRequest method.
//    req := client.TransactWriteItemsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactWriteItems
func (c *DynamoDB) TransactWriteItemsRequest(input *TransactWriteItemsInput) TransactWriteItemsRequest {
	op := &aws.Operation{
		Name:       opTransactWriteItems,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TransactWriteItemsInput{}
	}

	output := &TransactWriteItemsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TransactWriteItemsRequest{Request: req, Input: input, Copy: c.TransactWriteItemsRequest}
}

const opUntagResource = "UntagResource"

// UntagResourceRequest is a API request type for the UntagResource API operation.
type UntagResourceRequest struct {
	*aws.Request
	Input *UntagResourceInput
	Copy  func(*UntagResourceInput) UntagResourceRequest
}

// Send marshals and sends the UntagResource API request.
func (r UntagResourceRequest) Send(ctx context.Context) (*UntagResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UntagResourceOutput), nil
}

// UntagResourceRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Removes the association of tags from an Amazon DynamoDB resource. You can
// call UntagResource up to 5 times per second, per account.
//
// For an overview on tagging DynamoDB resources, see Tagging for DynamoDB (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
// in the Amazon DynamoDB Developer Guide.
//
//    // Example sending a request using the UntagResourceRequest method.
//    req := client.UntagResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UntagResource
func (c *DynamoDB) UntagResourceRequest(input *UntagResourceInput) UntagResourceRequest {
	op := &aws.Operation{
		Name:       opUntagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UntagResourceInput{}
	}

	output := &UntagResourceOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(jsonrpc.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return UntagResourceRequest{Request: req, Input: input, Copy: c.UntagResourceRequest}
}

const opUpdateContinuousBackups = "UpdateContinuousBackups"

// UpdateContinuousBackupsRequest is a API request type for the UpdateContinuousBackups API operation.
type UpdateContinuousBackupsRequest struct {
	*aws.Request
	Input *UpdateContinuousBackupsInput
	Copy  func(*UpdateContinuousBackupsInput) UpdateContinuousBackupsRequest
}

// Send marshals and sends the UpdateContinuousBackups API request.
func (r UpdateContinuousBackupsRequest) Send(ctx context.Context) (*UpdateContinuousBackupsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateContinuousBackupsOutput), nil
}

// UpdateContinuousBackupsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// UpdateContinuousBackups enables or disables point in time recovery for the
// specified table. A successful UpdateContinuousBackups call returns the current
// ContinuousBackupsDescription. Continuous backups are ENABLED on all tables
// at table creation. If point in time recovery is enabled, PointInTimeRecoveryStatus
// will be set to ENABLED.
//
// Once continuous backups and point in time recovery are enabled, you can restore
// to any point in time within EarliestRestorableDateTime and LatestRestorableDateTime.
//
// LatestRestorableDateTime is typically 5 minutes before the current time.
// You can restore your table to any point in time during the last 35 days..
//
//    // Example sending a request using the UpdateContinuousBackupsRequest method.
//    req := client.UpdateContinuousBackupsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateContinuousBackups
func (c *DynamoDB) UpdateContinuousBackupsRequest(input *UpdateContinuousBackupsInput) UpdateContinuousBackupsRequest {
	op := &aws.Operation{
		Name:       opUpdateContinuousBackups,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateContinuousBackupsInput{}
	}

	output := &UpdateContinuousBackupsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateContinuousBackupsRequest{Request: req, Input: input, Copy: c.UpdateContinuousBackupsRequest}
}

const opUpdateGlobalTable = "UpdateGlobalTable"

// UpdateGlobalTableRequest is a API request type for the UpdateGlobalTable API operation.
type UpdateGlobalTableRequest struct {
	*aws.Request
	Input *UpdateGlobalTableInput
	Copy  func(*UpdateGlobalTableInput) UpdateGlobalTableRequest
}

// Send marshals and sends the UpdateGlobalTable API request.
func (r UpdateGlobalTableRequest) Send(ctx context.Context) (*UpdateGlobalTableOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGlobalTableOutput), nil
}

// UpdateGlobalTableRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Adds or removes replicas in the specified global table. The global table
// must already exist to be able to use this operation. Any replica to be added
// must be empty, must have the same name as the global table, must have the
// same key schema, and must have DynamoDB Streams enabled and must have same
// provisioned and maximum write capacity units.
//
// Although you can use UpdateGlobalTable to add replicas and remove replicas
// in a single request, for simplicity we recommend that you issue separate
// requests for adding or removing replicas.
//
// If global secondary indexes are specified, then the following conditions
// must also be met:
//
//    *  The global secondary indexes must have the same name.
//
//    *  The global secondary indexes must have the same hash key and sort key
//    (if present).
//
//    *  The global secondary indexes must have the same provisioned and maximum
//    write capacity units.
//
//    // Example sending a request using the UpdateGlobalTableRequest method.
//    req := client.UpdateGlobalTableRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTable
func (c *DynamoDB) UpdateGlobalTableRequest(input *UpdateGlobalTableInput) UpdateGlobalTableRequest {
	op := &aws.Operation{
		Name:       opUpdateGlobalTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateGlobalTableInput{}
	}

	output := &UpdateGlobalTableOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateGlobalTableRequest{Request: req, Input: input, Copy: c.UpdateGlobalTableRequest}
}

const opUpdateGlobalTableSettings = "UpdateGlobalTableSettings"

// UpdateGlobalTableSettingsRequest is a API request type for the UpdateGlobalTableSettings API operation.
type UpdateGlobalTableSettingsRequest struct {
	*aws.Request
	Input *UpdateGlobalTableSettingsInput
	Copy  func(*UpdateGlobalTableSettingsInput) UpdateGlobalTableSettingsRequest
}

// Send marshals and sends the UpdateGlobalTableSettings API request.
func (r UpdateGlobalTableSettingsRequest) Send(ctx context.Context) (*UpdateGlobalTableSettingsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGlobalTableSettingsOutput), nil
}

// UpdateGlobalTableSettingsRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Updates settings for a global table.
//
//    // Example sending a request using the UpdateGlobalTableSettingsRequest method.
//    req := client.UpdateGlobalTableSettingsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTableSettings
func (c *DynamoDB) UpdateGlobalTableSettingsRequest(input *UpdateGlobalTableSettingsInput) UpdateGlobalTableSettingsRequest {
	op := &aws.Operation{
		Name:       opUpdateGlobalTableSettings,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateGlobalTableSettingsInput{}
	}

	output := &UpdateGlobalTableSettingsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateGlobalTableSettingsRequest{Request: req, Input: input, Copy: c.UpdateGlobalTableSettingsRequest}
}

const opUpdateItem = "UpdateItem"

// UpdateItemRequest is a API request type for the UpdateItem API operation.
type UpdateItemRequest struct {
	*aws.Request
	Input *UpdateItemInput
	Copy  func(*UpdateItemInput) UpdateItemRequest
}

// Send marshals and sends the UpdateItem API request.
func (r UpdateItemRequest) Send(ctx context.Context) (*UpdateItemOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateItemOutput), nil
}

// UpdateItemRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Edits an existing item's attributes, or adds a new item to the table if it
// does not already exist. You can put, delete, or add attribute values. You
// can also perform a conditional update on an existing item (insert a new attribute
// name-value pair if it doesn't exist, or replace an existing name-value pair
// if it has certain expected attribute values).
//
// You can also return the item's attribute values in the same UpdateItem operation
// using the ReturnValues parameter.
//
//    // Example sending a request using the UpdateItemRequest method.
//    req := client.UpdateItemRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateItem
func (c *DynamoDB) UpdateItemRequest(input *UpdateItemInput) UpdateItemRequest {
	op := &aws.Operation{
		Name:       opUpdateItem,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateItemInput{}
	}

	output := &UpdateItemOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateItemRequest{Request: req, Input: input, Copy: c.UpdateItemRequest}
}

const opUpdateTable = "UpdateTable"

// UpdateTableRequest is a API request type for the UpdateTable API operation.
type UpdateTableRequest struct {
	*aws.Request
	Input *UpdateTableInput
	Copy  func(*UpdateTableInput) UpdateTableRequest
}

// Send marshals and sends the UpdateTable API request.
func (r UpdateTableRequest) Send(ctx context.Context) (*UpdateTableOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateTableOutput), nil
}

// UpdateTableRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// Modifies the provisioned throughput settings, global secondary indexes, or
// DynamoDB Streams settings for a given table.
//
// You can only perform one of the following operations at once:
//
//    * Modify the provisioned throughput settings of the table.
//
//    * Enable or disable Streams on the table.
//
//    * Remove a global secondary index from the table.
//
//    * Create a new global secondary index on the table. Once the index begins
//    backfilling, you can use UpdateTable to perform other operations.
//
// UpdateTable is an asynchronous operation; while it is executing, the table
// status changes from ACTIVE to UPDATING. While it is UPDATING, you cannot
// issue another UpdateTable request. When the table returns to the ACTIVE state,
// the UpdateTable operation is complete.
//
//    // Example sending a request using the UpdateTableRequest method.
//    req := client.UpdateTableRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTable
func (c *DynamoDB) UpdateTableRequest(input *UpdateTableInput) UpdateTableRequest {
	op := &aws.Operation{
		Name:       opUpdateTable,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateTableInput{}
	}

	output := &UpdateTableOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateTableRequest{Request: req, Input: input, Copy: c.UpdateTableRequest}
}

const opUpdateTimeToLive = "UpdateTimeToLive"

// UpdateTimeToLiveRequest is a API request type for the UpdateTimeToLive API operation.
type UpdateTimeToLiveRequest struct {
	*aws.Request
	Input *UpdateTimeToLiveInput
	Copy  func(*UpdateTimeToLiveInput) UpdateTimeToLiveRequest
}

// Send marshals and sends the UpdateTimeToLive API request.
func (r UpdateTimeToLiveRequest) Send(ctx context.Context) (*UpdateTimeToLiveOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateTimeToLiveOutput), nil
}

// UpdateTimeToLiveRequest returns a request value for making API operation for
// Amazon DynamoDB.
//
// The UpdateTimeToLive method will enable or disable TTL for the specified
// table. A successful UpdateTimeToLive call returns the current TimeToLiveSpecification;
// it may take up to one hour for the change to fully process. Any additional
// UpdateTimeToLive calls for the same table during this one hour duration result
// in a ValidationException.
//
// TTL compares the current time in epoch time format to the time stored in
// the TTL attribute of an item. If the epoch time value stored in the attribute
// is less than the current time, the item is marked as expired and subsequently
// deleted.
//
// The epoch time format is the number of seconds elapsed since 12:00:00 AM
// January 1st, 1970 UTC.
//
// DynamoDB deletes expired items on a best-effort basis to ensure availability
// of throughput for other data operations.
//
// DynamoDB typically deletes expired items within two days of expiration. The
// exact duration within which an item gets deleted after expiration is specific
// to the nature of the workload. Items that have expired and not been deleted
// will still show up in reads, queries, and scans.
//
// As items are deleted, they are removed from any Local Secondary Index and
// Global Secondary Index immediately in the same eventually consistent way
// as a standard delete operation.
//
// For more information, see Time To Live (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html)
// in the Amazon DynamoDB Developer Guide.
//
//    // Example sending a request using the UpdateTimeToLiveRequest method.
//    req := client.UpdateTimeToLiveRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTimeToLive
func (c *DynamoDB) UpdateTimeToLiveRequest(input *UpdateTimeToLiveInput) UpdateTimeToLiveRequest {
	op := &aws.Operation{
		Name:       opUpdateTimeToLive,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateTimeToLiveInput{}
	}

	output := &UpdateTimeToLiveOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateTimeToLiveRequest{Request: req, Input: input, Copy: c.UpdateTimeToLiveRequest}
}

// Represents an attribute for describing the key schema for the table and indexes.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AttributeDefinition
type AttributeDefinition struct {
	_ struct{} `type:"structure"`

	// A name for the attribute.
	//
	// AttributeName is a required field
	AttributeName *string `min:"1" type:"string" required:"true"`

	// The data type for the attribute, where:
	//
	//    * S - the attribute is of type String
	//
	//    * N - the attribute is of type Number
	//
	//    * B - the attribute is of type Binary
	//
	// AttributeType is a required field
	AttributeType ScalarAttributeType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s AttributeDefinition) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeDefinition) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AttributeDefinition) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AttributeDefinition"}

	if s.AttributeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeName"))
	}
	if s.AttributeName != nil && len(*s.AttributeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributeName", 1))
	}
	if len(s.AttributeType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("AttributeType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the data for an attribute.
//
// Each attribute value is described as a name-value pair. The name is the data
// type, and the value is the data itself.
//
// For more information, see Data Types (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes)
// in the Amazon DynamoDB Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AttributeValue
type AttributeValue struct {
	_ struct{} `type:"structure"`

	// An attribute of type Binary. For example:
	//
	// "B": "dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk"
	//
	// B is automatically base64 encoded/decoded by the SDK.
	B []byte `type:"blob"`

	// An attribute of type Boolean. For example:
	//
	// "BOOL": true
	BOOL *bool `type:"boolean"`

	// An attribute of type Binary Set. For example:
	//
	// "BS": ["U3Vubnk=", "UmFpbnk=", "U25vd3k="]
	BS [][]byte `type:"list"`

	// An attribute of type List. For example:
	//
	// "L": ["Cookies", "Coffee", 3.14159]
	L []AttributeValue `type:"list"`

	// An attribute of type Map. For example:
	//
	// "M": {"Name": {"S": "Joe"}, "Age": {"N": "35"}}
	M map[string]AttributeValue `type:"map"`

	// An attribute of type Number. For example:
	//
	// "N": "123.45"
	//
	// Numbers are sent across the network to DynamoDB as strings, to maximize compatibility
	// across languages and libraries. However, DynamoDB treats them as number type
	// attributes for mathematical operations.
	N *string `type:"string"`

	// An attribute of type Number Set. For example:
	//
	// "NS": ["42.2", "-19", "7.5", "3.14"]
	//
	// Numbers are sent across the network to DynamoDB as strings, to maximize compatibility
	// across languages and libraries. However, DynamoDB treats them as number type
	// attributes for mathematical operations.
	NS []string `type:"list"`

	// An attribute of type Null. For example:
	//
	// "NULL": true
	NULL *bool `type:"boolean"`

	// An attribute of type String. For example:
	//
	// "S": "Hello"
	S *string `type:"string"`

	// An attribute of type String Set. For example:
	//
	// "SS": ["Giraffe", "Hippo" ,"Zebra"]
	SS []string `type:"list"`
}

// String returns the string representation
func (s AttributeValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeValue) GoString() string {
	return s.String()
}

// For the UpdateItem operation, represents the attributes to be modified, the
// action to perform on each, and the new value for each.
//
// You cannot use UpdateItem to update any primary key attributes. Instead,
// you will need to delete the item, and then use PutItem to create a new item
// with new attributes.
//
// Attribute values cannot be null; string and binary type attributes must have
// lengths greater than zero; and set type attributes must not be empty. Requests
// with empty values will be rejected with a ValidationException exception.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AttributeValueUpdate
type AttributeValueUpdate struct {
	_ struct{} `type:"structure"`

	// Specifies how to perform the update. Valid values are PUT (default), DELETE,
	// and ADD. The behavior depends on whether the specified primary key already
	// exists in the table.
	//
	// If an item with the specified Key is found in the table:
	//
	//    * PUT - Adds the specified attribute to the item. If the attribute already
	//    exists, it is replaced by the new value.
	//
	//    * DELETE - If no value is specified, the attribute and its value are removed
	//    from the item. The data type of the specified value must match the existing
	//    value's data type.
	//
	// If a set of values is specified, then those values are subtracted from the
	//    old set. For example, if the attribute value was the set [a,b,c] and the
	//    DELETE action specified [a,c], then the final attribute value would be
	//    [b]. Specifying an empty set is an error.
	//
	//    * ADD - If the attribute does not already exist, then the attribute and
	//    its values are added to the item. If the attribute does exist, then the
	//    behavior of ADD depends on the data type of the attribute:
	//
	// If the existing attribute is a number, and if Value is also a number, then
	//    the Value is mathematically added to the existing attribute. If Value
	//    is a negative number, then it is subtracted from the existing attribute.
	//
	//  If you use ADD to increment or decrement a number value for an item that
	//    doesn't exist before the update, DynamoDB uses 0 as the initial value.
	//
	// In addition, if you use ADD to update an existing item, and intend to increment
	//    or decrement an attribute value which does not yet exist, DynamoDB uses
	//    0 as the initial value. For example, suppose that the item you want to
	//    update does not yet have an attribute named itemcount, but you decide
	//    to ADD the number 3 to this attribute anyway, even though it currently
	//    does not exist. DynamoDB will create the itemcount attribute, set its
	//    initial value to 0, and finally add 3 to it. The result will be a new
	//    itemcount attribute in the item, with a value of 3.
	//
	// If the existing data type is a set, and if the Value is also a set, then
	//    the Value is added to the existing set. (This is a set operation, not
	//    mathematical addition.) For example, if the attribute value was the set
	//    [1,2], and the ADD action specified [3], then the final attribute value
	//    would be [1,2,3]. An error occurs if an Add action is specified for a
	//    set attribute and the attribute type specified does not match the existing
	//    set type.
	//
	// Both sets must have the same primitive data type. For example, if the existing
	//    data type is a set of strings, the Value must also be a set of strings.
	//    The same holds true for number sets and binary sets.
	//
	// This action is only valid for an existing attribute whose data type is number
	//    or is a set. Do not use ADD for any other data types.
	//
	// If no item with the specified Key is found:
	//
	//    * PUT - DynamoDB creates a new item with the specified primary key, and
	//    then adds the attribute.
	//
	//    * DELETE - Nothing happens; there is no attribute to delete.
	//
	//    * ADD - DynamoDB creates an item with the supplied primary key and number
	//    (or set of numbers) for the attribute value. The only data types allowed
	//    are number and number set; no other data types can be specified.
	Action AttributeAction `type:"string" enum:"true"`

	// Represents the data for an attribute.
	//
	// Each attribute value is described as a name-value pair. The name is the data
	// type, and the value is the data itself.
	//
	// For more information, see Data Types (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes)
	// in the Amazon DynamoDB Developer Guide.
	Value *AttributeValue `type:"structure"`
}

// String returns the string representation
func (s AttributeValueUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AttributeValueUpdate) GoString() string {
	return s.String()
}

// Represents the properties of the scaling policy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AutoScalingPolicyDescription
type AutoScalingPolicyDescription struct {
	_ struct{} `type:"structure"`

	// The name of the scaling policy.
	PolicyName *string `min:"1" type:"string"`

	// Represents a target tracking scaling policy configuration.
	TargetTrackingScalingPolicyConfiguration *AutoScalingTargetTrackingScalingPolicyConfigurationDescription `type:"structure"`
}

// String returns the string representation
func (s AutoScalingPolicyDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingPolicyDescription) GoString() string {
	return s.String()
}

// Represents the autoscaling policy to be modified.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AutoScalingPolicyUpdate
type AutoScalingPolicyUpdate struct {
	_ struct{} `type:"structure"`

	// The name of the scaling policy.
	PolicyName *string `min:"1" type:"string"`

	// Represents a target tracking scaling policy configuration.
	//
	// TargetTrackingScalingPolicyConfiguration is a required field
	TargetTrackingScalingPolicyConfiguration *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate `type:"structure" required:"true"`
}

// String returns the string representation
func (s AutoScalingPolicyUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingPolicyUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AutoScalingPolicyUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AutoScalingPolicyUpdate"}
	if s.PolicyName != nil && len(*s.PolicyName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("PolicyName", 1))
	}

	if s.TargetTrackingScalingPolicyConfiguration == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetTrackingScalingPolicyConfiguration"))
	}
	if s.TargetTrackingScalingPolicyConfiguration != nil {
		if err := s.TargetTrackingScalingPolicyConfiguration.Validate(); err != nil {
			invalidParams.AddNested("TargetTrackingScalingPolicyConfiguration", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the autoscaling settings for a global table or global secondary
// index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AutoScalingSettingsDescription
type AutoScalingSettingsDescription struct {
	_ struct{} `type:"structure"`

	// Disabled autoscaling for this global table or global secondary index.
	AutoScalingDisabled *bool `type:"boolean"`

	// Role ARN used for configuring autoScaling policy.
	AutoScalingRoleArn *string `type:"string"`

	// The maximum capacity units that a global table or global secondary index
	// should be scaled up to.
	MaximumUnits *int64 `min:"1" type:"long"`

	// The minimum capacity units that a global table or global secondary index
	// should be scaled down to.
	MinimumUnits *int64 `min:"1" type:"long"`

	// Information about the scaling policies.
	ScalingPolicies []AutoScalingPolicyDescription `type:"list"`
}

// String returns the string representation
func (s AutoScalingSettingsDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingSettingsDescription) GoString() string {
	return s.String()
}

// Represents the autoscaling settings to be modified for a global table or
// global secondary index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AutoScalingSettingsUpdate
type AutoScalingSettingsUpdate struct {
	_ struct{} `type:"structure"`

	// Disabled autoscaling for this global table or global secondary index.
	AutoScalingDisabled *bool `type:"boolean"`

	// Role ARN used for configuring autoscaling policy.
	AutoScalingRoleArn *string `min:"1" type:"string"`

	// The maximum capacity units that a global table or global secondary index
	// should be scaled up to.
	MaximumUnits *int64 `min:"1" type:"long"`

	// The minimum capacity units that a global table or global secondary index
	// should be scaled down to.
	MinimumUnits *int64 `min:"1" type:"long"`

	// The scaling policy to apply for scaling target global table or global secondary
	// index capacity units.
	ScalingPolicyUpdate *AutoScalingPolicyUpdate `type:"structure"`
}

// String returns the string representation
func (s AutoScalingSettingsUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingSettingsUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AutoScalingSettingsUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AutoScalingSettingsUpdate"}
	if s.AutoScalingRoleArn != nil && len(*s.AutoScalingRoleArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AutoScalingRoleArn", 1))
	}
	if s.MaximumUnits != nil && *s.MaximumUnits < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaximumUnits", 1))
	}
	if s.MinimumUnits != nil && *s.MinimumUnits < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MinimumUnits", 1))
	}
	if s.ScalingPolicyUpdate != nil {
		if err := s.ScalingPolicyUpdate.Validate(); err != nil {
			invalidParams.AddNested("ScalingPolicyUpdate", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the properties of a target tracking scaling policy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AutoScalingTargetTrackingScalingPolicyConfigurationDescription
type AutoScalingTargetTrackingScalingPolicyConfigurationDescription struct {
	_ struct{} `type:"structure"`

	// Indicates whether scale in by the target tracking policy is disabled. If
	// the value is true, scale in is disabled and the target tracking policy won't
	// remove capacity from the scalable resource. Otherwise, scale in is enabled
	// and the target tracking policy can remove capacity from the scalable resource.
	// The default value is false.
	DisableScaleIn *bool `type:"boolean"`

	// The amount of time, in seconds, after a scale in activity completes before
	// another scale in activity can start. The cooldown period is used to block
	// subsequent scale in requests until it has expired. You should scale in conservatively
	// to protect your application's availability. However, if another alarm triggers
	// a scale out policy during the cooldown period after a scale-in, application
	// autoscaling scales out your scalable target immediately.
	ScaleInCooldown *int64 `type:"integer"`

	// The amount of time, in seconds, after a scale out activity completes before
	// another scale out activity can start. While the cooldown period is in effect,
	// the capacity that has been added by the previous scale out event that initiated
	// the cooldown is calculated as part of the desired capacity for the next scale
	// out. You should continuously (but not excessively) scale out.
	ScaleOutCooldown *int64 `type:"integer"`

	// The target value for the metric. The range is 8.515920e-109 to 1.174271e+108
	// (Base 10) or 2e-360 to 2e360 (Base 2).
	//
	// TargetValue is a required field
	TargetValue *float64 `type:"double" required:"true"`
}

// String returns the string representation
func (s AutoScalingTargetTrackingScalingPolicyConfigurationDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingTargetTrackingScalingPolicyConfigurationDescription) GoString() string {
	return s.String()
}

// Represents the settings of a target tracking scaling policy that will be
// modified.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/AutoScalingTargetTrackingScalingPolicyConfigurationUpdate
type AutoScalingTargetTrackingScalingPolicyConfigurationUpdate struct {
	_ struct{} `type:"structure"`

	// Indicates whether scale in by the target tracking policy is disabled. If
	// the value is true, scale in is disabled and the target tracking policy won't
	// remove capacity from the scalable resource. Otherwise, scale in is enabled
	// and the target tracking policy can remove capacity from the scalable resource.
	// The default value is false.
	DisableScaleIn *bool `type:"boolean"`

	// The amount of time, in seconds, after a scale in activity completes before
	// another scale in activity can start. The cooldown period is used to block
	// subsequent scale in requests until it has expired. You should scale in conservatively
	// to protect your application's availability. However, if another alarm triggers
	// a scale out policy during the cooldown period after a scale-in, application
	// autoscaling scales out your scalable target immediately.
	ScaleInCooldown *int64 `type:"integer"`

	// The amount of time, in seconds, after a scale out activity completes before
	// another scale out activity can start. While the cooldown period is in effect,
	// the capacity that has been added by the previous scale out event that initiated
	// the cooldown is calculated as part of the desired capacity for the next scale
	// out. You should continuously (but not excessively) scale out.
	ScaleOutCooldown *int64 `type:"integer"`

	// The target value for the metric. The range is 8.515920e-109 to 1.174271e+108
	// (Base 10) or 2e-360 to 2e360 (Base 2).
	//
	// TargetValue is a required field
	TargetValue *float64 `type:"double" required:"true"`
}

// String returns the string representation
func (s AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AutoScalingTargetTrackingScalingPolicyConfigurationUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AutoScalingTargetTrackingScalingPolicyConfigurationUpdate"}

	if s.TargetValue == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetValue"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Contains the description of the backup created for the table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BackupDescription
type BackupDescription struct {
	_ struct{} `type:"structure"`

	// Contains the details of the backup created for the table.
	BackupDetails *BackupDetails `type:"structure"`

	// Contains the details of the table when the backup was created.
	SourceTableDetails *SourceTableDetails `type:"structure"`

	// Contains the details of the features enabled on the table when the backup
	// was created. For example, LSIs, GSIs, streams, TTL.
	SourceTableFeatureDetails *SourceTableFeatureDetails `type:"structure"`
}

// String returns the string representation
func (s BackupDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BackupDescription) GoString() string {
	return s.String()
}

// Contains the details of the backup created for the table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BackupDetails
type BackupDetails struct {
	_ struct{} `type:"structure"`

	// ARN associated with the backup.
	//
	// BackupArn is a required field
	BackupArn *string `min:"37" type:"string" required:"true"`

	// Time at which the backup was created. This is the request time of the backup.
	//
	// BackupCreationDateTime is a required field
	BackupCreationDateTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Time at which the automatic on-demand backup created by DynamoDB will expire.
	// This SYSTEM on-demand backup expires automatically 35 days after its creation.
	BackupExpiryDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Name of the requested backup.
	//
	// BackupName is a required field
	BackupName *string `min:"3" type:"string" required:"true"`

	// Size of the backup in bytes.
	BackupSizeBytes *int64 `type:"long"`

	// Backup can be in one of the following states: CREATING, ACTIVE, DELETED.
	//
	// BackupStatus is a required field
	BackupStatus BackupStatus `type:"string" required:"true" enum:"true"`

	// BackupType:
	//
	//    * USER - You create and manage these using the on-demand backup feature.
	//
	//    * SYSTEM - If you delete a table with point-in-time recovery enabled,
	//    a SYSTEM backup is automatically created and is retained for 35 days (at
	//    no additional cost). System backups allow you to restore the deleted table
	//    to the state it was in just before the point of deletion.
	//
	// BackupType is a required field
	BackupType BackupType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s BackupDetails) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BackupDetails) GoString() string {
	return s.String()
}

// Contains details for the backup.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BackupSummary
type BackupSummary struct {
	_ struct{} `type:"structure"`

	// ARN associated with the backup.
	BackupArn *string `min:"37" type:"string"`

	// Time at which the backup was created.
	BackupCreationDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Time at which the automatic on-demand backup created by DynamoDB will expire.
	// This SYSTEM on-demand backup expires automatically 35 days after its creation.
	BackupExpiryDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Name of the specified backup.
	BackupName *string `min:"3" type:"string"`

	// Size of the backup in bytes.
	BackupSizeBytes *int64 `type:"long"`

	// Backup can be in one of the following states: CREATING, ACTIVE, DELETED.
	BackupStatus BackupStatus `type:"string" enum:"true"`

	// BackupType:
	//
	//    * USER - You create and manage these using the on-demand backup feature.
	//
	//    * SYSTEM - If you delete a table with point-in-time recovery enabled,
	//    a SYSTEM backup is automatically created and is retained for 35 days (at
	//    no additional cost). System backups allow you to restore the deleted table
	//    to the state it was in just before the point of deletion.
	BackupType BackupType `type:"string" enum:"true"`

	// ARN associated with the table.
	TableArn *string `type:"string"`

	// Unique identifier for the table.
	TableId *string `type:"string"`

	// Name of the table.
	TableName *string `min:"3" type:"string"`
}

// String returns the string representation
func (s BackupSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BackupSummary) GoString() string {
	return s.String()
}

// Represents the input of a BatchGetItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchGetItemInput
type BatchGetItemInput struct {
	_ struct{} `type:"structure"`

	// A map of one or more table names and, for each table, a map that describes
	// one or more items to retrieve from that table. Each table name can be used
	// only once per BatchGetItem request.
	//
	// Each element in the map of items to retrieve consists of the following:
	//
	//    * ConsistentRead - If true, a strongly consistent read is used; if false
	//    (the default), an eventually consistent read is used.
	//
	//    * ExpressionAttributeNames - One or more substitution tokens for attribute
	//    names in the ProjectionExpression parameter. The following are some use
	//    cases for using ExpressionAttributeNames:
	//
	// To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	// To create a placeholder for repeating occurrences of an attribute name in
	//    an expression.
	//
	// To prevent special characters in an attribute name from being misinterpreted
	//    in an expression.
	//
	// Use the # character in an expression to dereference an attribute name. For
	//    example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot be
	//    used directly in an expression. (For the complete list of reserved words,
	//    see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	//    in the Amazon DynamoDB Developer Guide). To work around this, you could
	//    specify the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	// Tokens that begin with the : character are expression attribute values, which
	//    are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	//    (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	//    in the Amazon DynamoDB Developer Guide.
	//
	//    * Keys - An array of primary key attribute values that define specific
	//    items in the table. For each primary key, you must provide all of the
	//    key attributes. For example, with a simple primary key, you only need
	//    to provide the partition key value. For a composite key, you must provide
	//    both the partition key value and the sort key value.
	//
	//    * ProjectionExpression - A string that identifies one or more attributes
	//    to retrieve from the table. These attributes can include scalars, sets,
	//    or elements of a JSON document. The attributes in the expression must
	//    be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	//    If any of the requested attributes are not found, they will not appear
	//    in the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	//    in the Amazon DynamoDB Developer Guide.
	//
	//    * AttributesToGet - This is a legacy parameter. Use ProjectionExpression
	//    instead. For more information, see AttributesToGet (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
	//    in the Amazon DynamoDB Developer Guide.
	//
	// RequestItems is a required field
	RequestItems map[string]KeysAndAttributes `min:"1" type:"map" required:"true"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`
}

// String returns the string representation
func (s BatchGetItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetItemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchGetItemInput"}

	if s.RequestItems == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestItems"))
	}
	if s.RequestItems != nil && len(s.RequestItems) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RequestItems", 1))
	}
	if s.RequestItems != nil {
		for i, v := range s.RequestItems {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "RequestItems", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a BatchGetItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchGetItemOutput
type BatchGetItemOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The read capacity units consumed by the entire BatchGetItem operation.
	//
	// Each element consists of:
	//
	//    * TableName - The table that consumed the provisioned throughput.
	//
	//    * CapacityUnits - The total number of capacity units consumed.
	ConsumedCapacity []ConsumedCapacity `type:"list"`

	// A map of table name to a list of items. Each object in Responses consists
	// of a table name, along with a map of attribute data consisting of the data
	// type and attribute value.
	Responses map[string][]map[string]AttributeValue `type:"map"`

	// A map of tables and their respective keys that were not processed with the
	// current response. The UnprocessedKeys value is in the same form as RequestItems,
	// so the value can be provided directly to a subsequent BatchGetItem operation.
	// For more information, see RequestItems in the Request Parameters section.
	//
	// Each element consists of:
	//
	//    * Keys - An array of primary key attribute values that define specific
	//    items in the table.
	//
	//    * ProjectionExpression - One or more attributes to be retrieved from the
	//    table or index. By default, all attributes are returned. If a requested
	//    attribute is not found, it does not appear in the result.
	//
	//    * ConsistentRead - The consistency of a read operation. If set to true,
	//    then a strongly consistent read is used; otherwise, an eventually consistent
	//    read is used.
	//
	// If there are no unprocessed keys remaining, the response contains an empty
	// UnprocessedKeys map.
	UnprocessedKeys map[string]KeysAndAttributes `min:"1" type:"map"`
}

// String returns the string representation
func (s BatchGetItemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetItemOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s BatchGetItemOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input of a BatchWriteItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchWriteItemInput
type BatchWriteItemInput struct {
	_ struct{} `type:"structure"`

	// A map of one or more table names and, for each table, a list of operations
	// to be performed (DeleteRequest or PutRequest). Each element in the map consists
	// of the following:
	//
	//    * DeleteRequest - Perform a DeleteItem operation on the specified item.
	//    The item to be deleted is identified by a Key subelement:
	//
	// Key - A map of primary key attribute values that uniquely identify the item.
	//    Each entry in this map consists of an attribute name and an attribute
	//    value. For each primary key, you must provide all of the key attributes.
	//    For example, with a simple primary key, you only need to provide a value
	//    for the partition key. For a composite primary key, you must provide values
	//    for both the partition key and the sort key.
	//
	//    * PutRequest - Perform a PutItem operation on the specified item. The
	//    item to be put is identified by an Item subelement:
	//
	// Item - A map of attributes and their values. Each entry in this map consists
	//    of an attribute name and an attribute value. Attribute values must not
	//    be null; string and binary type attributes must have lengths greater than
	//    zero; and set type attributes must not be empty. Requests that contain
	//    empty values will be rejected with a ValidationException exception.
	//
	// If you specify any attributes that are part of an index key, then the data
	//    types for those attributes must match those of the schema in the table's
	//    attribute definition.
	//
	// RequestItems is a required field
	RequestItems map[string][]WriteRequest `min:"1" type:"map" required:"true"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// Determines whether item collection metrics are returned. If set to SIZE,
	// the response includes statistics about item collections, if any, that were
	// modified during the operation are returned in the response. If set to NONE
	// (the default), no statistics are returned.
	ReturnItemCollectionMetrics ReturnItemCollectionMetrics `type:"string" enum:"true"`
}

// String returns the string representation
func (s BatchWriteItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchWriteItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchWriteItemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "BatchWriteItemInput"}

	if s.RequestItems == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestItems"))
	}
	if s.RequestItems != nil && len(s.RequestItems) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RequestItems", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a BatchWriteItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BatchWriteItemOutput
type BatchWriteItemOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The capacity units consumed by the entire BatchWriteItem operation.
	//
	// Each element consists of:
	//
	//    * TableName - The table that consumed the provisioned throughput.
	//
	//    * CapacityUnits - The total number of capacity units consumed.
	ConsumedCapacity []ConsumedCapacity `type:"list"`

	// A list of tables that were processed by BatchWriteItem and, for each table,
	// information about any item collections that were affected by individual DeleteItem
	// or PutItem operations.
	//
	// Each entry consists of the following subelements:
	//
	//    * ItemCollectionKey - The partition key value of the item collection.
	//    This is the same as the partition key value of the item.
	//
	//    * SizeEstimateRangeGB - An estimate of item collection size, expressed
	//    in GB. This is a two-element array containing a lower bound and an upper
	//    bound for the estimate. The estimate includes the size of all the items
	//    in the table, plus the size of all attributes projected into all of the
	//    local secondary indexes on the table. Use this estimate to measure whether
	//    a local secondary index is approaching its size limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	//    precision or accuracy of the estimate.
	ItemCollectionMetrics map[string][]ItemCollectionMetrics `type:"map"`

	// A map of tables and requests against those tables that were not processed.
	// The UnprocessedItems value is in the same form as RequestItems, so you can
	// provide this value directly to a subsequent BatchGetItem operation. For more
	// information, see RequestItems in the Request Parameters section.
	//
	// Each UnprocessedItems entry consists of a table name and, for that table,
	// a list of operations to perform (DeleteRequest or PutRequest).
	//
	//    * DeleteRequest - Perform a DeleteItem operation on the specified item.
	//    The item to be deleted is identified by a Key subelement:
	//
	// Key - A map of primary key attribute values that uniquely identify the item.
	//    Each entry in this map consists of an attribute name and an attribute
	//    value.
	//
	//    * PutRequest - Perform a PutItem operation on the specified item. The
	//    item to be put is identified by an Item subelement:
	//
	// Item - A map of attributes and their values. Each entry in this map consists
	//    of an attribute name and an attribute value. Attribute values must not
	//    be null; string and binary type attributes must have lengths greater than
	//    zero; and set type attributes must not be empty. Requests that contain
	//    empty values will be rejected with a ValidationException exception.
	//
	// If you specify any attributes that are part of an index key, then the data
	//    types for those attributes must match those of the schema in the table's
	//    attribute definition.
	//
	// If there are no unprocessed items remaining, the response contains an empty
	// UnprocessedItems map.
	UnprocessedItems map[string][]WriteRequest `min:"1" type:"map"`
}

// String returns the string representation
func (s BatchWriteItemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchWriteItemOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s BatchWriteItemOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Contains the details for the read/write capacity mode.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/BillingModeSummary
type BillingModeSummary struct {
	_ struct{} `type:"structure"`

	// Controls how you are charged for read and write throughput and how you manage
	// capacity. This setting can be changed later.
	//
	//    * PROVISIONED - Sets the read/write capacity mode to PROVISIONED. We recommend
	//    using PROVISIONED for predictable workloads.
	//
	//    * PAY_PER_REQUEST - Sets the read/write capacity mode to PAY_PER_REQUEST.
	//    We recommend using PAY_PER_REQUEST for unpredictable workloads.
	BillingMode BillingMode `type:"string" enum:"true"`

	// Represents the time when PAY_PER_REQUEST was last set as the read/write capacity
	// mode.
	LastUpdateToPayPerRequestDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s BillingModeSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BillingModeSummary) GoString() string {
	return s.String()
}

// An ordered list of errors for each item in the request which caused the transaction
// to get cancelled. The values of the list are ordered according to the ordering
// of the TransactWriteItems request parameter. If no error occurred for the
// associated item an error with a Null code and Null message will be present.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CancellationReason
type CancellationReason struct {
	_ struct{} `type:"structure"`

	// Status code for the result of the cancelled transaction.
	Code *string `type:"string"`

	// Item in the request which caused the transaction to get cancelled.
	Item map[string]AttributeValue `type:"map"`

	// Cancellation reason message description.
	Message *string `type:"string"`
}

// String returns the string representation
func (s CancellationReason) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CancellationReason) GoString() string {
	return s.String()
}

// Represents the amount of provisioned throughput capacity consumed on a table
// or an index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Capacity
type Capacity struct {
	_ struct{} `type:"structure"`

	// The total number of capacity units consumed on a table or an index.
	CapacityUnits *float64 `type:"double"`

	// The total number of read capacity units consumed on a table or an index.
	ReadCapacityUnits *float64 `type:"double"`

	// The total number of write capacity units consumed on a table or an index.
	WriteCapacityUnits *float64 `type:"double"`
}

// String returns the string representation
func (s Capacity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Capacity) GoString() string {
	return s.String()
}

// Represents the selection criteria for a Query or Scan operation:
//
//    * For a Query operation, Condition is used for specifying the KeyConditions
//    to use when querying a table or an index. For KeyConditions, only the
//    following comparison operators are supported:
//
// EQ | LE | LT | GE | GT | BEGINS_WITH | BETWEEN
//
// Condition is also used in a QueryFilter, which evaluates the query results
//    and returns only the desired values.
//
//    * For a Scan operation, Condition is used in a ScanFilter, which evaluates
//    the scan results and returns only the desired values.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Condition
type Condition struct {
	_ struct{} `type:"structure"`

	// One or more values to evaluate against the supplied attribute. The number
	// of values in the list depends on the ComparisonOperator being used.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
	// (http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
	//
	// For Binary, DynamoDB treats each byte of the binary data as unsigned when
	// it compares binary values.
	AttributeValueList []AttributeValue `type:"list"`

	// A comparator for evaluating attributes. For example, equals, greater than,
	// less than, etc.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS |
	// BEGINS_WITH | IN | BETWEEN
	//
	// The following are descriptions of each comparison operator.
	//
	//    * EQ : Equal. EQ is supported for all data types, including lists and
	//    maps.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	//    Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	//    an AttributeValue element of a different type than the one provided in
	//    the request, the value does not match. For example, {"S":"6"} does not
	//    equal {"N":"6"}. Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    * NE : Not equal. NE is supported for all data types, including lists
	//    and maps.
	//
	//    * AttributeValueList can contain only one AttributeValue of type String,
	//    Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	//    an AttributeValue of a different type than the one provided in the request,
	//    the value does not match. For example, {"S":"6"} does not equal {"N":"6"}.
	//    Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    * LE : Less than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	// LT: Less than.
	//
	// AttributeValueListcan contain only one AttributeValueof type String, Number, or Binary (not a set type). If an item contains an
	// AttributeValueelement of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"}does not equal {"N":"6"}. Also, {"N":"6"}does not compare to {"NS":["6", "2", "1"]}
	//
	// ComparisonOperator is a required field
	ComparisonOperator ComparisonOperator `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s Condition) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Condition) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Condition) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Condition"}
	if len(s.ComparisonOperator) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ComparisonOperator"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents a request to perform a check that an item exists or to check the
// condition of specific attributes of the item..
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ConditionCheck
type ConditionCheck struct {
	_ struct{} `type:"structure"`

	// A condition that must be satisfied in order for a conditional update to succeed.
	//
	// ConditionExpression is a required field
	ConditionExpression *string `type:"string" required:"true"`

	// One or more substitution tokens for attribute names in an expression.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// The primary key of the item to be checked. Each element consists of an attribute
	// name and a value for that attribute.
	//
	// Key is a required field
	Key map[string]AttributeValue `type:"map" required:"true"`

	// Use ReturnValuesOnConditionCheckFailure to get the item attributes if the
	// ConditionCheck condition fails. For ReturnValuesOnConditionCheckFailure,
	// the valid values are: NONE and ALL_OLD.
	ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure `type:"string" enum:"true"`

	// Name of the table for the check item request.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s ConditionCheck) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ConditionCheck) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ConditionCheck) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ConditionCheck"}

	if s.ConditionExpression == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConditionExpression"))
	}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// The capacity units consumed by an operation. The data returned includes the
// total provisioned throughput consumed, along with statistics for the table
// and any indexes involved in the operation. ConsumedCapacity is only returned
// if the request asked for it. For more information, see Provisioned Throughput
// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
// in the Amazon DynamoDB Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ConsumedCapacity
type ConsumedCapacity struct {
	_ struct{} `type:"structure"`

	// The total number of capacity units consumed by the operation.
	CapacityUnits *float64 `type:"double"`

	// The amount of throughput consumed on each global index affected by the operation.
	GlobalSecondaryIndexes map[string]Capacity `type:"map"`

	// The amount of throughput consumed on each local index affected by the operation.
	LocalSecondaryIndexes map[string]Capacity `type:"map"`

	// The total number of read capacity units consumed by the operation.
	ReadCapacityUnits *float64 `type:"double"`

	// The amount of throughput consumed on the table affected by the operation.
	Table *Capacity `type:"structure"`

	// The name of the table that was affected by the operation.
	TableName *string `min:"3" type:"string"`

	// The total number of write capacity units consumed by the operation.
	WriteCapacityUnits *float64 `type:"double"`
}

// String returns the string representation
func (s ConsumedCapacity) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ConsumedCapacity) GoString() string {
	return s.String()
}

// Represents the continuous backups and point in time recovery settings on
// the table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ContinuousBackupsDescription
type ContinuousBackupsDescription struct {
	_ struct{} `type:"structure"`

	// ContinuousBackupsStatus can be one of the following states: ENABLED, DISABLED
	//
	// ContinuousBackupsStatus is a required field
	ContinuousBackupsStatus ContinuousBackupsStatus `type:"string" required:"true" enum:"true"`

	// The description of the point in time recovery settings applied to the table.
	PointInTimeRecoveryDescription *PointInTimeRecoveryDescription `type:"structure"`
}

// String returns the string representation
func (s ContinuousBackupsDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ContinuousBackupsDescription) GoString() string {
	return s.String()
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateBackupInput
type CreateBackupInput struct {
	_ struct{} `type:"structure"`

	// Specified name for the backup.
	//
	// BackupName is a required field
	BackupName *string `min:"3" type:"string" required:"true"`

	// The name of the table.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateBackupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBackupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBackupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateBackupInput"}

	if s.BackupName == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupName"))
	}
	if s.BackupName != nil && len(*s.BackupName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("BackupName", 3))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateBackupOutput
type CreateBackupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Contains the details of the backup created for the table.
	BackupDetails *BackupDetails `type:"structure"`
}

// String returns the string representation
func (s CreateBackupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBackupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateBackupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents a new global secondary index to be added to an existing table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateGlobalSecondaryIndexAction
type CreateGlobalSecondaryIndexAction struct {
	_ struct{} `type:"structure"`

	// The name of the global secondary index to be created.
	//
	// IndexName is a required field
	IndexName *string `min:"3" type:"string" required:"true"`

	// The key schema for the global secondary index.
	//
	// KeySchema is a required field
	KeySchema []KeySchemaElement `min:"1" type:"list" required:"true"`

	// Represents attributes that are copied (projected) from the table into an
	// index. These are in addition to the primary key attributes and index key
	// attributes, which are automatically projected.
	//
	// Projection is a required field
	Projection *Projection `type:"structure" required:"true"`

	// Represents the provisioned throughput settings for the specified global secondary
	// index.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure"`
}

// String returns the string representation
func (s CreateGlobalSecondaryIndexAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGlobalSecondaryIndexAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateGlobalSecondaryIndexAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateGlobalSecondaryIndexAction"}

	if s.IndexName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexName"))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}

	if s.KeySchema == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeySchema"))
	}
	if s.KeySchema != nil && len(s.KeySchema) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("KeySchema", 1))
	}

	if s.Projection == nil {
		invalidParams.Add(aws.NewErrParamRequired("Projection"))
	}
	if s.KeySchema != nil {
		for i, v := range s.KeySchema {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "KeySchema", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.Projection != nil {
		if err := s.Projection.Validate(); err != nil {
			invalidParams.AddNested("Projection", err.(aws.ErrInvalidParams))
		}
	}
	if s.ProvisionedThroughput != nil {
		if err := s.ProvisionedThroughput.Validate(); err != nil {
			invalidParams.AddNested("ProvisionedThroughput", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateGlobalTableInput
type CreateGlobalTableInput struct {
	_ struct{} `type:"structure"`

	// The global table name.
	//
	// GlobalTableName is a required field
	GlobalTableName *string `min:"3" type:"string" required:"true"`

	// The regions where the global table needs to be created.
	//
	// ReplicationGroup is a required field
	ReplicationGroup []Replica `type:"list" required:"true"`
}

// String returns the string representation
func (s CreateGlobalTableInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGlobalTableInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateGlobalTableInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateGlobalTableInput"}

	if s.GlobalTableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("GlobalTableName"))
	}
	if s.GlobalTableName != nil && len(*s.GlobalTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("GlobalTableName", 3))
	}

	if s.ReplicationGroup == nil {
		invalidParams.Add(aws.NewErrParamRequired("ReplicationGroup"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateGlobalTableOutput
type CreateGlobalTableOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Contains the details of the global table.
	GlobalTableDescription *GlobalTableDescription `type:"structure"`
}

// String returns the string representation
func (s CreateGlobalTableOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateGlobalTableOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateGlobalTableOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents a replica to be added.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateReplicaAction
type CreateReplicaAction struct {
	_ struct{} `type:"structure"`

	// The region of the replica to be added.
	//
	// RegionName is a required field
	RegionName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s CreateReplicaAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateReplicaAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateReplicaAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateReplicaAction"}

	if s.RegionName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RegionName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the input of a CreateTable operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateTableInput
type CreateTableInput struct {
	_ struct{} `type:"structure"`

	// An array of attributes that describe the key schema for the table and indexes.
	//
	// AttributeDefinitions is a required field
	AttributeDefinitions []AttributeDefinition `type:"list" required:"true"`

	// Controls how you are charged for read and write throughput and how you manage
	// capacity. This setting can be changed later.
	//
	//    * PROVISIONED - Sets the billing mode to PROVISIONED. We recommend using
	//    PROVISIONED for predictable workloads.
	//
	//    * PAY_PER_REQUEST - Sets the billing mode to PAY_PER_REQUEST. We recommend
	//    using PAY_PER_REQUEST for unpredictable workloads.
	BillingMode BillingMode `type:"string" enum:"true"`

	// One or more global secondary indexes (the maximum is five) to be created
	// on the table. Each global secondary index in the array includes the following:
	//
	//    * IndexName - The name of the global secondary index. Must be unique only
	//    for this table.
	//
	//    * KeySchema - Specifies the key schema for the global secondary index.
	//
	//    * Projection - Specifies attributes that are copied (projected) from the
	//    table into the index. These are in addition to the primary key attributes
	//    and index key attributes, which are automatically projected. Each attribute
	//    specification is composed of:
	//
	//    * ProjectionType - One of the following:
	//
	// KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	// INCLUDE - Only the specified table attributes are projected into the index.
	//    The list of projected attributes are in NonKeyAttributes.
	//
	// ALL - All of the table attributes are projected into the index.
	//
	// NonKeyAttributes - A list of one or more non-key attribute names that are
	//    projected into the secondary index. The total count of attributes provided
	//    in NonKeyAttributes, summed across all of the secondary indexes, must
	//    not exceed 20. If you project the same attribute into two different indexes,
	//    this counts as two distinct attributes when determining the total.
	//
	//    * ProvisionedThroughput - The provisioned throughput settings for the
	//    global secondary index, consisting of read and write capacity units.
	GlobalSecondaryIndexes []GlobalSecondaryIndex `type:"list"`

	// Specifies the attributes that make up the primary key for a table or an index.
	// The attributes in KeySchema must also be defined in the AttributeDefinitions
	// array. For more information, see Data Model (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// Each KeySchemaElement in the array is composed of:
	//
	//    * AttributeName - The name of this key attribute.
	//
	//    * KeyType - The role that the key attribute will assume:
	//
	// HASH - partition key
	//
	// RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	// "hash attribute" derives from DynamoDB' usage of an internal hash function
	// to evenly distribute data items across partitions, based on their partition
	// key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	// attribute" derives from the way DynamoDB stores items with the same partition
	// key physically close together, in sorted order by the sort key value.
	//
	// For a simple primary key (partition key), you must provide exactly one element
	// with a KeyType of HASH.
	//
	// For a composite primary key (partition key and sort key), you must provide
	// exactly two elements, in this order: The first element must have a KeyType
	// of HASH, and the second element must have a KeyType of RANGE.
	//
	// For more information, see Specifying the Primary Key (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key)
	// in the Amazon DynamoDB Developer Guide.
	//
	// KeySchema is a required field
	KeySchema []KeySchemaElement `min:"1" type:"list" required:"true"`

	// One or more local secondary indexes (the maximum is five) to be created on
	// the table. Each index is scoped to a given partition key value. There is
	// a 10 GB size limit per partition key value; otherwise, the size of a local
	// secondary index is unconstrained.
	//
	// Each local secondary index in the array includes the following:
	//
	//    * IndexName - The name of the local secondary index. Must be unique only
	//    for this table.
	//
	//    * KeySchema - Specifies the key schema for the local secondary index.
	//    The key schema must begin with the same partition key as the table.
	//
	//    * Projection - Specifies attributes that are copied (projected) from the
	//    table into the index. These are in addition to the primary key attributes
	//    and index key attributes, which are automatically projected. Each attribute
	//    specification is composed of:
	//
	//    * ProjectionType - One of the following:
	//
	// KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	// INCLUDE - Only the specified table attributes are projected into the index.
	//    The list of projected attributes are in NonKeyAttributes.
	//
	// ALL - All of the table attributes are projected into the index.
	//
	// NonKeyAttributes - A list of one or more non-key attribute names that are
	//    projected into the secondary index. The total count of attributes provided
	//    in NonKeyAttributes, summed across all of the secondary indexes, must
	//    not exceed 20. If you project the same attribute into two different indexes,
	//    this counts as two distinct attributes when determining the total.
	LocalSecondaryIndexes []LocalSecondaryIndex `type:"list"`

	// Represents the provisioned throughput settings for a specified table or index.
	// The settings can be modified using the UpdateTable operation.
	//
	// If you set BillingMode as PROVISIONED, you must specify this property. If
	// you set BillingMode as PAY_PER_REQUEST, you cannot specify this property.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure"`

	// Represents the settings used to enable server-side encryption.
	SSESpecification *SSESpecification `type:"structure"`

	// The settings for DynamoDB Streams on the table. These settings consist of:
	//
	//    * StreamEnabled - Indicates whether Streams is to be enabled (true) or
	//    disabled (false).
	//
	//    * StreamViewType - When an item in the table is modified, StreamViewType
	//    determines what information is written to the table's stream. Valid values
	//    for StreamViewType are:
	//
	// KEYS_ONLY - Only the key attributes of the modified item are written to the
	//    stream.
	//
	// NEW_IMAGE - The entire item, as it appears after it was modified, is written
	//    to the stream.
	//
	// OLD_IMAGE - The entire item, as it appeared before it was modified, is written
	//    to the stream.
	//
	// NEW_AND_OLD_IMAGES - Both the new and the old item images of the item are
	//    written to the stream.
	StreamSpecification *StreamSpecification `type:"structure"`

	// The name of the table to create.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateTableInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTableInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTableInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTableInput"}

	if s.AttributeDefinitions == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeDefinitions"))
	}

	if s.KeySchema == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeySchema"))
	}
	if s.KeySchema != nil && len(s.KeySchema) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("KeySchema", 1))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}
	if s.AttributeDefinitions != nil {
		for i, v := range s.AttributeDefinitions {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AttributeDefinitions", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.GlobalSecondaryIndexes != nil {
		for i, v := range s.GlobalSecondaryIndexes {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "GlobalSecondaryIndexes", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.KeySchema != nil {
		for i, v := range s.KeySchema {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "KeySchema", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.LocalSecondaryIndexes != nil {
		for i, v := range s.LocalSecondaryIndexes {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "LocalSecondaryIndexes", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.ProvisionedThroughput != nil {
		if err := s.ProvisionedThroughput.Validate(); err != nil {
			invalidParams.AddNested("ProvisionedThroughput", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a CreateTable operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/CreateTableOutput
type CreateTableOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Represents the properties of the table.
	TableDescription *TableDescription `type:"structure"`
}

// String returns the string representation
func (s CreateTableOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTableOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTableOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents a request to perform a DeleteItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Delete
type Delete struct {
	_ struct{} `type:"structure"`

	// A condition that must be satisfied in order for a conditional delete to succeed.
	ConditionExpression *string `type:"string"`

	// One or more substitution tokens for attribute names in an expression.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// The primary key of the item to be deleted. Each element consists of an attribute
	// name and a value for that attribute.
	//
	// Key is a required field
	Key map[string]AttributeValue `type:"map" required:"true"`

	// Use ReturnValuesOnConditionCheckFailure to get the item attributes if the
	// Delete condition fails. For ReturnValuesOnConditionCheckFailure, the valid
	// values are: NONE and ALL_OLD.
	ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure `type:"string" enum:"true"`

	// Name of the table in which the item to be deleted resides.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s Delete) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Delete) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Delete) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Delete"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteBackupInput
type DeleteBackupInput struct {
	_ struct{} `type:"structure"`

	// The ARN associated with the backup.
	//
	// BackupArn is a required field
	BackupArn *string `min:"37" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBackupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBackupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBackupInput"}

	if s.BackupArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupArn"))
	}
	if s.BackupArn != nil && len(*s.BackupArn) < 37 {
		invalidParams.Add(aws.NewErrParamMinLen("BackupArn", 37))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteBackupOutput
type DeleteBackupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Contains the description of the backup created for the table.
	BackupDescription *BackupDescription `type:"structure"`
}

// String returns the string representation
func (s DeleteBackupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBackupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBackupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents a global secondary index to be deleted from an existing table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteGlobalSecondaryIndexAction
type DeleteGlobalSecondaryIndexAction struct {
	_ struct{} `type:"structure"`

	// The name of the global secondary index to be deleted.
	//
	// IndexName is a required field
	IndexName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteGlobalSecondaryIndexAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGlobalSecondaryIndexAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteGlobalSecondaryIndexAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteGlobalSecondaryIndexAction"}

	if s.IndexName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexName"))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the input of a DeleteItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteItemInput
type DeleteItemInput struct {
	_ struct{} `type:"structure"`

	// A condition that must be satisfied in order for a conditional DeleteItem
	// to succeed.
	//
	// An expression can contain any of the following:
	//
	//    * Functions: attribute_exists | attribute_not_exists | attribute_type
	//    | contains | begins_with | size
	//
	// These function names are case-sensitive.
	//
	//    * Comparison operators: = | <> | < | > | <= | >= | BETWEEN | IN
	//
	//    *  Logical operators: AND | OR | NOT
	//
	// For more information on condition expressions, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	ConditionExpression *string `type:"string"`

	// This is a legacy parameter. Use ConditionExpression instead. For more information,
	// see ConditionalOperator (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
	// in the Amazon DynamoDB Developer Guide.
	ConditionalOperator ConditionalOperator `type:"string" enum:"true"`

	// This is a legacy parameter. Use ConditionExpression instead. For more information,
	// see Expected (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html)
	// in the Amazon DynamoDB Developer Guide.
	Expected map[string]ExpectedAttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//    * To access an attribute whose name conflicts with a DynamoDB reserved
	//    word.
	//
	//    * To create a placeholder for repeating occurrences of an attribute name
	//    in an expression.
	//
	//    * To prevent special characters in an attribute name from being misinterpreted
	//    in an expression.
	//
	// Use the # character in an expression to dereference an attribute name. For
	// example, consider the following attribute name:
	//
	//    * Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot be
	// used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	//    * {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	//    * #P = :val
	//
	// Tokens that begin with the : character are expression attribute values, which
	// are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// A map of attribute names to AttributeValue objects, representing the primary
	// key of the item to delete.
	//
	// For the primary key, you must provide all of the attributes. For example,
	// with a simple primary key, you only need to provide a value for the partition
	// key. For a composite primary key, you must provide values for both the partition
	// key and the sort key.
	//
	// Key is a required field
	Key map[string]AttributeValue `type:"map" required:"true"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// Determines whether item collection metrics are returned. If set to SIZE,
	// the response includes statistics about item collections, if any, that were
	// modified during the operation are returned in the response. If set to NONE
	// (the default), no statistics are returned.
	ReturnItemCollectionMetrics ReturnItemCollectionMetrics `type:"string" enum:"true"`

	// Use ReturnValues if you want to get the item attributes as they appeared
	// before they were deleted. For DeleteItem, the valid values are:
	//
	//    * NONE - If ReturnValues is not specified, or if its value is NONE, then
	//    nothing is returned. (This setting is the default for ReturnValues.)
	//
	//    * ALL_OLD - The content of the old item is returned.
	//
	// The ReturnValues parameter is used by several DynamoDB operations; however,
	// DeleteItem does not recognize any values other than NONE or ALL_OLD.
	ReturnValues ReturnValue `type:"string" enum:"true"`

	// The name of the table from which to delete the item.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteItemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteItemInput"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DeleteItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteItemOutput
type DeleteItemOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A map of attribute names to AttributeValue objects, representing the item
	// as it appeared before the DeleteItem operation. This map appears in the response
	// only if ReturnValues was specified as ALL_OLD in the request.
	Attributes map[string]AttributeValue `type:"map"`

	// The capacity units consumed by the DeleteItem operation. The data returned
	// includes the total provisioned throughput consumed, along with statistics
	// for the table and any indexes involved in the operation. ConsumedCapacity
	// is only returned if the ReturnConsumedCapacity parameter was specified. For
	// more information, see Provisioned Throughput (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// Information about item collections, if any, that were affected by the DeleteItem
	// operation. ItemCollectionMetrics is only returned if the ReturnItemCollectionMetrics
	// parameter was specified. If the table does not have any local secondary indexes,
	// this information is not returned in the response.
	//
	// Each ItemCollectionMetrics element consists of:
	//
	//    * ItemCollectionKey - The partition key value of the item collection.
	//    This is the same as the partition key value of the item itself.
	//
	//    * SizeEstimateRangeGB - An estimate of item collection size, in gigabytes.
	//    This value is a two-element array containing a lower bound and an upper
	//    bound for the estimate. The estimate includes the size of all the items
	//    in the table, plus the size of all attributes projected into all of the
	//    local secondary indexes on that table. Use this estimate to measure whether
	//    a local secondary index is approaching its size limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	//    precision or accuracy of the estimate.
	ItemCollectionMetrics *ItemCollectionMetrics `type:"structure"`
}

// String returns the string representation
func (s DeleteItemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteItemOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteItemOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents a replica to be removed.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteReplicaAction
type DeleteReplicaAction struct {
	_ struct{} `type:"structure"`

	// The region of the replica to be removed.
	//
	// RegionName is a required field
	RegionName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteReplicaAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteReplicaAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteReplicaAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteReplicaAction"}

	if s.RegionName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RegionName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents a request to perform a DeleteItem operation on an item.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteRequest
type DeleteRequest struct {
	_ struct{} `type:"structure"`

	// A map of attribute name to attribute values, representing the primary key
	// of the item to delete. All of the table's primary key attributes must be
	// specified, and their data types must match those of the table's key schema.
	//
	// Key is a required field
	Key map[string]AttributeValue `type:"map" required:"true"`
}

// String returns the string representation
func (s DeleteRequest) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRequest) GoString() string {
	return s.String()
}

// Represents the input of a DeleteTable operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteTableInput
type DeleteTableInput struct {
	_ struct{} `type:"structure"`

	// The name of the table to delete.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteTableInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTableInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTableInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTableInput"}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DeleteTable operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DeleteTableOutput
type DeleteTableOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Represents the properties of a table.
	TableDescription *TableDescription `type:"structure"`
}

// String returns the string representation
func (s DeleteTableOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTableOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTableOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeBackupInput
type DescribeBackupInput struct {
	_ struct{} `type:"structure"`

	// The ARN associated with the backup.
	//
	// BackupArn is a required field
	BackupArn *string `min:"37" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeBackupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBackupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeBackupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeBackupInput"}

	if s.BackupArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupArn"))
	}
	if s.BackupArn != nil && len(*s.BackupArn) < 37 {
		invalidParams.Add(aws.NewErrParamMinLen("BackupArn", 37))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeBackupOutput
type DescribeBackupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Contains the description of the backup created for the table.
	BackupDescription *BackupDescription `type:"structure"`
}

// String returns the string representation
func (s DescribeBackupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBackupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeBackupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeContinuousBackupsInput
type DescribeContinuousBackupsInput struct {
	_ struct{} `type:"structure"`

	// Name of the table for which the customer wants to check the continuous backups
	// and point in time recovery settings.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeContinuousBackupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeContinuousBackupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeContinuousBackupsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeContinuousBackupsInput"}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeContinuousBackupsOutput
type DescribeContinuousBackupsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Represents the continuous backups and point in time recovery settings on
	// the table.
	ContinuousBackupsDescription *ContinuousBackupsDescription `type:"structure"`
}

// String returns the string representation
func (s DescribeContinuousBackupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeContinuousBackupsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeContinuousBackupsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeEndpointsRequest
type DescribeEndpointsInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DescribeEndpointsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEndpointsInput) GoString() string {
	return s.String()
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeEndpointsResponse
type DescribeEndpointsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Endpoints is a required field
	Endpoints []Endpoint `type:"list" required:"true"`
}

// String returns the string representation
func (s DescribeEndpointsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeEndpointsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeEndpointsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTableInput
type DescribeGlobalTableInput struct {
	_ struct{} `type:"structure"`

	// The name of the global table.
	//
	// GlobalTableName is a required field
	GlobalTableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeGlobalTableInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGlobalTableInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeGlobalTableInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeGlobalTableInput"}

	if s.GlobalTableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("GlobalTableName"))
	}
	if s.GlobalTableName != nil && len(*s.GlobalTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("GlobalTableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTableOutput
type DescribeGlobalTableOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Contains the details of the global table.
	GlobalTableDescription *GlobalTableDescription `type:"structure"`
}

// String returns the string representation
func (s DescribeGlobalTableOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGlobalTableOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeGlobalTableOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTableSettingsInput
type DescribeGlobalTableSettingsInput struct {
	_ struct{} `type:"structure"`

	// The name of the global table to describe.
	//
	// GlobalTableName is a required field
	GlobalTableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeGlobalTableSettingsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGlobalTableSettingsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeGlobalTableSettingsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeGlobalTableSettingsInput"}

	if s.GlobalTableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("GlobalTableName"))
	}
	if s.GlobalTableName != nil && len(*s.GlobalTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("GlobalTableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeGlobalTableSettingsOutput
type DescribeGlobalTableSettingsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The name of the global table.
	GlobalTableName *string `min:"3" type:"string"`

	// The region specific settings for the global table.
	ReplicaSettings []ReplicaSettingsDescription `type:"list"`
}

// String returns the string representation
func (s DescribeGlobalTableSettingsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeGlobalTableSettingsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeGlobalTableSettingsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input of a DescribeLimits operation. Has no content.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeLimitsInput
type DescribeLimitsInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DescribeLimitsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeLimitsInput) GoString() string {
	return s.String()
}

// Represents the output of a DescribeLimits operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeLimitsOutput
type DescribeLimitsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The maximum total read capacity units that your account allows you to provision
	// across all of your tables in this region.
	AccountMaxReadCapacityUnits *int64 `min:"1" type:"long"`

	// The maximum total write capacity units that your account allows you to provision
	// across all of your tables in this region.
	AccountMaxWriteCapacityUnits *int64 `min:"1" type:"long"`

	// The maximum read capacity units that your account allows you to provision
	// for a new table that you are creating in this region, including the read
	// capacity units provisioned for its global secondary indexes (GSIs).
	TableMaxReadCapacityUnits *int64 `min:"1" type:"long"`

	// The maximum write capacity units that your account allows you to provision
	// for a new table that you are creating in this region, including the write
	// capacity units provisioned for its global secondary indexes (GSIs).
	TableMaxWriteCapacityUnits *int64 `min:"1" type:"long"`
}

// String returns the string representation
func (s DescribeLimitsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeLimitsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeLimitsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input of a DescribeTable operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTableInput
type DescribeTableInput struct {
	_ struct{} `type:"structure"`

	// The name of the table to describe.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeTableInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeTableInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeTableInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeTableInput"}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a DescribeTable operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTableOutput
type DescribeTableOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The properties of the table.
	Table *TableDescription `type:"structure"`
}

// String returns the string representation
func (s DescribeTableOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeTableOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeTableOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTimeToLiveInput
type DescribeTimeToLiveInput struct {
	_ struct{} `type:"structure"`

	// The name of the table to be described.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeTimeToLiveInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeTimeToLiveInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeTimeToLiveInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeTimeToLiveInput"}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/DescribeTimeToLiveOutput
type DescribeTimeToLiveOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The description of the Time to Live (TTL) status on the specified table.
	TimeToLiveDescription *TimeToLiveDescription `type:"structure"`
}

// String returns the string representation
func (s DescribeTimeToLiveOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeTimeToLiveOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeTimeToLiveOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Endpoint
type Endpoint struct {
	_ struct{} `type:"structure"`

	// Address is a required field
	Address *string `type:"string" required:"true"`

	// CachePeriodInMinutes is a required field
	CachePeriodInMinutes *int64 `type:"long" required:"true"`
}

// String returns the string representation
func (s Endpoint) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Endpoint) GoString() string {
	return s.String()
}

// Represents a condition to be compared with an attribute value. This condition
// can be used with DeleteItem, PutItem or UpdateItem operations; if the comparison
// evaluates to true, the operation succeeds; if not, the operation fails. You
// can use ExpectedAttributeValue in one of two different ways:
//
//    * Use AttributeValueList to specify one or more values to compare against
//    an attribute. Use ComparisonOperator to specify how you want to perform
//    the comparison. If the comparison evaluates to true, then the conditional
//    operation succeeds.
//
//    * Use Value to specify a value that DynamoDB will compare against an attribute.
//    If the values match, then ExpectedAttributeValue evaluates to true and
//    the conditional operation succeeds. Optionally, you can also set Exists
//    to false, indicating that you do not expect to find the attribute value
//    in the table. In this case, the conditional operation succeeds only if
//    the comparison evaluates to false.
//
// Value and Exists are incompatible with AttributeValueList and ComparisonOperator.
// Note that if you use both sets of parameters at once, DynamoDB will return
// a ValidationException exception.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ExpectedAttributeValue
type ExpectedAttributeValue struct {
	_ struct{} `type:"structure"`

	// One or more values to evaluate against the supplied attribute. The number
	// of values in the list depends on the ComparisonOperator being used.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
	// (http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
	//
	// For Binary, DynamoDB treats each byte of the binary data as unsigned when
	// it compares binary values.
	//
	// For information on specifying data types in JSON, see JSON Data Format (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataFormat.html)
	// in the Amazon DynamoDB Developer Guide.
	AttributeValueList []AttributeValue `type:"list"`

	// A comparator for evaluating attributes in the AttributeValueList. For example,
	// equals, greater than, less than, etc.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS |
	// BEGINS_WITH | IN | BETWEEN
	//
	// The following are descriptions of each comparison operator.
	//
	//    * EQ : Equal. EQ is supported for all data types, including lists and
	//    maps.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	//    Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	//    an AttributeValue element of a different type than the one provided in
	//    the request, the value does not match. For example, {"S":"6"} does not
	//    equal {"N":"6"}. Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    * NE : Not equal. NE is supported for all data types, including lists
	//    and maps.
	//
	//    * AttributeValueList can contain only one AttributeValue of type String,
	//    Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	//    an AttributeValue of a different type than the one provided in the request,
	//    the value does not match. For example, {"S":"6"} does not equal {"N":"6"}.
	//    Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    * LE : Less than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	// LT: Less than.
	//
	// AttributeValueListcan contain only one AttributeValueof type String, Number, or Binary (not a set type). If an item contains an
	// AttributeValueelement of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"}does not equal {"N":"6"}. Also, {"N":"6"}does not compare to {"NS":["6", "2", "1"]}
	ComparisonOperator ComparisonOperator `type:"string" enum:"true"`

	// Causes DynamoDB to evaluate the value before attempting a conditional operation:
	//
	//    * If Exists is true, DynamoDB will check to see if that attribute value
	//    already exists in the table. If it is found, then the operation succeeds.
	//    If it is not found, the operation fails with a ConditionCheckFailedException.
	//
	//    * If Exists is false, DynamoDB assumes that the attribute value does not
	//    exist in the table. If in fact the value does not exist, then the assumption
	//    is valid and the operation succeeds. If the value is found, despite the
	//    assumption that it does not exist, the operation fails with a ConditionCheckFailedException.
	//
	// The default setting for Exists is true. If you supply a Value all by itself,
	// DynamoDB assumes the attribute exists: You don't have to set Exists to true,
	// because it is implied.
	//
	// DynamoDB returns a ValidationException if:
	//
	//    * Exists is true but there is no Value to check. (You expect a value to
	//    exist, but don't specify what that value is.)
	//
	//    * Exists is false but you also provide a Value. (You cannot expect an
	//    attribute to have a value, while also expecting it not to exist.)
	Exists *bool `type:"boolean"`

	// Represents the data for the expected attribute.
	//
	// Each attribute value is described as a name-value pair. The name is the data
	// type, and the value is the data itself.
	//
	// For more information, see Data Types (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes)
	// in the Amazon DynamoDB Developer Guide.
	Value *AttributeValue `type:"structure"`
}

// String returns the string representation
func (s ExpectedAttributeValue) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ExpectedAttributeValue) GoString() string {
	return s.String()
}

// Specifies an item and related attribute values to retrieve in a TransactGetItem
// object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Get
type Get struct {
	_ struct{} `type:"structure"`

	// One or more substitution tokens for attribute names in the ProjectionExpression
	// parameter.
	ExpressionAttributeNames map[string]string `type:"map"`

	// A map of attribute names to AttributeValue objects that specifies the primary
	// key of the item to retrieve.
	//
	// Key is a required field
	Key map[string]AttributeValue `type:"map" required:"true"`

	// A string that identifies one or more attributes of the specified item to
	// retrieve from the table. The attributes in the expression must be separated
	// by commas. If no attribute names are specified, then all attributes of the
	// specified item are returned. If any of the requested attributes are not found,
	// they do not appear in the result.
	ProjectionExpression *string `type:"string"`

	// The name of the table from which to retrieve the specified item.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s Get) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Get) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Get) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Get"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the input of a GetItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GetItemInput
type GetItemInput struct {
	_ struct{} `type:"structure"`

	// This is a legacy parameter. Use ProjectionExpression instead. For more information,
	// see AttributesToGet (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
	// in the Amazon DynamoDB Developer Guide.
	AttributesToGet []string `min:"1" type:"list"`

	// Determines the read consistency model: If set to true, then the operation
	// uses strongly consistent reads; otherwise, the operation uses eventually
	// consistent reads.
	ConsistentRead *bool `type:"boolean"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//    * To access an attribute whose name conflicts with a DynamoDB reserved
	//    word.
	//
	//    * To create a placeholder for repeating occurrences of an attribute name
	//    in an expression.
	//
	//    * To prevent special characters in an attribute name from being misinterpreted
	//    in an expression.
	//
	// Use the # character in an expression to dereference an attribute name. For
	// example, consider the following attribute name:
	//
	//    * Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot be
	// used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	//    * {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	//    * #P = :val
	//
	// Tokens that begin with the : character are expression attribute values, which
	// are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]string `type:"map"`

	// A map of attribute names to AttributeValue objects, representing the primary
	// key of the item to retrieve.
	//
	// For the primary key, you must provide all of the attributes. For example,
	// with a simple primary key, you only need to provide a value for the partition
	// key. For a composite primary key, you must provide values for both the partition
	// key and the sort key.
	//
	// Key is a required field
	Key map[string]AttributeValue `type:"map" required:"true"`

	// A string that identifies one or more attributes to retrieve from the table.
	// These attributes can include scalars, sets, or elements of a JSON document.
	// The attributes in the expression must be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ProjectionExpression *string `type:"string"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// The name of the table containing the requested item.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s GetItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetItemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetItemInput"}
	if s.AttributesToGet != nil && len(s.AttributesToGet) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributesToGet", 1))
	}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a GetItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GetItemOutput
type GetItemOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The capacity units consumed by the GetItem operation. The data returned includes
	// the total provisioned throughput consumed, along with statistics for the
	// table and any indexes involved in the operation. ConsumedCapacity is only
	// returned if the ReturnConsumedCapacity parameter was specified. For more
	// information, see Provisioned Throughput (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// A map of attribute names to AttributeValue objects, as specified by ProjectionExpression.
	Item map[string]AttributeValue `type:"map"`
}

// String returns the string representation
func (s GetItemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetItemOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetItemOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the properties of a global secondary index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GlobalSecondaryIndex
type GlobalSecondaryIndex struct {
	_ struct{} `type:"structure"`

	// The name of the global secondary index. The name must be unique among all
	// other indexes on this table.
	//
	// IndexName is a required field
	IndexName *string `min:"3" type:"string" required:"true"`

	// The complete key schema for a global secondary index, which consists of one
	// or more pairs of attribute names and key types:
	//
	//    * HASH - partition key
	//
	//    * RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	// "hash attribute" derives from DynamoDB' usage of an internal hash function
	// to evenly distribute data items across partitions, based on their partition
	// key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	// attribute" derives from the way DynamoDB stores items with the same partition
	// key physically close together, in sorted order by the sort key value.
	//
	// KeySchema is a required field
	KeySchema []KeySchemaElement `min:"1" type:"list" required:"true"`

	// Represents attributes that are copied (projected) from the table into the
	// global secondary index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected.
	//
	// Projection is a required field
	Projection *Projection `type:"structure" required:"true"`

	// Represents the provisioned throughput settings for the specified global secondary
	// index.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure"`
}

// String returns the string representation
func (s GlobalSecondaryIndex) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GlobalSecondaryIndex) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GlobalSecondaryIndex) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GlobalSecondaryIndex"}

	if s.IndexName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexName"))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}

	if s.KeySchema == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeySchema"))
	}
	if s.KeySchema != nil && len(s.KeySchema) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("KeySchema", 1))
	}

	if s.Projection == nil {
		invalidParams.Add(aws.NewErrParamRequired("Projection"))
	}
	if s.KeySchema != nil {
		for i, v := range s.KeySchema {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "KeySchema", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.Projection != nil {
		if err := s.Projection.Validate(); err != nil {
			invalidParams.AddNested("Projection", err.(aws.ErrInvalidParams))
		}
	}
	if s.ProvisionedThroughput != nil {
		if err := s.ProvisionedThroughput.Validate(); err != nil {
			invalidParams.AddNested("ProvisionedThroughput", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the properties of a global secondary index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GlobalSecondaryIndexDescription
type GlobalSecondaryIndexDescription struct {
	_ struct{} `type:"structure"`

	// Indicates whether the index is currently backfilling. Backfilling is the
	// process of reading items from the table and determining whether they can
	// be added to the index. (Not all items will qualify: For example, a partition
	// key cannot have any duplicate values.) If an item can be added to the index,
	// DynamoDB will do so. After all items have been processed, the backfilling
	// operation is complete and Backfilling is false.
	//
	// For indexes that were created during a CreateTable operation, the Backfilling
	// attribute does not appear in the DescribeTable output.
	Backfilling *bool `type:"boolean"`

	// The Amazon Resource Name (ARN) that uniquely identifies the index.
	IndexArn *string `type:"string"`

	// The name of the global secondary index.
	IndexName *string `min:"3" type:"string"`

	// The total size of the specified index, in bytes. DynamoDB updates this value
	// approximately every six hours. Recent changes might not be reflected in this
	// value.
	IndexSizeBytes *int64 `type:"long"`

	// The current state of the global secondary index:
	//
	//    * CREATING - The index is being created.
	//
	//    * UPDATING - The index is being updated.
	//
	//    * DELETING - The index is being deleted.
	//
	//    * ACTIVE - The index is ready for use.
	IndexStatus IndexStatus `type:"string" enum:"true"`

	// The number of items in the specified index. DynamoDB updates this value approximately
	// every six hours. Recent changes might not be reflected in this value.
	ItemCount *int64 `type:"long"`

	// The complete key schema for a global secondary index, which consists of one
	// or more pairs of attribute names and key types:
	//
	//    * HASH - partition key
	//
	//    * RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	// "hash attribute" derives from DynamoDB' usage of an internal hash function
	// to evenly distribute data items across partitions, based on their partition
	// key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	// attribute" derives from the way DynamoDB stores items with the same partition
	// key physically close together, in sorted order by the sort key value.
	KeySchema []KeySchemaElement `min:"1" type:"list"`

	// Represents attributes that are copied (projected) from the table into the
	// global secondary index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected.
	Projection *Projection `type:"structure"`

	// Represents the provisioned throughput settings for the specified global secondary
	// index.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughputDescription `type:"structure"`
}

// String returns the string representation
func (s GlobalSecondaryIndexDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GlobalSecondaryIndexDescription) GoString() string {
	return s.String()
}

// Represents the properties of a global secondary index for the table when
// the backup was created.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GlobalSecondaryIndexInfo
type GlobalSecondaryIndexInfo struct {
	_ struct{} `type:"structure"`

	// The name of the global secondary index.
	IndexName *string `min:"3" type:"string"`

	// The complete key schema for a global secondary index, which consists of one
	// or more pairs of attribute names and key types:
	//
	//    * HASH - partition key
	//
	//    * RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	// "hash attribute" derives from DynamoDB' usage of an internal hash function
	// to evenly distribute data items across partitions, based on their partition
	// key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	// attribute" derives from the way DynamoDB stores items with the same partition
	// key physically close together, in sorted order by the sort key value.
	KeySchema []KeySchemaElement `min:"1" type:"list"`

	// Represents attributes that are copied (projected) from the table into the
	// global secondary index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected.
	Projection *Projection `type:"structure"`

	// Represents the provisioned throughput settings for the specified global secondary
	// index.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure"`
}

// String returns the string representation
func (s GlobalSecondaryIndexInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GlobalSecondaryIndexInfo) GoString() string {
	return s.String()
}

// Represents one of the following:
//
//    * A new global secondary index to be added to an existing table.
//
//    * New provisioned throughput parameters for an existing global secondary
//    index.
//
//    * An existing global secondary index to be removed from an existing table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GlobalSecondaryIndexUpdate
type GlobalSecondaryIndexUpdate struct {
	_ struct{} `type:"structure"`

	// The parameters required for creating a global secondary index on an existing
	// table:
	//
	//    * IndexName
	//
	//    * KeySchema
	//
	//    * AttributeDefinitions
	//
	//    * Projection
	//
	//    * ProvisionedThroughput
	Create *CreateGlobalSecondaryIndexAction `type:"structure"`

	// The name of an existing global secondary index to be removed.
	Delete *DeleteGlobalSecondaryIndexAction `type:"structure"`

	// The name of an existing global secondary index, along with new provisioned
	// throughput settings to be applied to that index.
	Update *UpdateGlobalSecondaryIndexAction `type:"structure"`
}

// String returns the string representation
func (s GlobalSecondaryIndexUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GlobalSecondaryIndexUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GlobalSecondaryIndexUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GlobalSecondaryIndexUpdate"}
	if s.Create != nil {
		if err := s.Create.Validate(); err != nil {
			invalidParams.AddNested("Create", err.(aws.ErrInvalidParams))
		}
	}
	if s.Delete != nil {
		if err := s.Delete.Validate(); err != nil {
			invalidParams.AddNested("Delete", err.(aws.ErrInvalidParams))
		}
	}
	if s.Update != nil {
		if err := s.Update.Validate(); err != nil {
			invalidParams.AddNested("Update", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the properties of a global table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GlobalTable
type GlobalTable struct {
	_ struct{} `type:"structure"`

	// The global table name.
	GlobalTableName *string `min:"3" type:"string"`

	// The regions where the global table has replicas.
	ReplicationGroup []Replica `type:"list"`
}

// String returns the string representation
func (s GlobalTable) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GlobalTable) GoString() string {
	return s.String()
}

// Contains details about the global table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GlobalTableDescription
type GlobalTableDescription struct {
	_ struct{} `type:"structure"`

	// The creation time of the global table.
	CreationDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The unique identifier of the global table.
	GlobalTableArn *string `type:"string"`

	// The global table name.
	GlobalTableName *string `min:"3" type:"string"`

	// The current state of the global table:
	//
	//    * CREATING - The global table is being created.
	//
	//    * UPDATING - The global table is being updated.
	//
	//    * DELETING - The global table is being deleted.
	//
	//    * ACTIVE - The global table is ready for use.
	GlobalTableStatus GlobalTableStatus `type:"string" enum:"true"`

	// The regions where the global table has replicas.
	ReplicationGroup []ReplicaDescription `type:"list"`
}

// String returns the string representation
func (s GlobalTableDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GlobalTableDescription) GoString() string {
	return s.String()
}

// Represents the settings of a global secondary index for a global table that
// will be modified.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/GlobalTableGlobalSecondaryIndexSettingsUpdate
type GlobalTableGlobalSecondaryIndexSettingsUpdate struct {
	_ struct{} `type:"structure"`

	// The name of the global secondary index. The name must be unique among all
	// other indexes on this table.
	//
	// IndexName is a required field
	IndexName *string `min:"3" type:"string" required:"true"`

	// AutoScaling settings for managing a global secondary index's write capacity
	// units.
	ProvisionedWriteCapacityAutoScalingSettingsUpdate *AutoScalingSettingsUpdate `type:"structure"`

	// The maximum number of writes consumed per second before DynamoDB returns
	// a ThrottlingException.
	ProvisionedWriteCapacityUnits *int64 `min:"1" type:"long"`
}

// String returns the string representation
func (s GlobalTableGlobalSecondaryIndexSettingsUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GlobalTableGlobalSecondaryIndexSettingsUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GlobalTableGlobalSecondaryIndexSettingsUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GlobalTableGlobalSecondaryIndexSettingsUpdate"}

	if s.IndexName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexName"))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}
	if s.ProvisionedWriteCapacityUnits != nil && *s.ProvisionedWriteCapacityUnits < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("ProvisionedWriteCapacityUnits", 1))
	}
	if s.ProvisionedWriteCapacityAutoScalingSettingsUpdate != nil {
		if err := s.ProvisionedWriteCapacityAutoScalingSettingsUpdate.Validate(); err != nil {
			invalidParams.AddNested("ProvisionedWriteCapacityAutoScalingSettingsUpdate", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Information about item collections, if any, that were affected by the operation.
// ItemCollectionMetrics is only returned if the request asked for it. If the
// table does not have any local secondary indexes, this information is not
// returned in the response.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ItemCollectionMetrics
type ItemCollectionMetrics struct {
	_ struct{} `type:"structure"`

	// The partition key value of the item collection. This value is the same as
	// the partition key value of the item.
	ItemCollectionKey map[string]AttributeValue `type:"map"`

	// An estimate of item collection size, in gigabytes. This value is a two-element
	// array containing a lower bound and an upper bound for the estimate. The estimate
	// includes the size of all the items in the table, plus the size of all attributes
	// projected into all of the local secondary indexes on that table. Use this
	// estimate to measure whether a local secondary index is approaching its size
	// limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	// precision or accuracy of the estimate.
	SizeEstimateRangeGB []float64 `type:"list"`
}

// String returns the string representation
func (s ItemCollectionMetrics) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ItemCollectionMetrics) GoString() string {
	return s.String()
}

// Details for the requested item.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ItemResponse
type ItemResponse struct {
	_ struct{} `type:"structure"`

	// Map of attribute data consisting of the data type and attribute value.
	Item map[string]AttributeValue `type:"map"`
}

// String returns the string representation
func (s ItemResponse) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ItemResponse) GoString() string {
	return s.String()
}

// Represents a single element of a key schema. A key schema specifies the attributes
// that make up the primary key of a table, or the key attributes of an index.
//
// A KeySchemaElement represents exactly one attribute of the primary key. For
// example, a simple primary key would be represented by one KeySchemaElement
// (for the partition key). A composite primary key would require one KeySchemaElement
// for the partition key, and another KeySchemaElement for the sort key.
//
// A KeySchemaElement must be a scalar, top-level attribute (not a nested attribute).
// The data type must be one of String, Number, or Binary. The attribute cannot
// be nested within a List or a Map.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/KeySchemaElement
type KeySchemaElement struct {
	_ struct{} `type:"structure"`

	// The name of a key attribute.
	//
	// AttributeName is a required field
	AttributeName *string `min:"1" type:"string" required:"true"`

	// The role that this key attribute will assume:
	//
	//    * HASH - partition key
	//
	//    * RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	// "hash attribute" derives from DynamoDB' usage of an internal hash function
	// to evenly distribute data items across partitions, based on their partition
	// key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	// attribute" derives from the way DynamoDB stores items with the same partition
	// key physically close together, in sorted order by the sort key value.
	//
	// KeyType is a required field
	KeyType KeyType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s KeySchemaElement) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s KeySchemaElement) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *KeySchemaElement) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "KeySchemaElement"}

	if s.AttributeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeName"))
	}
	if s.AttributeName != nil && len(*s.AttributeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributeName", 1))
	}
	if len(s.KeyType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("KeyType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents a set of primary keys and, for each key, the attributes to retrieve
// from the table.
//
// For each primary key, you must provide all of the key attributes. For example,
// with a simple primary key, you only need to provide the partition key. For
// a composite primary key, you must provide both the partition key and the
// sort key.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/KeysAndAttributes
type KeysAndAttributes struct {
	_ struct{} `type:"structure"`

	// This is a legacy parameter. Use ProjectionExpression instead. For more information,
	// see Legacy Conditional Parameters (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html)
	// in the Amazon DynamoDB Developer Guide.
	AttributesToGet []string `min:"1" type:"list"`

	// The consistency of a read operation. If set to true, then a strongly consistent
	// read is used; otherwise, an eventually consistent read is used.
	ConsistentRead *bool `type:"boolean"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//    * To access an attribute whose name conflicts with a DynamoDB reserved
	//    word.
	//
	//    * To create a placeholder for repeating occurrences of an attribute name
	//    in an expression.
	//
	//    * To prevent special characters in an attribute name from being misinterpreted
	//    in an expression.
	//
	// Use the # character in an expression to dereference an attribute name. For
	// example, consider the following attribute name:
	//
	//    * Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot be
	// used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	//    * {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	//    * #P = :val
	//
	// Tokens that begin with the : character are expression attribute values, which
	// are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]string `type:"map"`

	// The primary key attribute values that define the items and the attributes
	// associated with the items.
	//
	// Keys is a required field
	Keys []map[string]AttributeValue `min:"1" type:"list" required:"true"`

	// A string that identifies one or more attributes to retrieve from the table.
	// These attributes can include scalars, sets, or elements of a JSON document.
	// The attributes in the ProjectionExpression must be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ProjectionExpression *string `type:"string"`
}

// String returns the string representation
func (s KeysAndAttributes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s KeysAndAttributes) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *KeysAndAttributes) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "KeysAndAttributes"}
	if s.AttributesToGet != nil && len(s.AttributesToGet) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributesToGet", 1))
	}

	if s.Keys == nil {
		invalidParams.Add(aws.NewErrParamRequired("Keys"))
	}
	if s.Keys != nil && len(s.Keys) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Keys", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListBackupsInput
type ListBackupsInput struct {
	_ struct{} `type:"structure"`

	// The backups from the table specified by BackupType are listed.
	//
	// Where BackupType can be:
	//
	//    * USER - On-demand backup created by you.
	//
	//    * SYSTEM - On-demand backup automatically created by DynamoDB.
	//
	//    * ALL - All types of on-demand backups (USER and SYSTEM).
	BackupType BackupTypeFilter `type:"string" enum:"true"`

	// LastEvaluatedBackupArn is the ARN of the backup last evaluated when the current
	// page of results was returned, inclusive of the current page of results. This
	// value may be specified as the ExclusiveStartBackupArn of a new ListBackups
	// operation in order to fetch the next page of results.
	ExclusiveStartBackupArn *string `min:"37" type:"string"`

	// Maximum number of backups to return at once.
	Limit *int64 `min:"1" type:"integer"`

	// The backups from the table specified by TableName are listed.
	TableName *string `min:"3" type:"string"`

	// Only backups created after this time are listed. TimeRangeLowerBound is inclusive.
	TimeRangeLowerBound *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Only backups created before this time are listed. TimeRangeUpperBound is
	// exclusive.
	TimeRangeUpperBound *time.Time `type:"timestamp" timestampFormat:"unix"`
}

// String returns the string representation
func (s ListBackupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBackupsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBackupsInput"}
	if s.ExclusiveStartBackupArn != nil && len(*s.ExclusiveStartBackupArn) < 37 {
		invalidParams.Add(aws.NewErrParamMinLen("ExclusiveStartBackupArn", 37))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListBackupsOutput
type ListBackupsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// List of BackupSummary objects.
	BackupSummaries []BackupSummary `type:"list"`

	// The ARN of the backup last evaluated when the current page of results was
	// returned, inclusive of the current page of results. This value may be specified
	// as the ExclusiveStartBackupArn of a new ListBackups operation in order to
	// fetch the next page of results.
	//
	// If LastEvaluatedBackupArn is empty, then the last page of results has been
	// processed and there are no more results to be retrieved.
	//
	// If LastEvaluatedBackupArn is not empty, this may or may not indicate there
	// is more data to be returned. All results are guaranteed to have been returned
	// if and only if no value for LastEvaluatedBackupArn is returned.
	LastEvaluatedBackupArn *string `min:"37" type:"string"`
}

// String returns the string representation
func (s ListBackupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBackupsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBackupsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListGlobalTablesInput
type ListGlobalTablesInput struct {
	_ struct{} `type:"structure"`

	// The first global table name that this operation will evaluate.
	ExclusiveStartGlobalTableName *string `min:"3" type:"string"`

	// The maximum number of table names to return.
	Limit *int64 `min:"1" type:"integer"`

	// Lists the global tables in a specific region.
	RegionName *string `type:"string"`
}

// String returns the string representation
func (s ListGlobalTablesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListGlobalTablesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListGlobalTablesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListGlobalTablesInput"}
	if s.ExclusiveStartGlobalTableName != nil && len(*s.ExclusiveStartGlobalTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("ExclusiveStartGlobalTableName", 3))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListGlobalTablesOutput
type ListGlobalTablesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// List of global table names.
	GlobalTables []GlobalTable `type:"list"`

	// Last evaluated global table name.
	LastEvaluatedGlobalTableName *string `min:"3" type:"string"`
}

// String returns the string representation
func (s ListGlobalTablesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListGlobalTablesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListGlobalTablesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input of a ListTables operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTablesInput
type ListTablesInput struct {
	_ struct{} `type:"structure"`

	// The first table name that this operation will evaluate. Use the value that
	// was returned for LastEvaluatedTableName in a previous operation, so that
	// you can obtain the next page of results.
	ExclusiveStartTableName *string `min:"3" type:"string"`

	// A maximum number of table names to return. If this parameter is not specified,
	// the limit is 100.
	Limit *int64 `min:"1" type:"integer"`
}

// String returns the string representation
func (s ListTablesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTablesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTablesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTablesInput"}
	if s.ExclusiveStartTableName != nil && len(*s.ExclusiveStartTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("ExclusiveStartTableName", 3))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a ListTables operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTablesOutput
type ListTablesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The name of the last table in the current page of results. Use this value
	// as the ExclusiveStartTableName in a new request to obtain the next page of
	// results, until all the table names are returned.
	//
	// If you do not receive a LastEvaluatedTableName value in the response, this
	// means that there are no more table names to be retrieved.
	LastEvaluatedTableName *string `min:"3" type:"string"`

	// The names of the tables associated with the current account at the current
	// endpoint. The maximum size of this array is 100.
	//
	// If LastEvaluatedTableName also appears in the output, you can use this value
	// as the ExclusiveStartTableName parameter in a subsequent ListTables request
	// and obtain the next page of results.
	TableNames []string `type:"list"`
}

// String returns the string representation
func (s ListTablesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTablesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTablesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTagsOfResourceInput
type ListTagsOfResourceInput struct {
	_ struct{} `type:"structure"`

	// An optional string that, if supplied, must be copied from the output of a
	// previous call to ListTagOfResource. When provided in this manner, this API
	// fetches the next page of results.
	NextToken *string `type:"string"`

	// The Amazon DynamoDB resource with tags to be listed. This value is an Amazon
	// Resource Name (ARN).
	//
	// ResourceArn is a required field
	ResourceArn *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTagsOfResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsOfResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsOfResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTagsOfResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}
	if s.ResourceArn != nil && len(*s.ResourceArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceArn", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ListTagsOfResourceOutput
type ListTagsOfResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If this value is returned, there are additional results to be displayed.
	// To retrieve them, call ListTagsOfResource again, with NextToken set to this
	// value.
	NextToken *string `type:"string"`

	// The tags currently associated with the Amazon DynamoDB resource.
	Tags []Tag `type:"list"`
}

// String returns the string representation
func (s ListTagsOfResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsOfResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTagsOfResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the properties of a local secondary index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/LocalSecondaryIndex
type LocalSecondaryIndex struct {
	_ struct{} `type:"structure"`

	// The name of the local secondary index. The name must be unique among all
	// other indexes on this table.
	//
	// IndexName is a required field
	IndexName *string `min:"3" type:"string" required:"true"`

	// The complete key schema for the local secondary index, consisting of one
	// or more pairs of attribute names and key types:
	//
	//    * HASH - partition key
	//
	//    * RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	// "hash attribute" derives from DynamoDB' usage of an internal hash function
	// to evenly distribute data items across partitions, based on their partition
	// key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	// attribute" derives from the way DynamoDB stores items with the same partition
	// key physically close together, in sorted order by the sort key value.
	//
	// KeySchema is a required field
	KeySchema []KeySchemaElement `min:"1" type:"list" required:"true"`

	// Represents attributes that are copied (projected) from the table into the
	// local secondary index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected.
	//
	// Projection is a required field
	Projection *Projection `type:"structure" required:"true"`
}

// String returns the string representation
func (s LocalSecondaryIndex) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LocalSecondaryIndex) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LocalSecondaryIndex) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LocalSecondaryIndex"}

	if s.IndexName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexName"))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}

	if s.KeySchema == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeySchema"))
	}
	if s.KeySchema != nil && len(s.KeySchema) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("KeySchema", 1))
	}

	if s.Projection == nil {
		invalidParams.Add(aws.NewErrParamRequired("Projection"))
	}
	if s.KeySchema != nil {
		for i, v := range s.KeySchema {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "KeySchema", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.Projection != nil {
		if err := s.Projection.Validate(); err != nil {
			invalidParams.AddNested("Projection", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the properties of a local secondary index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/LocalSecondaryIndexDescription
type LocalSecondaryIndexDescription struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) that uniquely identifies the index.
	IndexArn *string `type:"string"`

	// Represents the name of the local secondary index.
	IndexName *string `min:"3" type:"string"`

	// The total size of the specified index, in bytes. DynamoDB updates this value
	// approximately every six hours. Recent changes might not be reflected in this
	// value.
	IndexSizeBytes *int64 `type:"long"`

	// The number of items in the specified index. DynamoDB updates this value approximately
	// every six hours. Recent changes might not be reflected in this value.
	ItemCount *int64 `type:"long"`

	// The complete key schema for the local secondary index, consisting of one
	// or more pairs of attribute names and key types:
	//
	//    * HASH - partition key
	//
	//    * RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	// "hash attribute" derives from DynamoDB' usage of an internal hash function
	// to evenly distribute data items across partitions, based on their partition
	// key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	// attribute" derives from the way DynamoDB stores items with the same partition
	// key physically close together, in sorted order by the sort key value.
	KeySchema []KeySchemaElement `min:"1" type:"list"`

	// Represents attributes that are copied (projected) from the table into the
	// global secondary index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected.
	Projection *Projection `type:"structure"`
}

// String returns the string representation
func (s LocalSecondaryIndexDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LocalSecondaryIndexDescription) GoString() string {
	return s.String()
}

// Represents the properties of a local secondary index for the table when the
// backup was created.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/LocalSecondaryIndexInfo
type LocalSecondaryIndexInfo struct {
	_ struct{} `type:"structure"`

	// Represents the name of the local secondary index.
	IndexName *string `min:"3" type:"string"`

	// The complete key schema for a local secondary index, which consists of one
	// or more pairs of attribute names and key types:
	//
	//    * HASH - partition key
	//
	//    * RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	// "hash attribute" derives from DynamoDB' usage of an internal hash function
	// to evenly distribute data items across partitions, based on their partition
	// key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	// attribute" derives from the way DynamoDB stores items with the same partition
	// key physically close together, in sorted order by the sort key value.
	KeySchema []KeySchemaElement `min:"1" type:"list"`

	// Represents attributes that are copied (projected) from the table into the
	// global secondary index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected.
	Projection *Projection `type:"structure"`
}

// String returns the string representation
func (s LocalSecondaryIndexInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LocalSecondaryIndexInfo) GoString() string {
	return s.String()
}

// The description of the point in time settings applied to the table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/PointInTimeRecoveryDescription
type PointInTimeRecoveryDescription struct {
	_ struct{} `type:"structure"`

	// Specifies the earliest point in time you can restore your table to. It You
	// can restore your table to any point in time during the last 35 days.
	EarliestRestorableDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// LatestRestorableDateTime is typically 5 minutes before the current time.
	LatestRestorableDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The current state of point in time recovery:
	//
	//    * ENABLING - Point in time recovery is being enabled.
	//
	//    * ENABLED - Point in time recovery is enabled.
	//
	//    * DISABLED - Point in time recovery is disabled.
	PointInTimeRecoveryStatus PointInTimeRecoveryStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s PointInTimeRecoveryDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PointInTimeRecoveryDescription) GoString() string {
	return s.String()
}

// Represents the settings used to enable point in time recovery.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/PointInTimeRecoverySpecification
type PointInTimeRecoverySpecification struct {
	_ struct{} `type:"structure"`

	// Indicates whether point in time recovery is enabled (true) or disabled (false)
	// on the table.
	//
	// PointInTimeRecoveryEnabled is a required field
	PointInTimeRecoveryEnabled *bool `type:"boolean" required:"true"`
}

// String returns the string representation
func (s PointInTimeRecoverySpecification) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PointInTimeRecoverySpecification) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PointInTimeRecoverySpecification) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PointInTimeRecoverySpecification"}

	if s.PointInTimeRecoveryEnabled == nil {
		invalidParams.Add(aws.NewErrParamRequired("PointInTimeRecoveryEnabled"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents attributes that are copied (projected) from the table into an
// index. These are in addition to the primary key attributes and index key
// attributes, which are automatically projected.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Projection
type Projection struct {
	_ struct{} `type:"structure"`

	// Represents the non-key attribute names which will be projected into the index.
	//
	// For local secondary indexes, the total count of NonKeyAttributes summed across
	// all of the local secondary indexes, must not exceed 20. If you project the
	// same attribute into two different indexes, this counts as two distinct attributes
	// when determining the total.
	NonKeyAttributes []string `min:"1" type:"list"`

	// The set of attributes that are projected into the index:
	//
	//    * KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	//    * INCLUDE - Only the specified table attributes are projected into the
	//    index. The list of projected attributes are in NonKeyAttributes.
	//
	//    * ALL - All of the table attributes are projected into the index.
	ProjectionType ProjectionType `type:"string" enum:"true"`
}

// String returns the string representation
func (s Projection) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Projection) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Projection) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Projection"}
	if s.NonKeyAttributes != nil && len(s.NonKeyAttributes) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("NonKeyAttributes", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the provisioned throughput settings for a specified table or index.
// The settings can be modified using the UpdateTable operation.
//
// For current minimum and maximum provisioned throughput values, see Limits
// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
// in the Amazon DynamoDB Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ProvisionedThroughput
type ProvisionedThroughput struct {
	_ struct{} `type:"structure"`

	// The maximum number of strongly consistent reads consumed per second before
	// DynamoDB returns a ThrottlingException. For more information, see Specifying
	// Read and Write Requirements (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput)
	// in the Amazon DynamoDB Developer Guide.
	//
	// If read/write capacity mode is PAY_PER_REQUEST the value is set to 0.
	//
	// ReadCapacityUnits is a required field
	ReadCapacityUnits *int64 `min:"1" type:"long" required:"true"`

	// The maximum number of writes consumed per second before DynamoDB returns
	// a ThrottlingException. For more information, see Specifying Read and Write
	// Requirements (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput)
	// in the Amazon DynamoDB Developer Guide.
	//
	// If read/write capacity mode is PAY_PER_REQUEST the value is set to 0.
	//
	// WriteCapacityUnits is a required field
	WriteCapacityUnits *int64 `min:"1" type:"long" required:"true"`
}

// String returns the string representation
func (s ProvisionedThroughput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ProvisionedThroughput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ProvisionedThroughput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ProvisionedThroughput"}

	if s.ReadCapacityUnits == nil {
		invalidParams.Add(aws.NewErrParamRequired("ReadCapacityUnits"))
	}
	if s.ReadCapacityUnits != nil && *s.ReadCapacityUnits < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("ReadCapacityUnits", 1))
	}

	if s.WriteCapacityUnits == nil {
		invalidParams.Add(aws.NewErrParamRequired("WriteCapacityUnits"))
	}
	if s.WriteCapacityUnits != nil && *s.WriteCapacityUnits < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("WriteCapacityUnits", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the provisioned throughput settings for the table, consisting
// of read and write capacity units, along with data about increases and decreases.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ProvisionedThroughputDescription
type ProvisionedThroughputDescription struct {
	_ struct{} `type:"structure"`

	// The date and time of the last provisioned throughput decrease for this table.
	LastDecreaseDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The date and time of the last provisioned throughput increase for this table.
	LastIncreaseDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The number of provisioned throughput decreases for this table during this
	// UTC calendar day. For current maximums on provisioned throughput decreases,
	// see Limits (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	NumberOfDecreasesToday *int64 `min:"1" type:"long"`

	// The maximum number of strongly consistent reads consumed per second before
	// DynamoDB returns a ThrottlingException. Eventually consistent reads require
	// less effort than strongly consistent reads, so a setting of 50 ReadCapacityUnits
	// per second provides 100 eventually consistent ReadCapacityUnits per second.
	ReadCapacityUnits *int64 `type:"long"`

	// The maximum number of writes consumed per second before DynamoDB returns
	// a ThrottlingException.
	WriteCapacityUnits *int64 `type:"long"`
}

// String returns the string representation
func (s ProvisionedThroughputDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ProvisionedThroughputDescription) GoString() string {
	return s.String()
}

// Represents a request to perform a PutItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Put
type Put struct {
	_ struct{} `type:"structure"`

	// A condition that must be satisfied in order for a conditional update to succeed.
	ConditionExpression *string `type:"string"`

	// One or more substitution tokens for attribute names in an expression.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// A map of attribute name to attribute values, representing the primary key
	// of the item to be written by PutItem. All of the table's primary key attributes
	// must be specified, and their data types must match those of the table's key
	// schema. If any attributes are present in the item that are part of an index
	// key schema for the table, their types must match the index key schema.
	//
	// Item is a required field
	Item map[string]AttributeValue `type:"map" required:"true"`

	// Use ReturnValuesOnConditionCheckFailure to get the item attributes if the
	// Put condition fails. For ReturnValuesOnConditionCheckFailure, the valid values
	// are: NONE and ALL_OLD.
	ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure `type:"string" enum:"true"`

	// Name of the table in which to write the item.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s Put) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Put) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Put) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Put"}

	if s.Item == nil {
		invalidParams.Add(aws.NewErrParamRequired("Item"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the input of a PutItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/PutItemInput
type PutItemInput struct {
	_ struct{} `type:"structure"`

	// A condition that must be satisfied in order for a conditional PutItem operation
	// to succeed.
	//
	// An expression can contain any of the following:
	//
	//    * Functions: attribute_exists | attribute_not_exists | attribute_type
	//    | contains | begins_with | size
	//
	// These function names are case-sensitive.
	//
	//    * Comparison operators: = | <> | < | > | <= | >= | BETWEEN | IN
	//
	//    *  Logical operators: AND | OR | NOT
	//
	// For more information on condition expressions, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	ConditionExpression *string `type:"string"`

	// This is a legacy parameter. Use ConditionExpression instead. For more information,
	// see ConditionalOperator (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
	// in the Amazon DynamoDB Developer Guide.
	ConditionalOperator ConditionalOperator `type:"string" enum:"true"`

	// This is a legacy parameter. Use ConditionExpression instead. For more information,
	// see Expected (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html)
	// in the Amazon DynamoDB Developer Guide.
	Expected map[string]ExpectedAttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//    * To access an attribute whose name conflicts with a DynamoDB reserved
	//    word.
	//
	//    * To create a placeholder for repeating occurrences of an attribute name
	//    in an expression.
	//
	//    * To prevent special characters in an attribute name from being misinterpreted
	//    in an expression.
	//
	// Use the # character in an expression to dereference an attribute name. For
	// example, consider the following attribute name:
	//
	//    * Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot be
	// used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	//    * {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	//    * #P = :val
	//
	// Tokens that begin with the : character are expression attribute values, which
	// are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// A map of attribute name/value pairs, one for each attribute. Only the primary
	// key attributes are required; you can optionally provide other attribute name-value
	// pairs for the item.
	//
	// You must provide all of the attributes for the primary key. For example,
	// with a simple primary key, you only need to provide a value for the partition
	// key. For a composite primary key, you must provide both values for both the
	// partition key and the sort key.
	//
	// If you specify any attributes that are part of an index key, then the data
	// types for those attributes must match those of the schema in the table's
	// attribute definition.
	//
	// For more information about primary keys, see Primary Key (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModelPrimaryKey)
	// in the Amazon DynamoDB Developer Guide.
	//
	// Each element in the Item map is an AttributeValue object.
	//
	// Item is a required field
	Item map[string]AttributeValue `type:"map" required:"true"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// Determines whether item collection metrics are returned. If set to SIZE,
	// the response includes statistics about item collections, if any, that were
	// modified during the operation are returned in the response. If set to NONE
	// (the default), no statistics are returned.
	ReturnItemCollectionMetrics ReturnItemCollectionMetrics `type:"string" enum:"true"`

	// Use ReturnValues if you want to get the item attributes as they appeared
	// before they were updated with the PutItem request. For PutItem, the valid
	// values are:
	//
	//    * NONE - If ReturnValues is not specified, or if its value is NONE, then
	//    nothing is returned. (This setting is the default for ReturnValues.)
	//
	//    * ALL_OLD - If PutItem overwrote an attribute name-value pair, then the
	//    content of the old item is returned.
	//
	// The ReturnValues parameter is used by several DynamoDB operations; however,
	// PutItem does not recognize any values other than NONE or ALL_OLD.
	ReturnValues ReturnValue `type:"string" enum:"true"`

	// The name of the table to contain the item.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s PutItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutItemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutItemInput"}

	if s.Item == nil {
		invalidParams.Add(aws.NewErrParamRequired("Item"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a PutItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/PutItemOutput
type PutItemOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The attribute values as they appeared before the PutItem operation, but only
	// if ReturnValues is specified as ALL_OLD in the request. Each element consists
	// of an attribute name and an attribute value.
	Attributes map[string]AttributeValue `type:"map"`

	// The capacity units consumed by the PutItem operation. The data returned includes
	// the total provisioned throughput consumed, along with statistics for the
	// table and any indexes involved in the operation. ConsumedCapacity is only
	// returned if the ReturnConsumedCapacity parameter was specified. For more
	// information, see Provisioned Throughput (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// Information about item collections, if any, that were affected by the PutItem
	// operation. ItemCollectionMetrics is only returned if the ReturnItemCollectionMetrics
	// parameter was specified. If the table does not have any local secondary indexes,
	// this information is not returned in the response.
	//
	// Each ItemCollectionMetrics element consists of:
	//
	//    * ItemCollectionKey - The partition key value of the item collection.
	//    This is the same as the partition key value of the item itself.
	//
	//    * SizeEstimateRangeGB - An estimate of item collection size, in gigabytes.
	//    This value is a two-element array containing a lower bound and an upper
	//    bound for the estimate. The estimate includes the size of all the items
	//    in the table, plus the size of all attributes projected into all of the
	//    local secondary indexes on that table. Use this estimate to measure whether
	//    a local secondary index is approaching its size limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	//    precision or accuracy of the estimate.
	ItemCollectionMetrics *ItemCollectionMetrics `type:"structure"`
}

// String returns the string representation
func (s PutItemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutItemOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s PutItemOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents a request to perform a PutItem operation on an item.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/PutRequest
type PutRequest struct {
	_ struct{} `type:"structure"`

	// A map of attribute name to attribute values, representing the primary key
	// of an item to be processed by PutItem. All of the table's primary key attributes
	// must be specified, and their data types must match those of the table's key
	// schema. If any attributes are present in the item which are part of an index
	// key schema for the table, their types must match the index key schema.
	//
	// Item is a required field
	Item map[string]AttributeValue `type:"map" required:"true"`
}

// String returns the string representation
func (s PutRequest) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutRequest) GoString() string {
	return s.String()
}

// Represents the input of a Query operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/QueryInput
type QueryInput struct {
	_ struct{} `type:"structure"`

	// This is a legacy parameter. Use ProjectionExpression instead. For more information,
	// see AttributesToGet (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
	// in the Amazon DynamoDB Developer Guide.
	AttributesToGet []string `min:"1" type:"list"`

	// This is a legacy parameter. Use FilterExpression instead. For more information,
	// see ConditionalOperator (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
	// in the Amazon DynamoDB Developer Guide.
	ConditionalOperator ConditionalOperator `type:"string" enum:"true"`

	// Determines the read consistency model: If set to true, then the operation
	// uses strongly consistent reads; otherwise, the operation uses eventually
	// consistent reads.
	//
	// Strongly consistent reads are not supported on global secondary indexes.
	// If you query a global secondary index with ConsistentRead set to true, you
	// will receive a ValidationException.
	ConsistentRead *bool `type:"boolean"`

	// The primary key of the first item that this operation will evaluate. Use
	// the value that was returned for LastEvaluatedKey in the previous operation.
	//
	// The data type for ExclusiveStartKey must be String, Number or Binary. No
	// set data types are allowed.
	ExclusiveStartKey map[string]AttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//    * To access an attribute whose name conflicts with a DynamoDB reserved
	//    word.
	//
	//    * To create a placeholder for repeating occurrences of an attribute name
	//    in an expression.
	//
	//    * To prevent special characters in an attribute name from being misinterpreted
	//    in an expression.
	//
	// Use the # character in an expression to dereference an attribute name. For
	// example, consider the following attribute name:
	//
	//    * Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot be
	// used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	//    * {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	//    * #P = :val
	//
	// Tokens that begin with the : character are expression attribute values, which
	// are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// A string that contains conditions that DynamoDB applies after the Query operation,
	// but before the data is returned to you. Items that do not satisfy the FilterExpression
	// criteria are not returned.
	//
	// A FilterExpression does not allow key attributes. You cannot define a filter
	// expression based on a partition key or a sort key.
	//
	// A FilterExpression is applied after the items have already been read; the
	// process of filtering does not consume any additional read capacity units.
	//
	// For more information, see Filter Expressions (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults)
	// in the Amazon DynamoDB Developer Guide.
	FilterExpression *string `type:"string"`

	// The name of an index to query. This index can be any local secondary index
	// or global secondary index on the table. Note that if you use the IndexName
	// parameter, you must also provide TableName.
	IndexName *string `min:"3" type:"string"`

	// The condition that specifies the key value(s) for items to be retrieved by
	// the Query action.
	//
	// The condition must perform an equality test on a single partition key value.
	//
	// The condition can optionally perform one of several comparison tests on a
	// single sort key value. This allows Query to retrieve one item with a given
	// partition key value and sort key value, or several items that have the same
	// partition key value but different sort key values.
	//
	// The partition key equality test is required, and must be specified in the
	// following format:
	//
	// partitionKeyName=:partitionkeyval
	//
	// If you also want to provide a condition for the sort key, it must be combined
	// using AND with the condition for the sort key. Following is an example, using
	// the = comparison operator for the sort key:
	//
	// partitionKeyName=:partitionkeyvalANDsortKeyName=:sortkeyval
	//
	// Valid comparisons for the sort key condition are as follows:
	//
	//    * sortKeyName=:sortkeyval - true if the sort key value is equal to :sortkeyval.
	//
	//    * sortKeyName<:sortkeyval - true if the sort key value is less than :sortkeyval.
	//
	//    * sortKeyName<=:sortkeyval - true if the sort key value is less than or
	//    equal to :sortkeyval.
	//
	//    * sortKeyName>:sortkeyval - true if the sort key value is greater than
	//    :sortkeyval.
	//
	//    * sortKeyName>= :sortkeyval - true if the sort key value is greater than
	//    or equal to :sortkeyval.
	//
	//    * sortKeyNameBETWEEN:sortkeyval1AND:sortkeyval2 - true if the sort key
	//    value is greater than or equal to :sortkeyval1, and less than or equal
	//    to :sortkeyval2.
	//
	//    * begins_with (sortKeyName, :sortkeyval) - true if the sort key value
	//    begins with a particular operand. (You cannot use this function with a
	//    sort key that is of type Number.) Note that the function name begins_with
	//    is case-sensitive.
	//
	// Use the ExpressionAttributeValues parameter to replace tokens such as :partitionval
	// and :sortval with actual values at runtime.
	//
	// You can optionally use the ExpressionAttributeNames parameter to replace
	// the names of the partition key and sort key with placeholder tokens. This
	// option might be necessary if an attribute name conflicts with a DynamoDB
	// reserved word. For example, the following KeyConditionExpression parameter
	// causes an error because Size is a reserved word:
	//
	//    * Size = :myval
	//
	// To work around this, define a placeholder (such a #S) to represent the attribute
	// name Size. KeyConditionExpression then is as follows:
	//
	//    * #S = :myval
	//
	// For a list of reserved words, see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// For more information on ExpressionAttributeNames and ExpressionAttributeValues,
	// see Using Placeholders for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	KeyConditionExpression *string `type:"string"`

	// This is a legacy parameter. Use KeyConditionExpression instead. For more
	// information, see KeyConditions (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.KeyConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	KeyConditions map[string]Condition `type:"map"`

	// The maximum number of items to evaluate (not necessarily the number of matching
	// items). If DynamoDB processes the number of items up to the limit while processing
	// the results, it stops the operation and returns the matching values up to
	// that point, and a key in LastEvaluatedKey to apply in a subsequent operation,
	// so that you can pick up where you left off. Also, if the processed data set
	// size exceeds 1 MB before DynamoDB reaches this limit, it stops the operation
	// and returns the matching values up to the limit, and a key in LastEvaluatedKey
	// to apply in a subsequent operation to continue the operation. For more information,
	// see Query and Scan (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html)
	// in the Amazon DynamoDB Developer Guide.
	Limit *int64 `min:"1" type:"integer"`

	// A string that identifies one or more attributes to retrieve from the table.
	// These attributes can include scalars, sets, or elements of a JSON document.
	// The attributes in the expression must be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ProjectionExpression *string `type:"string"`

	// This is a legacy parameter. Use FilterExpression instead. For more information,
	// see QueryFilter (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.QueryFilter.html)
	// in the Amazon DynamoDB Developer Guide.
	QueryFilter map[string]Condition `type:"map"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// Specifies the order for index traversal: If true (default), the traversal
	// is performed in ascending order; if false, the traversal is performed in
	// descending order.
	//
	// Items with the same partition key value are stored in sorted order by sort
	// key. If the sort key data type is Number, the results are stored in numeric
	// order. For type String, the results are stored in order of UTF-8 bytes. For
	// type Binary, DynamoDB treats each byte of the binary data as unsigned.
	//
	// If ScanIndexForward is true, DynamoDB returns the results in the order in
	// which they are stored (by sort key value). This is the default behavior.
	// If ScanIndexForward is false, DynamoDB reads the results in reverse order
	// by sort key value, and then returns the results to the client.
	ScanIndexForward *bool `type:"boolean"`

	// The attributes to be returned in the result. You can retrieve all item attributes,
	// specific item attributes, the count of matching items, or in the case of
	// an index, some or all of the attributes projected into the index.
	//
	//    * ALL_ATTRIBUTES - Returns all of the item attributes from the specified
	//    table or index. If you query a local secondary index, then for each matching
	//    item in the index DynamoDB will fetch the entire item from the parent
	//    table. If the index is configured to project all item attributes, then
	//    all of the data can be obtained from the local secondary index, and no
	//    fetching is required.
	//
	//    * ALL_PROJECTED_ATTRIBUTES - Allowed only when querying an index. Retrieves
	//    all attributes that have been projected into the index. If the index is
	//    configured to project all attributes, this return value is equivalent
	//    to specifying ALL_ATTRIBUTES.
	//
	//    * COUNT - Returns the number of matching items, rather than the matching
	//    items themselves.
	//
	//    * SPECIFIC_ATTRIBUTES - Returns only the attributes listed in AttributesToGet.
	//    This return value is equivalent to specifying AttributesToGet without
	//    specifying any value for Select.
	//
	// If you query or scan a local secondary index and request only attributes
	//    that are projected into that index, the operation will read only the index
	//    and not the table. If any of the requested attributes are not projected
	//    into the local secondary index, DynamoDB will fetch each of these attributes
	//    from the parent table. This extra fetching incurs additional throughput
	//    cost and latency.
	//
	// If you query or scan a global secondary index, you can only request attributes
	//    that are projected into the index. Global secondary index queries cannot
	//    fetch attributes from the parent table.
	//
	// If neither Select nor AttributesToGet are specified, DynamoDB defaults to
	// ALL_ATTRIBUTES when accessing a table, and ALL_PROJECTED_ATTRIBUTES when
	// accessing an index. You cannot use both Select and AttributesToGet together
	// in a single request, unless the value for Select is SPECIFIC_ATTRIBUTES.
	// (This usage is equivalent to specifying AttributesToGet without any value
	// for Select.)
	//
	// If you use the ProjectionExpression parameter, then the value for Select
	// can only be SPECIFIC_ATTRIBUTES. Any other value for Select will return an
	// error.
	Select Select `type:"string" enum:"true"`

	// The name of the table containing the requested items.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s QueryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s QueryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *QueryInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "QueryInput"}
	if s.AttributesToGet != nil && len(s.AttributesToGet) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributesToGet", 1))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}
	if s.KeyConditions != nil {
		for i, v := range s.KeyConditions {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "KeyConditions", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.QueryFilter != nil {
		for i, v := range s.QueryFilter {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "QueryFilter", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a Query operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/QueryOutput
type QueryOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The capacity units consumed by the Query operation. The data returned includes
	// the total provisioned throughput consumed, along with statistics for the
	// table and any indexes involved in the operation. ConsumedCapacity is only
	// returned if the ReturnConsumedCapacity parameter was specified For more information,
	// see Provisioned Throughput (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// The number of items in the response.
	//
	// If you used a QueryFilter in the request, then Count is the number of items
	// returned after the filter was applied, and ScannedCount is the number of
	// matching items before the filter was applied.
	//
	// If you did not use a filter in the request, then Count and ScannedCount are
	// the same.
	Count *int64 `type:"integer"`

	// An array of item attributes that match the query criteria. Each element in
	// this array consists of an attribute name and the value for that attribute.
	Items []map[string]AttributeValue `type:"list"`

	// The primary key of the item where the operation stopped, inclusive of the
	// previous result set. Use this value to start a new operation, excluding this
	// value in the new request.
	//
	// If LastEvaluatedKey is empty, then the "last page" of results has been processed
	// and there is no more data to be retrieved.
	//
	// If LastEvaluatedKey is not empty, it does not necessarily mean that there
	// is more data in the result set. The only way to know when you have reached
	// the end of the result set is when LastEvaluatedKey is empty.
	LastEvaluatedKey map[string]AttributeValue `type:"map"`

	// The number of items evaluated, before any QueryFilter is applied. A high
	// ScannedCount value with few, or no, Count results indicates an inefficient
	// Query operation. For more information, see Count and ScannedCount (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count)
	// in the Amazon DynamoDB Developer Guide.
	//
	// If you did not use a filter in the request, then ScannedCount is the same
	// as Count.
	ScannedCount *int64 `type:"integer"`
}

// String returns the string representation
func (s QueryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s QueryOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s QueryOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the properties of a replica.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Replica
type Replica struct {
	_ struct{} `type:"structure"`

	// The region where the replica needs to be created.
	RegionName *string `type:"string"`
}

// String returns the string representation
func (s Replica) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Replica) GoString() string {
	return s.String()
}

// Contains the details of the replica.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ReplicaDescription
type ReplicaDescription struct {
	_ struct{} `type:"structure"`

	// The name of the region.
	RegionName *string `type:"string"`
}

// String returns the string representation
func (s ReplicaDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplicaDescription) GoString() string {
	return s.String()
}

// Represents the properties of a global secondary index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ReplicaGlobalSecondaryIndexSettingsDescription
type ReplicaGlobalSecondaryIndexSettingsDescription struct {
	_ struct{} `type:"structure"`

	// The name of the global secondary index. The name must be unique among all
	// other indexes on this table.
	//
	// IndexName is a required field
	IndexName *string `min:"3" type:"string" required:"true"`

	// The current status of the global secondary index:
	//
	//    * CREATING - The global secondary index is being created.
	//
	//    * UPDATING - The global secondary index is being updated.
	//
	//    * DELETING - The global secondary index is being deleted.
	//
	//    * ACTIVE - The global secondary index is ready for use.
	IndexStatus IndexStatus `type:"string" enum:"true"`

	// Autoscaling settings for a global secondary index replica's read capacity
	// units.
	ProvisionedReadCapacityAutoScalingSettings *AutoScalingSettingsDescription `type:"structure"`

	// The maximum number of strongly consistent reads consumed per second before
	// DynamoDB returns a ThrottlingException.
	ProvisionedReadCapacityUnits *int64 `min:"1" type:"long"`

	// AutoScaling settings for a global secondary index replica's write capacity
	// units.
	ProvisionedWriteCapacityAutoScalingSettings *AutoScalingSettingsDescription `type:"structure"`

	// The maximum number of writes consumed per second before DynamoDB returns
	// a ThrottlingException.
	ProvisionedWriteCapacityUnits *int64 `min:"1" type:"long"`
}

// String returns the string representation
func (s ReplicaGlobalSecondaryIndexSettingsDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplicaGlobalSecondaryIndexSettingsDescription) GoString() string {
	return s.String()
}

// Represents the settings of a global secondary index for a global table that
// will be modified.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ReplicaGlobalSecondaryIndexSettingsUpdate
type ReplicaGlobalSecondaryIndexSettingsUpdate struct {
	_ struct{} `type:"structure"`

	// The name of the global secondary index. The name must be unique among all
	// other indexes on this table.
	//
	// IndexName is a required field
	IndexName *string `min:"3" type:"string" required:"true"`

	// Autoscaling settings for managing a global secondary index replica's read
	// capacity units.
	ProvisionedReadCapacityAutoScalingSettingsUpdate *AutoScalingSettingsUpdate `type:"structure"`

	// The maximum number of strongly consistent reads consumed per second before
	// DynamoDB returns a ThrottlingException.
	ProvisionedReadCapacityUnits *int64 `min:"1" type:"long"`
}

// String returns the string representation
func (s ReplicaGlobalSecondaryIndexSettingsUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplicaGlobalSecondaryIndexSettingsUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplicaGlobalSecondaryIndexSettingsUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ReplicaGlobalSecondaryIndexSettingsUpdate"}

	if s.IndexName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexName"))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}
	if s.ProvisionedReadCapacityUnits != nil && *s.ProvisionedReadCapacityUnits < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("ProvisionedReadCapacityUnits", 1))
	}
	if s.ProvisionedReadCapacityAutoScalingSettingsUpdate != nil {
		if err := s.ProvisionedReadCapacityAutoScalingSettingsUpdate.Validate(); err != nil {
			invalidParams.AddNested("ProvisionedReadCapacityAutoScalingSettingsUpdate", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the properties of a replica.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ReplicaSettingsDescription
type ReplicaSettingsDescription struct {
	_ struct{} `type:"structure"`

	// The region name of the replica.
	//
	// RegionName is a required field
	RegionName *string `type:"string" required:"true"`

	// The read/write capacity mode of the replica.
	ReplicaBillingModeSummary *BillingModeSummary `type:"structure"`

	// Replica global secondary index settings for the global table.
	ReplicaGlobalSecondaryIndexSettings []ReplicaGlobalSecondaryIndexSettingsDescription `type:"list"`

	// Autoscaling settings for a global table replica's read capacity units.
	ReplicaProvisionedReadCapacityAutoScalingSettings *AutoScalingSettingsDescription `type:"structure"`

	// The maximum number of strongly consistent reads consumed per second before
	// DynamoDB returns a ThrottlingException. For more information, see Specifying
	// Read and Write Requirements (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput)
	// in the Amazon DynamoDB Developer Guide.
	ReplicaProvisionedReadCapacityUnits *int64 `type:"long"`

	// AutoScaling settings for a global table replica's write capacity units.
	ReplicaProvisionedWriteCapacityAutoScalingSettings *AutoScalingSettingsDescription `type:"structure"`

	// The maximum number of writes consumed per second before DynamoDB returns
	// a ThrottlingException. For more information, see Specifying Read and Write
	// Requirements (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput)
	// in the Amazon DynamoDB Developer Guide.
	ReplicaProvisionedWriteCapacityUnits *int64 `type:"long"`

	// The current state of the region:
	//
	//    * CREATING - The region is being created.
	//
	//    * UPDATING - The region is being updated.
	//
	//    * DELETING - The region is being deleted.
	//
	//    * ACTIVE - The region is ready for use.
	ReplicaStatus ReplicaStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s ReplicaSettingsDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplicaSettingsDescription) GoString() string {
	return s.String()
}

// Represents the settings for a global table in a region that will be modified.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ReplicaSettingsUpdate
type ReplicaSettingsUpdate struct {
	_ struct{} `type:"structure"`

	// The region of the replica to be added.
	//
	// RegionName is a required field
	RegionName *string `type:"string" required:"true"`

	// Represents the settings of a global secondary index for a global table that
	// will be modified.
	ReplicaGlobalSecondaryIndexSettingsUpdate []ReplicaGlobalSecondaryIndexSettingsUpdate `min:"1" type:"list"`

	// Autoscaling settings for managing a global table replica's read capacity
	// units.
	ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate *AutoScalingSettingsUpdate `type:"structure"`

	// The maximum number of strongly consistent reads consumed per second before
	// DynamoDB returns a ThrottlingException. For more information, see Specifying
	// Read and Write Requirements (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput)
	// in the Amazon DynamoDB Developer Guide.
	ReplicaProvisionedReadCapacityUnits *int64 `min:"1" type:"long"`
}

// String returns the string representation
func (s ReplicaSettingsUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplicaSettingsUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplicaSettingsUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ReplicaSettingsUpdate"}

	if s.RegionName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RegionName"))
	}
	if s.ReplicaGlobalSecondaryIndexSettingsUpdate != nil && len(s.ReplicaGlobalSecondaryIndexSettingsUpdate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ReplicaGlobalSecondaryIndexSettingsUpdate", 1))
	}
	if s.ReplicaProvisionedReadCapacityUnits != nil && *s.ReplicaProvisionedReadCapacityUnits < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("ReplicaProvisionedReadCapacityUnits", 1))
	}
	if s.ReplicaGlobalSecondaryIndexSettingsUpdate != nil {
		for i, v := range s.ReplicaGlobalSecondaryIndexSettingsUpdate {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ReplicaGlobalSecondaryIndexSettingsUpdate", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate != nil {
		if err := s.ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate.Validate(); err != nil {
			invalidParams.AddNested("ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents one of the following:
//
//    * A new replica to be added to an existing global table.
//
//    * New parameters for an existing replica.
//
//    * An existing replica to be removed from an existing global table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ReplicaUpdate
type ReplicaUpdate struct {
	_ struct{} `type:"structure"`

	// The parameters required for creating a replica on an existing global table.
	Create *CreateReplicaAction `type:"structure"`

	// The name of the existing replica to be removed.
	Delete *DeleteReplicaAction `type:"structure"`
}

// String returns the string representation
func (s ReplicaUpdate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplicaUpdate) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplicaUpdate) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ReplicaUpdate"}
	if s.Create != nil {
		if err := s.Create.Validate(); err != nil {
			invalidParams.AddNested("Create", err.(aws.ErrInvalidParams))
		}
	}
	if s.Delete != nil {
		if err := s.Delete.Validate(); err != nil {
			invalidParams.AddNested("Delete", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Contains details for the restore.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreSummary
type RestoreSummary struct {
	_ struct{} `type:"structure"`

	// Point in time or source backup time.
	//
	// RestoreDateTime is a required field
	RestoreDateTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Indicates if a restore is in progress or not.
	//
	// RestoreInProgress is a required field
	RestoreInProgress *bool `type:"boolean" required:"true"`

	// ARN of the backup from which the table was restored.
	SourceBackupArn *string `min:"37" type:"string"`

	// ARN of the source table of the backup that is being restored.
	SourceTableArn *string `type:"string"`
}

// String returns the string representation
func (s RestoreSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RestoreSummary) GoString() string {
	return s.String()
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableFromBackupInput
type RestoreTableFromBackupInput struct {
	_ struct{} `type:"structure"`

	// The ARN associated with the backup.
	//
	// BackupArn is a required field
	BackupArn *string `min:"37" type:"string" required:"true"`

	// The name of the new table to which the backup must be restored.
	//
	// TargetTableName is a required field
	TargetTableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s RestoreTableFromBackupInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RestoreTableFromBackupInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RestoreTableFromBackupInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RestoreTableFromBackupInput"}

	if s.BackupArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("BackupArn"))
	}
	if s.BackupArn != nil && len(*s.BackupArn) < 37 {
		invalidParams.Add(aws.NewErrParamMinLen("BackupArn", 37))
	}

	if s.TargetTableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetTableName"))
	}
	if s.TargetTableName != nil && len(*s.TargetTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TargetTableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableFromBackupOutput
type RestoreTableFromBackupOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The description of the table created from an existing backup.
	TableDescription *TableDescription `type:"structure"`
}

// String returns the string representation
func (s RestoreTableFromBackupOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RestoreTableFromBackupOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RestoreTableFromBackupOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableToPointInTimeInput
type RestoreTableToPointInTimeInput struct {
	_ struct{} `type:"structure"`

	// Time in the past to restore the table to.
	RestoreDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// Name of the source table that is being restored.
	//
	// SourceTableName is a required field
	SourceTableName *string `min:"3" type:"string" required:"true"`

	// The name of the new table to which it must be restored to.
	//
	// TargetTableName is a required field
	TargetTableName *string `min:"3" type:"string" required:"true"`

	// Restore the table to the latest possible time. LatestRestorableDateTime is
	// typically 5 minutes before the current time.
	UseLatestRestorableTime *bool `type:"boolean"`
}

// String returns the string representation
func (s RestoreTableToPointInTimeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RestoreTableToPointInTimeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RestoreTableToPointInTimeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RestoreTableToPointInTimeInput"}

	if s.SourceTableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("SourceTableName"))
	}
	if s.SourceTableName != nil && len(*s.SourceTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("SourceTableName", 3))
	}

	if s.TargetTableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetTableName"))
	}
	if s.TargetTableName != nil && len(*s.TargetTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TargetTableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/RestoreTableToPointInTimeOutput
type RestoreTableToPointInTimeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Represents the properties of a table.
	TableDescription *TableDescription `type:"structure"`
}

// String returns the string representation
func (s RestoreTableToPointInTimeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RestoreTableToPointInTimeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RestoreTableToPointInTimeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// The description of the server-side encryption status on the specified table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/SSEDescription
type SSEDescription struct {
	_ struct{} `type:"structure"`

	// The KMS master key ARN used for the KMS encryption.
	KMSMasterKeyArn *string `type:"string"`

	// Server-side encryption type:
	//
	//    * AES256 - Server-side encryption which uses the AES256 algorithm (not
	//    applicable).
	//
	//    * KMS - Server-side encryption which uses AWS Key Management Service.
	//    Key is stored in your account and is managed by AWS KMS (KMS charges apply).
	SSEType SSEType `type:"string" enum:"true"`

	// The current state of server-side encryption:
	//
	//    * ENABLING - Server-side encryption is being enabled.
	//
	//    * ENABLED - Server-side encryption is enabled.
	//
	//    * DISABLING - Server-side encryption is being disabled.
	//
	//    * DISABLED - Server-side encryption is disabled.
	//
	//    * UPDATING - Server-side encryption is being updated.
	Status SSEStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s SSEDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SSEDescription) GoString() string {
	return s.String()
}

// Represents the settings used to enable server-side encryption.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/SSESpecification
type SSESpecification struct {
	_ struct{} `type:"structure"`

	// Indicates whether server-side encryption is enabled (true) or disabled (false)
	// on the table. If enabled (true), server-side encryption type is set to KMS.
	// If disabled (false) or not specified, server-side encryption is set to AWS
	// owned CMK.
	Enabled *bool `type:"boolean"`

	// The KMS Master Key (CMK) which should be used for the KMS encryption. To
	// specify a CMK, use its key ID, Amazon Resource Name (ARN), alias name, or
	// alias ARN. Note that you should only provide this parameter if the key is
	// different from the default DynamoDB KMS Master Key alias/aws/dynamodb.
	KMSMasterKeyId *string `type:"string"`

	// Server-side encryption type:
	//
	//    * AES256 - Server-side encryption which uses the AES256 algorithm (not
	//    applicable).
	//
	//    * KMS - Server-side encryption which uses AWS Key Management Service.
	//    Key is stored in your account and is managed by AWS KMS (KMS charges apply).
	SSEType SSEType `type:"string" enum:"true"`
}

// String returns the string representation
func (s SSESpecification) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SSESpecification) GoString() string {
	return s.String()
}

// Represents the input of a Scan operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ScanInput
type ScanInput struct {
	_ struct{} `type:"structure"`

	// This is a legacy parameter. Use ProjectionExpression instead. For more information,
	// see AttributesToGet (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
	// in the Amazon DynamoDB Developer Guide.
	AttributesToGet []string `min:"1" type:"list"`

	// This is a legacy parameter. Use FilterExpression instead. For more information,
	// see ConditionalOperator (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
	// in the Amazon DynamoDB Developer Guide.
	ConditionalOperator ConditionalOperator `type:"string" enum:"true"`

	// A Boolean value that determines the read consistency model during the scan:
	//
	//    * If ConsistentRead is false, then the data returned from Scan might not
	//    contain the results from other recently completed write operations (PutItem,
	//    UpdateItem or DeleteItem).
	//
	//    * If ConsistentRead is true, then all of the write operations that completed
	//    before the Scan began are guaranteed to be contained in the Scan response.
	//
	// The default setting for ConsistentRead is false.
	//
	// The ConsistentRead parameter is not supported on global secondary indexes.
	// If you scan a global secondary index with ConsistentRead set to true, you
	// will receive a ValidationException.
	ConsistentRead *bool `type:"boolean"`

	// The primary key of the first item that this operation will evaluate. Use
	// the value that was returned for LastEvaluatedKey in the previous operation.
	//
	// The data type for ExclusiveStartKey must be String, Number or Binary. No
	// set data types are allowed.
	//
	// In a parallel scan, a Scan request that includes ExclusiveStartKey must specify
	// the same segment whose previous Scan returned the corresponding value of
	// LastEvaluatedKey.
	ExclusiveStartKey map[string]AttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//    * To access an attribute whose name conflicts with a DynamoDB reserved
	//    word.
	//
	//    * To create a placeholder for repeating occurrences of an attribute name
	//    in an expression.
	//
	//    * To prevent special characters in an attribute name from being misinterpreted
	//    in an expression.
	//
	// Use the # character in an expression to dereference an attribute name. For
	// example, consider the following attribute name:
	//
	//    * Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot be
	// used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	//    * {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	//    * #P = :val
	//
	// Tokens that begin with the : character are expression attribute values, which
	// are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// A string that contains conditions that DynamoDB applies after the Scan operation,
	// but before the data is returned to you. Items that do not satisfy the FilterExpression
	// criteria are not returned.
	//
	// A FilterExpression is applied after the items have already been read; the
	// process of filtering does not consume any additional read capacity units.
	//
	// For more information, see Filter Expressions (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults)
	// in the Amazon DynamoDB Developer Guide.
	FilterExpression *string `type:"string"`

	// The name of a secondary index to scan. This index can be any local secondary
	// index or global secondary index. Note that if you use the IndexName parameter,
	// you must also provide TableName.
	IndexName *string `min:"3" type:"string"`

	// The maximum number of items to evaluate (not necessarily the number of matching
	// items). If DynamoDB processes the number of items up to the limit while processing
	// the results, it stops the operation and returns the matching values up to
	// that point, and a key in LastEvaluatedKey to apply in a subsequent operation,
	// so that you can pick up where you left off. Also, if the processed data set
	// size exceeds 1 MB before DynamoDB reaches this limit, it stops the operation
	// and returns the matching values up to the limit, and a key in LastEvaluatedKey
	// to apply in a subsequent operation to continue the operation. For more information,
	// see Query and Scan (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html)
	// in the Amazon DynamoDB Developer Guide.
	Limit *int64 `min:"1" type:"integer"`

	// A string that identifies one or more attributes to retrieve from the specified
	// table or index. These attributes can include scalars, sets, or elements of
	// a JSON document. The attributes in the expression must be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ProjectionExpression *string `type:"string"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// This is a legacy parameter. Use FilterExpression instead. For more information,
	// see ScanFilter (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html)
	// in the Amazon DynamoDB Developer Guide.
	ScanFilter map[string]Condition `type:"map"`

	// For a parallel Scan request, Segment identifies an individual segment to
	// be scanned by an application worker.
	//
	// Segment IDs are zero-based, so the first segment is always 0. For example,
	// if you want to use four application threads to scan a table or an index,
	// then the first thread specifies a Segment value of 0, the second thread specifies
	// 1, and so on.
	//
	// The value of LastEvaluatedKey returned from a parallel Scan request must
	// be used as ExclusiveStartKey with the same segment ID in a subsequent Scan
	// operation.
	//
	// The value for Segment must be greater than or equal to 0, and less than the
	// value provided for TotalSegments.
	//
	// If you provide Segment, you must also provide TotalSegments.
	Segment *int64 `type:"integer"`

	// The attributes to be returned in the result. You can retrieve all item attributes,
	// specific item attributes, the count of matching items, or in the case of
	// an index, some or all of the attributes projected into the index.
	//
	//    * ALL_ATTRIBUTES - Returns all of the item attributes from the specified
	//    table or index. If you query a local secondary index, then for each matching
	//    item in the index DynamoDB will fetch the entire item from the parent
	//    table. If the index is configured to project all item attributes, then
	//    all of the data can be obtained from the local secondary index, and no
	//    fetching is required.
	//
	//    * ALL_PROJECTED_ATTRIBUTES - Allowed only when querying an index. Retrieves
	//    all attributes that have been projected into the index. If the index is
	//    configured to project all attributes, this return value is equivalent
	//    to specifying ALL_ATTRIBUTES.
	//
	//    * COUNT - Returns the number of matching items, rather than the matching
	//    items themselves.
	//
	//    * SPECIFIC_ATTRIBUTES - Returns only the attributes listed in AttributesToGet.
	//    This return value is equivalent to specifying AttributesToGet without
	//    specifying any value for Select.
	//
	// If you query or scan a local secondary index and request only attributes
	//    that are projected into that index, the operation will read only the index
	//    and not the table. If any of the requested attributes are not projected
	//    into the local secondary index, DynamoDB will fetch each of these attributes
	//    from the parent table. This extra fetching incurs additional throughput
	//    cost and latency.
	//
	// If you query or scan a global secondary index, you can only request attributes
	//    that are projected into the index. Global secondary index queries cannot
	//    fetch attributes from the parent table.
	//
	// If neither Select nor AttributesToGet are specified, DynamoDB defaults to
	// ALL_ATTRIBUTES when accessing a table, and ALL_PROJECTED_ATTRIBUTES when
	// accessing an index. You cannot use both Select and AttributesToGet together
	// in a single request, unless the value for Select is SPECIFIC_ATTRIBUTES.
	// (This usage is equivalent to specifying AttributesToGet without any value
	// for Select.)
	//
	// If you use the ProjectionExpression parameter, then the value for Select
	// can only be SPECIFIC_ATTRIBUTES. Any other value for Select will return an
	// error.
	Select Select `type:"string" enum:"true"`

	// The name of the table containing the requested items; or, if you provide
	// IndexName, the name of the table to which that index belongs.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`

	// For a parallel Scan request, TotalSegments represents the total number of
	// segments into which the Scan operation will be divided. The value of TotalSegments
	// corresponds to the number of application workers that will perform the parallel
	// scan. For example, if you want to use four application threads to scan a
	// table or an index, specify a TotalSegments value of 4.
	//
	// The value for TotalSegments must be greater than or equal to 1, and less
	// than or equal to 1000000. If you specify a TotalSegments value of 1, the
	// Scan operation will be sequential rather than parallel.
	//
	// If you specify TotalSegments, you must also specify Segment.
	TotalSegments *int64 `min:"1" type:"integer"`
}

// String returns the string representation
func (s ScanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ScanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ScanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ScanInput"}
	if s.AttributesToGet != nil && len(s.AttributesToGet) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributesToGet", 1))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}
	if s.Limit != nil && *s.Limit < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Limit", 1))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}
	if s.TotalSegments != nil && *s.TotalSegments < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("TotalSegments", 1))
	}
	if s.ScanFilter != nil {
		for i, v := range s.ScanFilter {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ScanFilter", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of a Scan operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/ScanOutput
type ScanOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The capacity units consumed by the Scan operation. The data returned includes
	// the total provisioned throughput consumed, along with statistics for the
	// table and any indexes involved in the operation. ConsumedCapacity is only
	// returned if the ReturnConsumedCapacity parameter was specified. For more
	// information, see Provisioned Throughput (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// The number of items in the response.
	//
	// If you set ScanFilter in the request, then Count is the number of items returned
	// after the filter was applied, and ScannedCount is the number of matching
	// items before the filter was applied.
	//
	// If you did not use a filter in the request, then Count is the same as ScannedCount.
	Count *int64 `type:"integer"`

	// An array of item attributes that match the scan criteria. Each element in
	// this array consists of an attribute name and the value for that attribute.
	Items []map[string]AttributeValue `type:"list"`

	// The primary key of the item where the operation stopped, inclusive of the
	// previous result set. Use this value to start a new operation, excluding this
	// value in the new request.
	//
	// If LastEvaluatedKey is empty, then the "last page" of results has been processed
	// and there is no more data to be retrieved.
	//
	// If LastEvaluatedKey is not empty, it does not necessarily mean that there
	// is more data in the result set. The only way to know when you have reached
	// the end of the result set is when LastEvaluatedKey is empty.
	LastEvaluatedKey map[string]AttributeValue `type:"map"`

	// The number of items evaluated, before any ScanFilter is applied. A high ScannedCount
	// value with few, or no, Count results indicates an inefficient Scan operation.
	// For more information, see Count and ScannedCount (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count)
	// in the Amazon DynamoDB Developer Guide.
	//
	// If you did not use a filter in the request, then ScannedCount is the same
	// as Count.
	ScannedCount *int64 `type:"integer"`
}

// String returns the string representation
func (s ScanOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ScanOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ScanOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Contains the details of the table when the backup was created.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/SourceTableDetails
type SourceTableDetails struct {
	_ struct{} `type:"structure"`

	// Controls how you are charged for read and write throughput and how you manage
	// capacity. This setting can be changed later.
	//
	//    * PROVISIONED - Sets the read/write capacity mode to PROVISIONED. We recommend
	//    using PROVISIONED for predictable workloads.
	//
	//    * PAY_PER_REQUEST - Sets the read/write capacity mode to PAY_PER_REQUEST.
	//    We recommend using PAY_PER_REQUEST for unpredictable workloads.
	BillingMode BillingMode `type:"string" enum:"true"`

	// Number of items in the table. Please note this is an approximate value.
	ItemCount *int64 `type:"long"`

	// Schema of the table.
	//
	// KeySchema is a required field
	KeySchema []KeySchemaElement `min:"1" type:"list" required:"true"`

	// Read IOPs and Write IOPS on the table when the backup was created.
	//
	// ProvisionedThroughput is a required field
	ProvisionedThroughput *ProvisionedThroughput `type:"structure" required:"true"`

	// ARN of the table for which backup was created.
	TableArn *string `type:"string"`

	// Time when the source table was created.
	//
	// TableCreationDateTime is a required field
	TableCreationDateTime *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// Unique identifier for the table for which the backup was created.
	//
	// TableId is a required field
	TableId *string `type:"string" required:"true"`

	// The name of the table for which the backup was created.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`

	// Size of the table in bytes. Please note this is an approximate value.
	TableSizeBytes *int64 `type:"long"`
}

// String returns the string representation
func (s SourceTableDetails) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SourceTableDetails) GoString() string {
	return s.String()
}

// Contains the details of the features enabled on the table when the backup
// was created. For example, LSIs, GSIs, streams, TTL.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/SourceTableFeatureDetails
type SourceTableFeatureDetails struct {
	_ struct{} `type:"structure"`

	// Represents the GSI properties for the table when the backup was created.
	// It includes the IndexName, KeySchema, Projection and ProvisionedThroughput
	// for the GSIs on the table at the time of backup.
	GlobalSecondaryIndexes []GlobalSecondaryIndexInfo `type:"list"`

	// Represents the LSI properties for the table when the backup was created.
	// It includes the IndexName, KeySchema and Projection for the LSIs on the table
	// at the time of backup.
	LocalSecondaryIndexes []LocalSecondaryIndexInfo `type:"list"`

	// The description of the server-side encryption status on the table when the
	// backup was created.
	SSEDescription *SSEDescription `type:"structure"`

	// Stream settings on the table when the backup was created.
	StreamDescription *StreamSpecification `type:"structure"`

	// Time to Live settings on the table when the backup was created.
	TimeToLiveDescription *TimeToLiveDescription `type:"structure"`
}

// String returns the string representation
func (s SourceTableFeatureDetails) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SourceTableFeatureDetails) GoString() string {
	return s.String()
}

// Represents the DynamoDB Streams configuration for a table in DynamoDB.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/StreamSpecification
type StreamSpecification struct {
	_ struct{} `type:"structure"`

	// Indicates whether DynamoDB Streams is enabled (true) or disabled (false)
	// on the table.
	StreamEnabled *bool `type:"boolean"`

	// When an item in the table is modified, StreamViewType determines what information
	// is written to the stream for this table. Valid values for StreamViewType
	// are:
	//
	//    * KEYS_ONLY - Only the key attributes of the modified item are written
	//    to the stream.
	//
	//    * NEW_IMAGE - The entire item, as it appears after it was modified, is
	//    written to the stream.
	//
	//    * OLD_IMAGE - The entire item, as it appeared before it was modified,
	//    is written to the stream.
	//
	//    * NEW_AND_OLD_IMAGES - Both the new and the old item images of the item
	//    are written to the stream.
	StreamViewType StreamViewType `type:"string" enum:"true"`
}

// String returns the string representation
func (s StreamSpecification) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StreamSpecification) GoString() string {
	return s.String()
}

// Represents the properties of a table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TableDescription
type TableDescription struct {
	_ struct{} `type:"structure"`

	// An array of AttributeDefinition objects. Each of these objects describes
	// one attribute in the table and index key schema.
	//
	// Each AttributeDefinition object in this array is composed of:
	//
	//    * AttributeName - The name of the attribute.
	//
	//    * AttributeType - The data type for the attribute.
	AttributeDefinitions []AttributeDefinition `type:"list"`

	// Contains the details for the read/write capacity mode.
	BillingModeSummary *BillingModeSummary `type:"structure"`

	// The date and time when the table was created, in UNIX epoch time (http://www.epochconverter.com/)
	// format.
	CreationDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The global secondary indexes, if any, on the table. Each index is scoped
	// to a given partition key value. Each element is composed of:
	//
	//    * Backfilling - If true, then the index is currently in the backfilling
	//    phase. Backfilling occurs only when a new global secondary index is added
	//    to the table; it is the process by which DynamoDB populates the new index
	//    with data from the table. (This attribute does not appear for indexes
	//    that were created during a CreateTable operation.)
	//
	//    * IndexName - The name of the global secondary index.
	//
	//    * IndexSizeBytes - The total size of the global secondary index, in bytes.
	//    DynamoDB updates this value approximately every six hours. Recent changes
	//    might not be reflected in this value.
	//
	//    * IndexStatus - The current status of the global secondary index:
	//
	// CREATING - The index is being created.
	//
	// UPDATING - The index is being updated.
	//
	// DELETING - The index is being deleted.
	//
	// ACTIVE - The index is ready for use.
	//
	//    * ItemCount - The number of items in the global secondary index. DynamoDB
	//    updates this value approximately every six hours. Recent changes might
	//    not be reflected in this value.
	//
	//    * KeySchema - Specifies the complete index key schema. The attribute names
	//    in the key schema must be between 1 and 255 characters (inclusive). The
	//    key schema must begin with the same partition key as the table.
	//
	//    * Projection - Specifies attributes that are copied (projected) from the
	//    table into the index. These are in addition to the primary key attributes
	//    and index key attributes, which are automatically projected. Each attribute
	//    specification is composed of:
	//
	// ProjectionType - One of the following:
	//
	// KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	// INCLUDE - Only the specified table attributes are projected into the index.
	//    The list of projected attributes are in NonKeyAttributes.
	//
	// ALL - All of the table attributes are projected into the index.
	//
	// NonKeyAttributes - A list of one or more non-key attribute names that are
	//    projected into the secondary index. The total count of attributes provided
	//    in NonKeyAttributes, summed across all of the secondary indexes, must
	//    not exceed 20. If you project the same attribute into two different indexes,
	//    this counts as two distinct attributes when determining the total.
	//
	//    * ProvisionedThroughput - The provisioned throughput settings for the
	//    global secondary index, consisting of read and write capacity units, along
	//    with data about increases and decreases.
	//
	// If the table is in the DELETING state, no information about indexes will
	// be returned.
	GlobalSecondaryIndexes []GlobalSecondaryIndexDescription `type:"list"`

	// The number of items in the specified table. DynamoDB updates this value approximately
	// every six hours. Recent changes might not be reflected in this value.
	ItemCount *int64 `type:"long"`

	// The primary key structure for the table. Each KeySchemaElement consists of:
	//
	//    * AttributeName - The name of the attribute.
	//
	//    * KeyType - The role of the attribute:
	//
	// HASH - partition key
	//
	// RANGE - sort key
	//
	// The partition key of an item is also known as its hash attribute. The term
	//    "hash attribute" derives from DynamoDB' usage of an internal hash function
	//    to evenly distribute data items across partitions, based on their partition
	//    key values.
	//
	// The sort key of an item is also known as its range attribute. The term "range
	//    attribute" derives from the way DynamoDB stores items with the same partition
	//    key physically close together, in sorted order by the sort key value.
	//
	// For more information about primary keys, see Primary Key (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModelPrimaryKey)
	// in the Amazon DynamoDB Developer Guide.
	KeySchema []KeySchemaElement `min:"1" type:"list"`

	// The Amazon Resource Name (ARN) that uniquely identifies the latest stream
	// for this table.
	LatestStreamArn *string `min:"37" type:"string"`

	// A timestamp, in ISO 8601 format, for this stream.
	//
	// Note that LatestStreamLabel is not a unique identifier for the stream, because
	// it is possible that a stream from another table might have the same timestamp.
	// However, the combination of the following three elements is guaranteed to
	// be unique:
	//
	//    * the AWS customer ID.
	//
	//    * the table name.
	//
	//    * the StreamLabel.
	LatestStreamLabel *string `type:"string"`

	// Represents one or more local secondary indexes on the table. Each index is
	// scoped to a given partition key value. Tables with one or more local secondary
	// indexes are subject to an item collection size limit, where the amount of
	// data within a given item collection cannot exceed 10 GB. Each element is
	// composed of:
	//
	//    * IndexName - The name of the local secondary index.
	//
	//    * KeySchema - Specifies the complete index key schema. The attribute names
	//    in the key schema must be between 1 and 255 characters (inclusive). The
	//    key schema must begin with the same partition key as the table.
	//
	//    * Projection - Specifies attributes that are copied (projected) from the
	//    table into the index. These are in addition to the primary key attributes
	//    and index key attributes, which are automatically projected. Each attribute
	//    specification is composed of:
	//
	// ProjectionType - One of the following:
	//
	// KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	// INCLUDE - Only the specified table attributes are projected into the index.
	//    The list of projected attributes are in NonKeyAttributes.
	//
	// ALL - All of the table attributes are projected into the index.
	//
	// NonKeyAttributes - A list of one or more non-key attribute names that are
	//    projected into the secondary index. The total count of attributes provided
	//    in NonKeyAttributes, summed across all of the secondary indexes, must
	//    not exceed 20. If you project the same attribute into two different indexes,
	//    this counts as two distinct attributes when determining the total.
	//
	//    * IndexSizeBytes - Represents the total size of the index, in bytes. DynamoDB
	//    updates this value approximately every six hours. Recent changes might
	//    not be reflected in this value.
	//
	//    * ItemCount - Represents the number of items in the index. DynamoDB updates
	//    this value approximately every six hours. Recent changes might not be
	//    reflected in this value.
	//
	// If the table is in the DELETING state, no information about indexes will
	// be returned.
	LocalSecondaryIndexes []LocalSecondaryIndexDescription `type:"list"`

	// The provisioned throughput settings for the table, consisting of read and
	// write capacity units, along with data about increases and decreases.
	ProvisionedThroughput *ProvisionedThroughputDescription `type:"structure"`

	// Contains details for the restore.
	RestoreSummary *RestoreSummary `type:"structure"`

	// The description of the server-side encryption status on the specified table.
	SSEDescription *SSEDescription `type:"structure"`

	// The current DynamoDB Streams configuration for the table.
	StreamSpecification *StreamSpecification `type:"structure"`

	// The Amazon Resource Name (ARN) that uniquely identifies the table.
	TableArn *string `type:"string"`

	// Unique identifier for the table for which the backup was created.
	TableId *string `type:"string"`

	// The name of the table.
	TableName *string `min:"3" type:"string"`

	// The total size of the specified table, in bytes. DynamoDB updates this value
	// approximately every six hours. Recent changes might not be reflected in this
	// value.
	TableSizeBytes *int64 `type:"long"`

	// The current state of the table:
	//
	//    * CREATING - The table is being created.
	//
	//    * UPDATING - The table is being updated.
	//
	//    * DELETING - The table is being deleted.
	//
	//    * ACTIVE - The table is ready for use.
	TableStatus TableStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s TableDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TableDescription) GoString() string {
	return s.String()
}

// Describes a tag. A tag is a key-value pair. You can add up to 50 tags to
// a single DynamoDB table.
//
// AWS-assigned tag names and values are automatically assigned the aws: prefix,
// which the user cannot assign. AWS-assigned tag names do not count towards
// the tag limit of 50. User-assigned tag names have the prefix user: in the
// Cost Allocation Report. You cannot backdate the application of a tag.
//
// For an overview on tagging DynamoDB resources, see Tagging for DynamoDB (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
// in the Amazon DynamoDB Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Tag
type Tag struct {
	_ struct{} `type:"structure"`

	// The key of the tag.Tag keys are case sensitive. Each DynamoDB table can only
	// have up to one tag with the same key. If you try to add an existing tag (same
	// key), the existing tag value will be updated to the new value.
	//
	// Key is a required field
	Key *string `min:"1" type:"string" required:"true"`

	// The value of the tag. Tag values are case-sensitive and can be null.
	//
	// Value is a required field
	Value *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Tag) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Tag) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Tag) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Tag"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TagResourceInput
type TagResourceInput struct {
	_ struct{} `type:"structure"`

	// Identifies the Amazon DynamoDB resource to which tags should be added. This
	// value is an Amazon Resource Name (ARN).
	//
	// ResourceArn is a required field
	ResourceArn *string `min:"1" type:"string" required:"true"`

	// The tags to be assigned to the Amazon DynamoDB resource.
	//
	// Tags is a required field
	Tags []Tag `type:"list" required:"true"`
}

// String returns the string representation
func (s TagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TagResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TagResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}
	if s.ResourceArn != nil && len(*s.ResourceArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceArn", 1))
	}

	if s.Tags == nil {
		invalidParams.Add(aws.NewErrParamRequired("Tags"))
	}
	if s.Tags != nil {
		for i, v := range s.Tags {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Tags", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TagResourceOutput
type TagResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s TagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TagResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// The description of the Time to Live (TTL) status on the specified table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TimeToLiveDescription
type TimeToLiveDescription struct {
	_ struct{} `type:"structure"`

	// The name of the Time to Live attribute for items in the table.
	AttributeName *string `min:"1" type:"string"`

	// The Time to Live status for the table.
	TimeToLiveStatus TimeToLiveStatus `type:"string" enum:"true"`
}

// String returns the string representation
func (s TimeToLiveDescription) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TimeToLiveDescription) GoString() string {
	return s.String()
}

// Represents the settings used to enable or disable Time to Live for the specified
// table.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TimeToLiveSpecification
type TimeToLiveSpecification struct {
	_ struct{} `type:"structure"`

	// The name of the Time to Live attribute used to store the expiration time
	// for items in the table.
	//
	// AttributeName is a required field
	AttributeName *string `min:"1" type:"string" required:"true"`

	// Indicates whether Time To Live is to be enabled (true) or disabled (false)
	// on the table.
	//
	// Enabled is a required field
	Enabled *bool `type:"boolean" required:"true"`
}

// String returns the string representation
func (s TimeToLiveSpecification) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TimeToLiveSpecification) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TimeToLiveSpecification) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TimeToLiveSpecification"}

	if s.AttributeName == nil {
		invalidParams.Add(aws.NewErrParamRequired("AttributeName"))
	}
	if s.AttributeName != nil && len(*s.AttributeName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AttributeName", 1))
	}

	if s.Enabled == nil {
		invalidParams.Add(aws.NewErrParamRequired("Enabled"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Specifies an item to be retrieved as part of the transaction.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactGetItem
type TransactGetItem struct {
	_ struct{} `type:"structure"`

	// Contains the primary key that identifies the item to get, together with the
	// name of the table that contains the item, and optionally the specific attributes
	// of the item to retrieve.
	//
	// Get is a required field
	Get *Get `type:"structure" required:"true"`
}

// String returns the string representation
func (s TransactGetItem) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransactGetItem) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TransactGetItem) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TransactGetItem"}

	if s.Get == nil {
		invalidParams.Add(aws.NewErrParamRequired("Get"))
	}
	if s.Get != nil {
		if err := s.Get.Validate(); err != nil {
			invalidParams.AddNested("Get", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactGetItemsInput
type TransactGetItemsInput struct {
	_ struct{} `type:"structure"`

	// A value of TOTAL causes consumed capacity information to be returned, and
	// a value of NONE prevents that information from being returned. No other value
	// is valid.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// An ordered array of up to 10 TransactGetItem objects, each of which contains
	// a Get structure.
	//
	// TransactItems is a required field
	TransactItems []TransactGetItem `min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s TransactGetItemsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransactGetItemsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TransactGetItemsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TransactGetItemsInput"}

	if s.TransactItems == nil {
		invalidParams.Add(aws.NewErrParamRequired("TransactItems"))
	}
	if s.TransactItems != nil && len(s.TransactItems) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TransactItems", 1))
	}
	if s.TransactItems != nil {
		for i, v := range s.TransactItems {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TransactItems", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactGetItemsOutput
type TransactGetItemsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If the ReturnConsumedCapacity value was TOTAL, this is an array of ConsumedCapacity
	// objects, one for each table addressed by TransactGetItem objects in the TransactItems
	// parameter. These ConsumedCapacity objects report the read-capacity units
	// consumed by the TransactGetItems call in that table.
	ConsumedCapacity []ConsumedCapacity `type:"list"`

	// An ordered array of up to 10 ItemResponse objects, each of which corresponds
	// to the TransactGetItem object in the same position in the TransactItems array.
	// Each ItemResponse object contains a Map of the name-value pairs that are
	// the projected attributes of the requested item.
	//
	// If a requested item could not be retrieved, the corresponding ItemResponse
	// object is Null, or if the requested item has no projected attributes, the
	// corresponding ItemResponse object is an empty Map.
	Responses []ItemResponse `min:"1" type:"list"`
}

// String returns the string representation
func (s TransactGetItemsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransactGetItemsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TransactGetItemsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// A list of requests that can perform update, put, delete, or check operations
// on multiple items in one or more tables atomically.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactWriteItem
type TransactWriteItem struct {
	_ struct{} `type:"structure"`

	// A request to perform a check item operation.
	ConditionCheck *ConditionCheck `type:"structure"`

	// A request to perform a DeleteItem operation.
	Delete *Delete `type:"structure"`

	// A request to perform a PutItem operation.
	Put *Put `type:"structure"`

	// A request to perform an UpdateItem operation.
	Update *Update `type:"structure"`
}

// String returns the string representation
func (s TransactWriteItem) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransactWriteItem) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TransactWriteItem) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TransactWriteItem"}
	if s.ConditionCheck != nil {
		if err := s.ConditionCheck.Validate(); err != nil {
			invalidParams.AddNested("ConditionCheck", err.(aws.ErrInvalidParams))
		}
	}
	if s.Delete != nil {
		if err := s.Delete.Validate(); err != nil {
			invalidParams.AddNested("Delete", err.(aws.ErrInvalidParams))
		}
	}
	if s.Put != nil {
		if err := s.Put.Validate(); err != nil {
			invalidParams.AddNested("Put", err.(aws.ErrInvalidParams))
		}
	}
	if s.Update != nil {
		if err := s.Update.Validate(); err != nil {
			invalidParams.AddNested("Update", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactWriteItemsInput
type TransactWriteItemsInput struct {
	_ struct{} `type:"structure"`

	// Providing a ClientRequestToken makes the call to TransactWriteItems idempotent,
	// meaning that multiple identical calls have the same effect as one single
	// call.
	//
	// Although multiple identical calls using the same client request token produce
	// the same result on the server (no side effects), the responses to the calls
	// may not be the same. If the ReturnConsumedCapacity> parameter is set, then
	// the initial TransactWriteItems call returns the amount of write capacity
	// units consumed in making the changes, and subsequent TransactWriteItems calls
	// with the same client token return the amount of read capacity units consumed
	// in reading the item.
	//
	// A client request token is valid for 10 minutes after the first request that
	// uses it completes. After 10 minutes, any request with the same client token
	// is treated as a new request. Do not resubmit the same request with the same
	// client token for more than 10 minutes or the result may not be idempotent.
	//
	// If you submit a request with the same client token but a change in other
	// parameters within the 10 minute idempotency window, DynamoDB returns an IdempotentParameterMismatch
	// exception.
	ClientRequestToken *string `min:"1" type:"string" idempotencyToken:"true"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// Determines whether item collection metrics are returned. If set to SIZE,
	// the response includes statistics about item collections (if any), that were
	// modified during the operation and are returned in the response. If set to
	// NONE (the default), no statistics are returned.
	ReturnItemCollectionMetrics ReturnItemCollectionMetrics `type:"string" enum:"true"`

	// An ordered array of up to 10 TransactWriteItem objects, each of which contains
	// a ConditionCheck, Put, Update, or Delete object. These can operate on items
	// in different tables, but the tables must reside in the same AWS account and
	// region, and no two of them can operate on the same item.
	//
	// TransactItems is a required field
	TransactItems []TransactWriteItem `min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s TransactWriteItemsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransactWriteItemsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TransactWriteItemsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TransactWriteItemsInput"}
	if s.ClientRequestToken != nil && len(*s.ClientRequestToken) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ClientRequestToken", 1))
	}

	if s.TransactItems == nil {
		invalidParams.Add(aws.NewErrParamRequired("TransactItems"))
	}
	if s.TransactItems != nil && len(s.TransactItems) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TransactItems", 1))
	}
	if s.TransactItems != nil {
		for i, v := range s.TransactItems {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TransactItems", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/TransactWriteItemsOutput
type TransactWriteItemsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The capacity units consumed by the entire TransactWriteItems operation. The
	// values of the list are ordered according to the ordering of the TransactItems
	// request parameter.
	ConsumedCapacity []ConsumedCapacity `type:"list"`

	// A list of tables that were processed by TransactWriteItems and, for each
	// table, information about any item collections that were affected by individual
	// UpdateItem, PutItem or DeleteItem operations.
	ItemCollectionMetrics map[string][]ItemCollectionMetrics `type:"map"`
}

// String returns the string representation
func (s TransactWriteItemsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TransactWriteItemsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TransactWriteItemsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UntagResourceInput
type UntagResourceInput struct {
	_ struct{} `type:"structure"`

	// The Amazon DyanamoDB resource the tags will be removed from. This value is
	// an Amazon Resource Name (ARN).
	//
	// ResourceArn is a required field
	ResourceArn *string `min:"1" type:"string" required:"true"`

	// A list of tag keys. Existing tags of the resource whose keys are members
	// of this list will be removed from the Amazon DynamoDB resource.
	//
	// TagKeys is a required field
	TagKeys []string `type:"list" required:"true"`
}

// String returns the string representation
func (s UntagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UntagResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UntagResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}
	if s.ResourceArn != nil && len(*s.ResourceArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceArn", 1))
	}

	if s.TagKeys == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UntagResourceOutput
type UntagResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UntagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UntagResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents a request to perform an UpdateItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/Update
type Update struct {
	_ struct{} `type:"structure"`

	// A condition that must be satisfied in order for a conditional update to succeed.
	ConditionExpression *string `type:"string"`

	// One or more substitution tokens for attribute names in an expression.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// The primary key of the item to be updated. Each element consists of an attribute
	// name and a value for that attribute.
	//
	// Key is a required field
	Key map[string]AttributeValue `type:"map" required:"true"`

	// Use ReturnValuesOnConditionCheckFailure to get the item attributes if the
	// Update condition fails. For ReturnValuesOnConditionCheckFailure, the valid
	// values are: NONE, ALL_OLD, UPDATED_OLD, ALL_NEW, UPDATED_NEW.
	ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure `type:"string" enum:"true"`

	// Name of the table for the UpdateItem request.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`

	// An expression that defines one or more attributes to be updated, the action
	// to be performed on them, and new value(s) for them.
	//
	// UpdateExpression is a required field
	UpdateExpression *string `type:"string" required:"true"`
}

// String returns the string representation
func (s Update) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Update) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Update) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Update"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if s.UpdateExpression == nil {
		invalidParams.Add(aws.NewErrParamRequired("UpdateExpression"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateContinuousBackupsInput
type UpdateContinuousBackupsInput struct {
	_ struct{} `type:"structure"`

	// Represents the settings used to enable point in time recovery.
	//
	// PointInTimeRecoverySpecification is a required field
	PointInTimeRecoverySpecification *PointInTimeRecoverySpecification `type:"structure" required:"true"`

	// The name of the table.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateContinuousBackupsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateContinuousBackupsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateContinuousBackupsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateContinuousBackupsInput"}

	if s.PointInTimeRecoverySpecification == nil {
		invalidParams.Add(aws.NewErrParamRequired("PointInTimeRecoverySpecification"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}
	if s.PointInTimeRecoverySpecification != nil {
		if err := s.PointInTimeRecoverySpecification.Validate(); err != nil {
			invalidParams.AddNested("PointInTimeRecoverySpecification", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateContinuousBackupsOutput
type UpdateContinuousBackupsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Represents the continuous backups and point in time recovery settings on
	// the table.
	ContinuousBackupsDescription *ContinuousBackupsDescription `type:"structure"`
}

// String returns the string representation
func (s UpdateContinuousBackupsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateContinuousBackupsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateContinuousBackupsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the new provisioned throughput settings to be applied to a global
// secondary index.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalSecondaryIndexAction
type UpdateGlobalSecondaryIndexAction struct {
	_ struct{} `type:"structure"`

	// The name of the global secondary index to be updated.
	//
	// IndexName is a required field
	IndexName *string `min:"3" type:"string" required:"true"`

	// Represents the provisioned throughput settings for the specified global secondary
	// index.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// ProvisionedThroughput is a required field
	ProvisionedThroughput *ProvisionedThroughput `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateGlobalSecondaryIndexAction) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGlobalSecondaryIndexAction) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateGlobalSecondaryIndexAction) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateGlobalSecondaryIndexAction"}

	if s.IndexName == nil {
		invalidParams.Add(aws.NewErrParamRequired("IndexName"))
	}
	if s.IndexName != nil && len(*s.IndexName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("IndexName", 3))
	}

	if s.ProvisionedThroughput == nil {
		invalidParams.Add(aws.NewErrParamRequired("ProvisionedThroughput"))
	}
	if s.ProvisionedThroughput != nil {
		if err := s.ProvisionedThroughput.Validate(); err != nil {
			invalidParams.AddNested("ProvisionedThroughput", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTableInput
type UpdateGlobalTableInput struct {
	_ struct{} `type:"structure"`

	// The global table name.
	//
	// GlobalTableName is a required field
	GlobalTableName *string `min:"3" type:"string" required:"true"`

	// A list of regions that should be added or removed from the global table.
	//
	// ReplicaUpdates is a required field
	ReplicaUpdates []ReplicaUpdate `type:"list" required:"true"`
}

// String returns the string representation
func (s UpdateGlobalTableInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGlobalTableInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateGlobalTableInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateGlobalTableInput"}

	if s.GlobalTableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("GlobalTableName"))
	}
	if s.GlobalTableName != nil && len(*s.GlobalTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("GlobalTableName", 3))
	}

	if s.ReplicaUpdates == nil {
		invalidParams.Add(aws.NewErrParamRequired("ReplicaUpdates"))
	}
	if s.ReplicaUpdates != nil {
		for i, v := range s.ReplicaUpdates {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ReplicaUpdates", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTableOutput
type UpdateGlobalTableOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Contains the details of the global table.
	GlobalTableDescription *GlobalTableDescription `type:"structure"`
}

// String returns the string representation
func (s UpdateGlobalTableOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGlobalTableOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateGlobalTableOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTableSettingsInput
type UpdateGlobalTableSettingsInput struct {
	_ struct{} `type:"structure"`

	// The billing mode of the global table. If GlobalTableBillingMode is not specified,
	// the global table defaults to PROVISIONED capacity billing mode.
	GlobalTableBillingMode BillingMode `type:"string" enum:"true"`

	// Represents the settings of a global secondary index for a global table that
	// will be modified.
	GlobalTableGlobalSecondaryIndexSettingsUpdate []GlobalTableGlobalSecondaryIndexSettingsUpdate `min:"1" type:"list"`

	// The name of the global table
	//
	// GlobalTableName is a required field
	GlobalTableName *string `min:"3" type:"string" required:"true"`

	// AutoScaling settings for managing provisioned write capacity for the global
	// table.
	GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate *AutoScalingSettingsUpdate `type:"structure"`

	// The maximum number of writes consumed per second before DynamoDB returns
	// a ThrottlingException.
	GlobalTableProvisionedWriteCapacityUnits *int64 `min:"1" type:"long"`

	// Represents the settings for a global table in a region that will be modified.
	ReplicaSettingsUpdate []ReplicaSettingsUpdate `min:"1" type:"list"`
}

// String returns the string representation
func (s UpdateGlobalTableSettingsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGlobalTableSettingsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateGlobalTableSettingsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateGlobalTableSettingsInput"}
	if s.GlobalTableGlobalSecondaryIndexSettingsUpdate != nil && len(s.GlobalTableGlobalSecondaryIndexSettingsUpdate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("GlobalTableGlobalSecondaryIndexSettingsUpdate", 1))
	}

	if s.GlobalTableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("GlobalTableName"))
	}
	if s.GlobalTableName != nil && len(*s.GlobalTableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("GlobalTableName", 3))
	}
	if s.GlobalTableProvisionedWriteCapacityUnits != nil && *s.GlobalTableProvisionedWriteCapacityUnits < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("GlobalTableProvisionedWriteCapacityUnits", 1))
	}
	if s.ReplicaSettingsUpdate != nil && len(s.ReplicaSettingsUpdate) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ReplicaSettingsUpdate", 1))
	}
	if s.GlobalTableGlobalSecondaryIndexSettingsUpdate != nil {
		for i, v := range s.GlobalTableGlobalSecondaryIndexSettingsUpdate {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "GlobalTableGlobalSecondaryIndexSettingsUpdate", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate != nil {
		if err := s.GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate.Validate(); err != nil {
			invalidParams.AddNested("GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate", err.(aws.ErrInvalidParams))
		}
	}
	if s.ReplicaSettingsUpdate != nil {
		for i, v := range s.ReplicaSettingsUpdate {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ReplicaSettingsUpdate", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateGlobalTableSettingsOutput
type UpdateGlobalTableSettingsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The name of the global table.
	GlobalTableName *string `min:"3" type:"string"`

	// The region specific settings for the global table.
	ReplicaSettings []ReplicaSettingsDescription `type:"list"`
}

// String returns the string representation
func (s UpdateGlobalTableSettingsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGlobalTableSettingsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateGlobalTableSettingsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input of an UpdateItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateItemInput
type UpdateItemInput struct {
	_ struct{} `type:"structure"`

	// This is a legacy parameter. Use UpdateExpression instead. For more information,
	// see AttributeUpdates (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributeUpdates.html)
	// in the Amazon DynamoDB Developer Guide.
	AttributeUpdates map[string]AttributeValueUpdate `type:"map"`

	// A condition that must be satisfied in order for a conditional update to succeed.
	//
	// An expression can contain any of the following:
	//
	//    * Functions: attribute_exists | attribute_not_exists | attribute_type
	//    | contains | begins_with | size
	//
	// These function names are case-sensitive.
	//
	//    * Comparison operators: = | <> | < | > | <= | >= | BETWEEN | IN
	//
	//    *  Logical operators: AND | OR | NOT
	//
	// For more information on condition expressions, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	ConditionExpression *string `type:"string"`

	// This is a legacy parameter. Use ConditionExpression instead. For more information,
	// see ConditionalOperator (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
	// in the Amazon DynamoDB Developer Guide.
	ConditionalOperator ConditionalOperator `type:"string" enum:"true"`

	// This is a legacy parameter. Use ConditionExpression instead. For more information,
	// see Expected (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html)
	// in the Amazon DynamoDB Developer Guide.
	Expected map[string]ExpectedAttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//    * To access an attribute whose name conflicts with a DynamoDB reserved
	//    word.
	//
	//    * To create a placeholder for repeating occurrences of an attribute name
	//    in an expression.
	//
	//    * To prevent special characters in an attribute name from being misinterpreted
	//    in an expression.
	//
	// Use the # character in an expression to dereference an attribute name. For
	// example, consider the following attribute name:
	//
	//    * Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot be
	// used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	//    * {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	//    * #P = :val
	//
	// Tokens that begin with the : character are expression attribute values, which
	// are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]AttributeValue `type:"map"`

	// The primary key of the item to be updated. Each element consists of an attribute
	// name and a value for that attribute.
	//
	// For the primary key, you must provide all of the attributes. For example,
	// with a simple primary key, you only need to provide a value for the partition
	// key. For a composite primary key, you must provide values for both the partition
	// key and the sort key.
	//
	// Key is a required field
	Key map[string]AttributeValue `type:"map" required:"true"`

	// Determines the level of detail about provisioned throughput consumption that
	// is returned in the response:
	//
	//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
	//    operation, together with ConsumedCapacity for each table and secondary
	//    index that was accessed.
	//
	// Note that some operations, such as GetItem and BatchGetItem, do not access
	//    any indexes at all. In these cases, specifying INDEXES will only return
	//    ConsumedCapacity information for table(s).
	//
	//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
	//    the operation.
	//
	//    * NONE - No ConsumedCapacity details are included in the response.
	ReturnConsumedCapacity ReturnConsumedCapacity `type:"string" enum:"true"`

	// Determines whether item collection metrics are returned. If set to SIZE,
	// the response includes statistics about item collections, if any, that were
	// modified during the operation are returned in the response. If set to NONE
	// (the default), no statistics are returned.
	ReturnItemCollectionMetrics ReturnItemCollectionMetrics `type:"string" enum:"true"`

	// Use ReturnValues if you want to get the item attributes as they appear before
	// or after they are updated. For UpdateItem, the valid values are:
	//
	//    * NONE - If ReturnValues is not specified, or if its value is NONE, then
	//    nothing is returned. (This setting is the default for ReturnValues.)
	//
	//    * ALL_OLD - Returns all of the attributes of the item, as they appeared
	//    before the UpdateItem operation.
	//
	//    * UPDATED_OLD - Returns only the updated attributes, as they appeared
	//    before the UpdateItem operation.
	//
	//    * ALL_NEW - Returns all of the attributes of the item, as they appear
	//    after the UpdateItem operation.
	//
	//    * UPDATED_NEW - Returns only the updated attributes, as they appear after
	//    the UpdateItem operation.
	//
	// There is no additional cost associated with requesting a return value aside
	// from the small network and processing overhead of receiving a larger response.
	// No read capacity units are consumed.
	//
	// The values returned are strongly consistent.
	ReturnValues ReturnValue `type:"string" enum:"true"`

	// The name of the table containing the item to update.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`

	// An expression that defines one or more attributes to be updated, the action
	// to be performed on them, and new value(s) for them.
	//
	// The following action values are available for UpdateExpression.
	//
	//    * SET - Adds one or more attributes and values to an item. If any of these
	//    attribute already exist, they are replaced by the new values. You can
	//    also use SET to add or subtract from an attribute that is of type Number.
	//    For example: SET myNum = myNum + :val
	//
	// SET supports the following functions:
	//
	// if_not_exists (path, operand) - if the item does not contain an attribute
	//    at the specified path, then if_not_exists evaluates to operand; otherwise,
	//    it evaluates to path. You can use this function to avoid overwriting an
	//    attribute that may already be present in the item.
	//
	// list_append (operand, operand) - evaluates to a list with a new element added
	//    to it. You can append the new element to the start or the end of the list
	//    by reversing the order of the operands.
	//
	// These function names are case-sensitive.
	//
	//    * REMOVE - Removes one or more attributes from an item.
	//
	//    * ADD - Adds the specified value to the item, if the attribute does not
	//    already exist. If the attribute does exist, then the behavior of ADD depends
	//    on the data type of the attribute:
	//
	// If the existing attribute is a number, and if Value is also a number, then
	//    Value is mathematically added to the existing attribute. If Value is a
	//    negative number, then it is subtracted from the existing attribute.
	//
	// If you use ADD to increment or decrement a number value for an item that
	//    doesn't exist before the update, DynamoDB uses 0 as the initial value.
	//
	// Similarly, if you use ADD for an existing item to increment or decrement
	//    an attribute value that doesn't exist before the update, DynamoDB uses
	//    0 as the initial value. For example, suppose that the item you want to
	//    update doesn't have an attribute named itemcount, but you decide to ADD
	//    the number 3 to this attribute anyway. DynamoDB will create the itemcount
	//    attribute, set its initial value to 0, and finally add 3 to it. The result
	//    will be a new itemcount attribute in the item, with a value of 3.
	//
	// If the existing data type is a set and if Value is also a set, then Value
	//    is added to the existing set. For example, if the attribute value is the
	//    set [1,2], and the ADD action specified [3], then the final attribute
	//    value is [1,2,3]. An error occurs if an ADD action is specified for a
	//    set attribute and the attribute type specified does not match the existing
	//    set type.
	//
	// Both sets must have the same primitive data type. For example, if the existing
	//    data type is a set of strings, the Value must also be a set of strings.
	//
	// The ADD action only supports Number and set data types. In addition, ADD
	//    can only be used on top-level attributes, not nested attributes.
	//
	//    * DELETE - Deletes an element from a set.
	//
	// If a set of values is specified, then those values are subtracted from the
	//    old set. For example, if the attribute value was the set [a,b,c] and the
	//    DELETE action specifies [a,c], then the final attribute value is [b].
	//    Specifying an empty set is an error.
	//
	// The DELETE action only supports set data types. In addition, DELETE can only
	//    be used on top-level attributes, not nested attributes.
	//
	// You can have many actions in a single expression, such as the following:
	// SET a=:value1, b=:value2 DELETE :value3, :value4, :value5
	//
	// For more information on update expressions, see Modifying Items and Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html)
	// in the Amazon DynamoDB Developer Guide.
	UpdateExpression *string `type:"string"`
}

// String returns the string representation
func (s UpdateItemInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateItemInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateItemInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateItemInput"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of an UpdateItem operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateItemOutput
type UpdateItemOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A map of attribute values as they appear before or after the UpdateItem operation,
	// as determined by the ReturnValues parameter.
	//
	// The Attributes map is only present if ReturnValues was specified as something
	// other than NONE in the request. Each element represents one attribute.
	Attributes map[string]AttributeValue `type:"map"`

	// The capacity units consumed by the UpdateItem operation. The data returned
	// includes the total provisioned throughput consumed, along with statistics
	// for the table and any indexes involved in the operation. ConsumedCapacity
	// is only returned if the ReturnConsumedCapacity parameter was specified. For
	// more information, see Provisioned Throughput (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// Information about item collections, if any, that were affected by the UpdateItem
	// operation. ItemCollectionMetrics is only returned if the ReturnItemCollectionMetrics
	// parameter was specified. If the table does not have any local secondary indexes,
	// this information is not returned in the response.
	//
	// Each ItemCollectionMetrics element consists of:
	//
	//    * ItemCollectionKey - The partition key value of the item collection.
	//    This is the same as the partition key value of the item itself.
	//
	//    * SizeEstimateRangeGB - An estimate of item collection size, in gigabytes.
	//    This value is a two-element array containing a lower bound and an upper
	//    bound for the estimate. The estimate includes the size of all the items
	//    in the table, plus the size of all attributes projected into all of the
	//    local secondary indexes on that table. Use this estimate to measure whether
	//    a local secondary index is approaching its size limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	//    precision or accuracy of the estimate.
	ItemCollectionMetrics *ItemCollectionMetrics `type:"structure"`
}

// String returns the string representation
func (s UpdateItemOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateItemOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateItemOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input of an UpdateTable operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTableInput
type UpdateTableInput struct {
	_ struct{} `type:"structure"`

	// An array of attributes that describe the key schema for the table and indexes.
	// If you are adding a new global secondary index to the table, AttributeDefinitions
	// must include the key element(s) of the new index.
	AttributeDefinitions []AttributeDefinition `type:"list"`

	// Controls how you are charged for read and write throughput and how you manage
	// capacity. When switching from pay-per-request to provisioned capacity, initial
	// provisioned capacity values must be set. The initial provisioned capacity
	// values are estimated based on the consumed read and write capacity of your
	// table and global secondary indexes over the past 30 minutes.
	//
	//    * PROVISIONED - Sets the billing mode to PROVISIONED. We recommend using
	//    PROVISIONED for predictable workloads.
	//
	//    * PAY_PER_REQUEST - Sets the billing mode to PAY_PER_REQUEST. We recommend
	//    using PAY_PER_REQUEST for unpredictable workloads.
	BillingMode BillingMode `type:"string" enum:"true"`

	// An array of one or more global secondary indexes for the table. For each
	// index in the array, you can request one action:
	//
	//    * Create - add a new global secondary index to the table.
	//
	//    * Update - modify the provisioned throughput settings of an existing global
	//    secondary index.
	//
	//    * Delete - remove a global secondary index from the table.
	//
	// For more information, see Managing Global Secondary Indexes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html)
	// in the Amazon DynamoDB Developer Guide.
	GlobalSecondaryIndexUpdates []GlobalSecondaryIndexUpdate `type:"list"`

	// The new provisioned throughput settings for the specified table or index.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure"`

	// The new server-side encryption settings for the specified table.
	SSESpecification *SSESpecification `type:"structure"`

	// Represents the DynamoDB Streams configuration for the table.
	//
	// You will receive a ResourceInUseException if you attempt to enable a stream
	// on a table that already has a stream, or if you attempt to disable a stream
	// on a table which does not have a stream.
	StreamSpecification *StreamSpecification `type:"structure"`

	// The name of the table to be updated.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateTableInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTableInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateTableInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateTableInput"}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}
	if s.AttributeDefinitions != nil {
		for i, v := range s.AttributeDefinitions {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AttributeDefinitions", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.GlobalSecondaryIndexUpdates != nil {
		for i, v := range s.GlobalSecondaryIndexUpdates {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "GlobalSecondaryIndexUpdates", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.ProvisionedThroughput != nil {
		if err := s.ProvisionedThroughput.Validate(); err != nil {
			invalidParams.AddNested("ProvisionedThroughput", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Represents the output of an UpdateTable operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTableOutput
type UpdateTableOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Represents the properties of the table.
	TableDescription *TableDescription `type:"structure"`
}

// String returns the string representation
func (s UpdateTableOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTableOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateTableOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents the input of an UpdateTimeToLive operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTimeToLiveInput
type UpdateTimeToLiveInput struct {
	_ struct{} `type:"structure"`

	// The name of the table to be configured.
	//
	// TableName is a required field
	TableName *string `min:"3" type:"string" required:"true"`

	// Represents the settings used to enable or disable Time to Live for the specified
	// table.
	//
	// TimeToLiveSpecification is a required field
	TimeToLiveSpecification *TimeToLiveSpecification `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateTimeToLiveInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTimeToLiveInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateTimeToLiveInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateTimeToLiveInput"}

	if s.TableName == nil {
		invalidParams.Add(aws.NewErrParamRequired("TableName"))
	}
	if s.TableName != nil && len(*s.TableName) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("TableName", 3))
	}

	if s.TimeToLiveSpecification == nil {
		invalidParams.Add(aws.NewErrParamRequired("TimeToLiveSpecification"))
	}
	if s.TimeToLiveSpecification != nil {
		if err := s.TimeToLiveSpecification.Validate(); err != nil {
			invalidParams.AddNested("TimeToLiveSpecification", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/UpdateTimeToLiveOutput
type UpdateTimeToLiveOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Represents the output of an UpdateTimeToLive operation.
	TimeToLiveSpecification *TimeToLiveSpecification `type:"structure"`
}

// String returns the string representation
func (s UpdateTimeToLiveOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTimeToLiveOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateTimeToLiveOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// Represents an operation to perform - either DeleteItem or PutItem. You can
// only request one of these operations, not both, in a single WriteRequest.
// If you do need to perform both of these operations, you will need to provide
// two separate WriteRequest objects.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/dynamodb-2012-08-10/WriteRequest
type WriteRequest struct {
	_ struct{} `type:"structure"`

	// A request to perform a DeleteItem operation.
	DeleteRequest *DeleteRequest `type:"structure"`

	// A request to perform a PutItem operation.
	PutRequest *PutRequest `type:"structure"`
}

// String returns the string representation
func (s WriteRequest) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s WriteRequest) GoString() string {
	return s.String()
}

type AttributeAction string

// Enum values for AttributeAction
const (
	AttributeActionAdd    AttributeAction = "ADD"
	AttributeActionPut    AttributeAction = "PUT"
	AttributeActionDelete AttributeAction = "DELETE"
)

func (enum AttributeAction) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AttributeAction) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type BackupStatus string

// Enum values for BackupStatus
const (
	BackupStatusCreating  BackupStatus = "CREATING"
	BackupStatusDeleted   BackupStatus = "DELETED"
	BackupStatusAvailable BackupStatus = "AVAILABLE"
)

func (enum BackupStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BackupStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type BackupType string

// Enum values for BackupType
const (
	BackupTypeUser   BackupType = "USER"
	BackupTypeSystem BackupType = "SYSTEM"
)

func (enum BackupType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BackupType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type BackupTypeFilter string

// Enum values for BackupTypeFilter
const (
	BackupTypeFilterUser   BackupTypeFilter = "USER"
	BackupTypeFilterSystem BackupTypeFilter = "SYSTEM"
	BackupTypeFilterAll    BackupTypeFilter = "ALL"
)

func (enum BackupTypeFilter) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BackupTypeFilter) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type BillingMode string

// Enum values for BillingMode
const (
	BillingModeProvisioned   BillingMode = "PROVISIONED"
	BillingModePayPerRequest BillingMode = "PAY_PER_REQUEST"
)

func (enum BillingMode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BillingMode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ComparisonOperator string

// Enum values for ComparisonOperator
const (
	ComparisonOperatorEq          ComparisonOperator = "EQ"
	ComparisonOperatorNe          ComparisonOperator = "NE"
	ComparisonOperatorIn          ComparisonOperator = "IN"
	ComparisonOperatorLe          ComparisonOperator = "LE"
	ComparisonOperatorLt          ComparisonOperator = "LT"
	ComparisonOperatorGe          ComparisonOperator = "GE"
	ComparisonOperatorGt          ComparisonOperator = "GT"
	ComparisonOperatorBetween     ComparisonOperator = "BETWEEN"
	ComparisonOperatorNotNull     ComparisonOperator = "NOT_NULL"
	ComparisonOperatorNull        ComparisonOperator = "NULL"
	ComparisonOperatorContains    ComparisonOperator = "CONTAINS"
	ComparisonOperatorNotContains ComparisonOperator = "NOT_CONTAINS"
	ComparisonOperatorBeginsWith  ComparisonOperator = "BEGINS_WITH"
)

func (enum ComparisonOperator) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ComparisonOperator) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ConditionalOperator string

// Enum values for ConditionalOperator
const (
	ConditionalOperatorAnd ConditionalOperator = "AND"
	ConditionalOperatorOr  ConditionalOperator = "OR"
)

func (enum ConditionalOperator) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ConditionalOperator) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ContinuousBackupsStatus string

// Enum values for ContinuousBackupsStatus
const (
	ContinuousBackupsStatusEnabled  ContinuousBackupsStatus = "ENABLED"
	ContinuousBackupsStatusDisabled ContinuousBackupsStatus = "DISABLED"
)

func (enum ContinuousBackupsStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ContinuousBackupsStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type GlobalTableStatus string

// Enum values for GlobalTableStatus
const (
	GlobalTableStatusCreating GlobalTableStatus = "CREATING"
	GlobalTableStatusActive   GlobalTableStatus = "ACTIVE"
	GlobalTableStatusDeleting GlobalTableStatus = "DELETING"
	GlobalTableStatusUpdating GlobalTableStatus = "UPDATING"
)

func (enum GlobalTableStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum GlobalTableStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type IndexStatus string

// Enum values for IndexStatus
const (
	IndexStatusCreating IndexStatus = "CREATING"
	IndexStatusUpdating IndexStatus = "UPDATING"
	IndexStatusDeleting IndexStatus = "DELETING"
	IndexStatusActive   IndexStatus = "ACTIVE"
)

func (enum IndexStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum IndexStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type KeyType string

// Enum values for KeyType
const (
	KeyTypeHash  KeyType = "HASH"
	KeyTypeRange KeyType = "RANGE"
)

func (enum KeyType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum KeyType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type PointInTimeRecoveryStatus string

// Enum values for PointInTimeRecoveryStatus
const (
	PointInTimeRecoveryStatusEnabled  PointInTimeRecoveryStatus = "ENABLED"
	PointInTimeRecoveryStatusDisabled PointInTimeRecoveryStatus = "DISABLED"
)

func (enum PointInTimeRecoveryStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum PointInTimeRecoveryStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ProjectionType string

// Enum values for ProjectionType
const (
	ProjectionTypeAll      ProjectionType = "ALL"
	ProjectionTypeKeysOnly ProjectionType = "KEYS_ONLY"
	ProjectionTypeInclude  ProjectionType = "INCLUDE"
)

func (enum ProjectionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ProjectionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ReplicaStatus string

// Enum values for ReplicaStatus
const (
	ReplicaStatusCreating ReplicaStatus = "CREATING"
	ReplicaStatusUpdating ReplicaStatus = "UPDATING"
	ReplicaStatusDeleting ReplicaStatus = "DELETING"
	ReplicaStatusActive   ReplicaStatus = "ACTIVE"
)

func (enum ReplicaStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReplicaStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// Determines the level of detail about provisioned throughput consumption that
// is returned in the response:
//
//    * INDEXES - The response includes the aggregate ConsumedCapacity for the
//    operation, together with ConsumedCapacity for each table and secondary
//    index that was accessed.
//
// Note that some operations, such as GetItem and BatchGetItem, do not access
//    any indexes at all. In these cases, specifying INDEXES will only return
//    ConsumedCapacity information for table(s).
//
//    * TOTAL - The response includes only the aggregate ConsumedCapacity for
//    the operation.
//
//    * NONE - No ConsumedCapacity details are included in the response.
type ReturnConsumedCapacity string

// Enum values for ReturnConsumedCapacity
const (
	ReturnConsumedCapacityIndexes ReturnConsumedCapacity = "INDEXES"
	ReturnConsumedCapacityTotal   ReturnConsumedCapacity = "TOTAL"
	ReturnConsumedCapacityNone    ReturnConsumedCapacity = "NONE"
)

func (enum ReturnConsumedCapacity) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReturnConsumedCapacity) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ReturnItemCollectionMetrics string

// Enum values for ReturnItemCollectionMetrics
const (
	ReturnItemCollectionMetricsSize ReturnItemCollectionMetrics = "SIZE"
	ReturnItemCollectionMetricsNone ReturnItemCollectionMetrics = "NONE"
)

func (enum ReturnItemCollectionMetrics) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReturnItemCollectionMetrics) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ReturnValue string

// Enum values for ReturnValue
const (
	ReturnValueNone       ReturnValue = "NONE"
	ReturnValueAllOld     ReturnValue = "ALL_OLD"
	ReturnValueUpdatedOld ReturnValue = "UPDATED_OLD"
	ReturnValueAllNew     ReturnValue = "ALL_NEW"
	ReturnValueUpdatedNew ReturnValue = "UPDATED_NEW"
)

func (enum ReturnValue) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReturnValue) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ReturnValuesOnConditionCheckFailure string

// Enum values for ReturnValuesOnConditionCheckFailure
const (
	ReturnValuesOnConditionCheckFailureAllOld ReturnValuesOnConditionCheckFailure = "ALL_OLD"
	ReturnValuesOnConditionCheckFailureNone   ReturnValuesOnConditionCheckFailure = "NONE"
)

func (enum ReturnValuesOnConditionCheckFailure) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReturnValuesOnConditionCheckFailure) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SSEStatus string

// Enum values for SSEStatus
const (
	SSEStatusEnabling  SSEStatus = "ENABLING"
	SSEStatusEnabled   SSEStatus = "ENABLED"
	SSEStatusDisabling SSEStatus = "DISABLING"
	SSEStatusDisabled  SSEStatus = "DISABLED"
	SSEStatusUpdating  SSEStatus = "UPDATING"
)

func (enum SSEStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SSEStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type SSEType string

// Enum values for SSEType
const (
	SSETypeAes256 SSEType = "AES256"
	SSETypeKms    SSEType = "KMS"
)

func (enum SSEType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SSEType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ScalarAttributeType string

// Enum values for ScalarAttributeType
const (
	ScalarAttributeTypeS ScalarAttributeType = "S"
	ScalarAttributeTypeN ScalarAttributeType = "N"
	ScalarAttributeTypeB ScalarAttributeType = "B"
)

func (enum ScalarAttributeType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ScalarAttributeType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Select string

// Enum values for Select
const (
	SelectAllAttributes          Select = "ALL_ATTRIBUTES"
	SelectAllProjectedAttributes Select = "ALL_PROJECTED_ATTRIBUTES"
	SelectSpecificAttributes     Select = "SPECIFIC_ATTRIBUTES"
	SelectCount                  Select = "COUNT"
)

func (enum Select) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Select) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type StreamViewType string

// Enum values for StreamViewType
const (
	StreamViewTypeNewImage        StreamViewType = "NEW_IMAGE"
	StreamViewTypeOldImage        StreamViewType = "OLD_IMAGE"
	StreamViewTypeNewAndOldImages StreamViewType = "NEW_AND_OLD_IMAGES"
	StreamViewTypeKeysOnly        StreamViewType = "KEYS_ONLY"
)

func (enum StreamViewType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum StreamViewType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type TableStatus string

// Enum values for TableStatus
const (
	TableStatusCreating TableStatus = "CREATING"
	TableStatusUpdating TableStatus = "UPDATING"
	TableStatusDeleting TableStatus = "DELETING"
	TableStatusActive   TableStatus = "ACTIVE"
)

func (enum TableStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum TableStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type TimeToLiveStatus string

// Enum values for TimeToLiveStatus
const (
	TimeToLiveStatusEnabling  TimeToLiveStatus = "ENABLING"
	TimeToLiveStatusDisabling TimeToLiveStatus = "DISABLING"
	TimeToLiveStatusEnabled   TimeToLiveStatus = "ENABLED"
	TimeToLiveStatusDisabled  TimeToLiveStatus = "DISABLED"
)

func (enum TimeToLiveStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum TimeToLiveStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
