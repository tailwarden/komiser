// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package mq

import (
	"context"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opCreateBroker = "CreateBroker"

// CreateBrokerRequest is a API request type for the CreateBroker API operation.
type CreateBrokerRequest struct {
	*aws.Request
	Input *CreateBrokerInput
	Copy  func(*CreateBrokerInput) CreateBrokerRequest
}

// Send marshals and sends the CreateBroker API request.
func (r CreateBrokerRequest) Send(ctx context.Context) (*CreateBrokerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateBrokerOutput), nil
}

// CreateBrokerRequest returns a request value for making API operation for
// AmazonMQ.
//
// Creates a broker. Note: This API is asynchronous.
//
//    // Example sending a request using the CreateBrokerRequest method.
//    req := client.CreateBrokerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateBroker
func (c *MQ) CreateBrokerRequest(input *CreateBrokerInput) CreateBrokerRequest {
	op := &aws.Operation{
		Name:       opCreateBroker,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/brokers",
	}

	if input == nil {
		input = &CreateBrokerInput{}
	}

	output := &CreateBrokerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBrokerRequest{Request: req, Input: input, Copy: c.CreateBrokerRequest}
}

const opCreateConfiguration = "CreateConfiguration"

// CreateConfigurationRequest is a API request type for the CreateConfiguration API operation.
type CreateConfigurationRequest struct {
	*aws.Request
	Input *CreateConfigurationInput
	Copy  func(*CreateConfigurationInput) CreateConfigurationRequest
}

// Send marshals and sends the CreateConfiguration API request.
func (r CreateConfigurationRequest) Send(ctx context.Context) (*CreateConfigurationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateConfigurationOutput), nil
}

// CreateConfigurationRequest returns a request value for making API operation for
// AmazonMQ.
//
// Creates a new configuration for the specified configuration name. Amazon
// MQ uses the default configuration (the engine type and version).
//
//    // Example sending a request using the CreateConfigurationRequest method.
//    req := client.CreateConfigurationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateConfiguration
func (c *MQ) CreateConfigurationRequest(input *CreateConfigurationInput) CreateConfigurationRequest {
	op := &aws.Operation{
		Name:       opCreateConfiguration,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/configurations",
	}

	if input == nil {
		input = &CreateConfigurationInput{}
	}

	output := &CreateConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateConfigurationRequest{Request: req, Input: input, Copy: c.CreateConfigurationRequest}
}

const opCreateTags = "CreateTags"

// CreateTagsRequest is a API request type for the CreateTags API operation.
type CreateTagsRequest struct {
	*aws.Request
	Input *CreateTagsInput
	Copy  func(*CreateTagsInput) CreateTagsRequest
}

// Send marshals and sends the CreateTags API request.
func (r CreateTagsRequest) Send(ctx context.Context) (*CreateTagsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTagsOutput), nil
}

// CreateTagsRequest returns a request value for making API operation for
// AmazonMQ.
//
// Add a tag to a resource.
//
//    // Example sending a request using the CreateTagsRequest method.
//    req := client.CreateTagsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateTags
func (c *MQ) CreateTagsRequest(input *CreateTagsInput) CreateTagsRequest {
	op := &aws.Operation{
		Name:       opCreateTags,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/tags/{resource-arn}",
	}

	if input == nil {
		input = &CreateTagsInput{}
	}

	output := &CreateTagsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTagsRequest{Request: req, Input: input, Copy: c.CreateTagsRequest}
}

const opCreateUser = "CreateUser"

// CreateUserRequest is a API request type for the CreateUser API operation.
type CreateUserRequest struct {
	*aws.Request
	Input *CreateUserInput
	Copy  func(*CreateUserInput) CreateUserRequest
}

// Send marshals and sends the CreateUser API request.
func (r CreateUserRequest) Send(ctx context.Context) (*CreateUserOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateUserOutput), nil
}

// CreateUserRequest returns a request value for making API operation for
// AmazonMQ.
//
// Creates an ActiveMQ user.
//
//    // Example sending a request using the CreateUserRequest method.
//    req := client.CreateUserRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateUser
func (c *MQ) CreateUserRequest(input *CreateUserInput) CreateUserRequest {
	op := &aws.Operation{
		Name:       opCreateUser,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/brokers/{broker-id}/users/{username}",
	}

	if input == nil {
		input = &CreateUserInput{}
	}

	output := &CreateUserOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateUserRequest{Request: req, Input: input, Copy: c.CreateUserRequest}
}

const opDeleteBroker = "DeleteBroker"

// DeleteBrokerRequest is a API request type for the DeleteBroker API operation.
type DeleteBrokerRequest struct {
	*aws.Request
	Input *DeleteBrokerInput
	Copy  func(*DeleteBrokerInput) DeleteBrokerRequest
}

// Send marshals and sends the DeleteBroker API request.
func (r DeleteBrokerRequest) Send(ctx context.Context) (*DeleteBrokerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBrokerOutput), nil
}

// DeleteBrokerRequest returns a request value for making API operation for
// AmazonMQ.
//
// Deletes a broker. Note: This API is asynchronous.
//
//    // Example sending a request using the DeleteBrokerRequest method.
//    req := client.DeleteBrokerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteBroker
func (c *MQ) DeleteBrokerRequest(input *DeleteBrokerInput) DeleteBrokerRequest {
	op := &aws.Operation{
		Name:       opDeleteBroker,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/brokers/{broker-id}",
	}

	if input == nil {
		input = &DeleteBrokerInput{}
	}

	output := &DeleteBrokerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBrokerRequest{Request: req, Input: input, Copy: c.DeleteBrokerRequest}
}

const opDeleteTags = "DeleteTags"

// DeleteTagsRequest is a API request type for the DeleteTags API operation.
type DeleteTagsRequest struct {
	*aws.Request
	Input *DeleteTagsInput
	Copy  func(*DeleteTagsInput) DeleteTagsRequest
}

// Send marshals and sends the DeleteTags API request.
func (r DeleteTagsRequest) Send(ctx context.Context) (*DeleteTagsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTagsOutput), nil
}

// DeleteTagsRequest returns a request value for making API operation for
// AmazonMQ.
//
// Remove a tag from a resource.
//
//    // Example sending a request using the DeleteTagsRequest method.
//    req := client.DeleteTagsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteTags
func (c *MQ) DeleteTagsRequest(input *DeleteTagsInput) DeleteTagsRequest {
	op := &aws.Operation{
		Name:       opDeleteTags,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/tags/{resource-arn}",
	}

	if input == nil {
		input = &DeleteTagsInput{}
	}

	output := &DeleteTagsOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTagsRequest{Request: req, Input: input, Copy: c.DeleteTagsRequest}
}

const opDeleteUser = "DeleteUser"

// DeleteUserRequest is a API request type for the DeleteUser API operation.
type DeleteUserRequest struct {
	*aws.Request
	Input *DeleteUserInput
	Copy  func(*DeleteUserInput) DeleteUserRequest
}

// Send marshals and sends the DeleteUser API request.
func (r DeleteUserRequest) Send(ctx context.Context) (*DeleteUserOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteUserOutput), nil
}

// DeleteUserRequest returns a request value for making API operation for
// AmazonMQ.
//
// Deletes an ActiveMQ user.
//
//    // Example sending a request using the DeleteUserRequest method.
//    req := client.DeleteUserRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteUser
func (c *MQ) DeleteUserRequest(input *DeleteUserInput) DeleteUserRequest {
	op := &aws.Operation{
		Name:       opDeleteUser,
		HTTPMethod: "DELETE",
		HTTPPath:   "/v1/brokers/{broker-id}/users/{username}",
	}

	if input == nil {
		input = &DeleteUserInput{}
	}

	output := &DeleteUserOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteUserRequest{Request: req, Input: input, Copy: c.DeleteUserRequest}
}

const opDescribeBroker = "DescribeBroker"

// DescribeBrokerRequest is a API request type for the DescribeBroker API operation.
type DescribeBrokerRequest struct {
	*aws.Request
	Input *DescribeBrokerInput
	Copy  func(*DescribeBrokerInput) DescribeBrokerRequest
}

// Send marshals and sends the DescribeBroker API request.
func (r DescribeBrokerRequest) Send(ctx context.Context) (*DescribeBrokerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeBrokerOutput), nil
}

// DescribeBrokerRequest returns a request value for making API operation for
// AmazonMQ.
//
// Returns information about the specified broker.
//
//    // Example sending a request using the DescribeBrokerRequest method.
//    req := client.DescribeBrokerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeBroker
func (c *MQ) DescribeBrokerRequest(input *DescribeBrokerInput) DescribeBrokerRequest {
	op := &aws.Operation{
		Name:       opDescribeBroker,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/brokers/{broker-id}",
	}

	if input == nil {
		input = &DescribeBrokerInput{}
	}

	output := &DescribeBrokerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeBrokerRequest{Request: req, Input: input, Copy: c.DescribeBrokerRequest}
}

const opDescribeConfiguration = "DescribeConfiguration"

// DescribeConfigurationRequest is a API request type for the DescribeConfiguration API operation.
type DescribeConfigurationRequest struct {
	*aws.Request
	Input *DescribeConfigurationInput
	Copy  func(*DescribeConfigurationInput) DescribeConfigurationRequest
}

// Send marshals and sends the DescribeConfiguration API request.
func (r DescribeConfigurationRequest) Send(ctx context.Context) (*DescribeConfigurationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeConfigurationOutput), nil
}

// DescribeConfigurationRequest returns a request value for making API operation for
// AmazonMQ.
//
// Returns information about the specified configuration.
//
//    // Example sending a request using the DescribeConfigurationRequest method.
//    req := client.DescribeConfigurationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeConfiguration
func (c *MQ) DescribeConfigurationRequest(input *DescribeConfigurationInput) DescribeConfigurationRequest {
	op := &aws.Operation{
		Name:       opDescribeConfiguration,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/configurations/{configuration-id}",
	}

	if input == nil {
		input = &DescribeConfigurationInput{}
	}

	output := &DescribeConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeConfigurationRequest{Request: req, Input: input, Copy: c.DescribeConfigurationRequest}
}

const opDescribeConfigurationRevision = "DescribeConfigurationRevision"

// DescribeConfigurationRevisionRequest is a API request type for the DescribeConfigurationRevision API operation.
type DescribeConfigurationRevisionRequest struct {
	*aws.Request
	Input *DescribeConfigurationRevisionInput
	Copy  func(*DescribeConfigurationRevisionInput) DescribeConfigurationRevisionRequest
}

// Send marshals and sends the DescribeConfigurationRevision API request.
func (r DescribeConfigurationRevisionRequest) Send(ctx context.Context) (*DescribeConfigurationRevisionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeConfigurationRevisionOutput), nil
}

// DescribeConfigurationRevisionRequest returns a request value for making API operation for
// AmazonMQ.
//
// Returns the specified configuration revision for the specified configuration.
//
//    // Example sending a request using the DescribeConfigurationRevisionRequest method.
//    req := client.DescribeConfigurationRevisionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeConfigurationRevision
func (c *MQ) DescribeConfigurationRevisionRequest(input *DescribeConfigurationRevisionInput) DescribeConfigurationRevisionRequest {
	op := &aws.Operation{
		Name:       opDescribeConfigurationRevision,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/configurations/{configuration-id}/revisions/{configuration-revision}",
	}

	if input == nil {
		input = &DescribeConfigurationRevisionInput{}
	}

	output := &DescribeConfigurationRevisionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeConfigurationRevisionRequest{Request: req, Input: input, Copy: c.DescribeConfigurationRevisionRequest}
}

const opDescribeUser = "DescribeUser"

// DescribeUserRequest is a API request type for the DescribeUser API operation.
type DescribeUserRequest struct {
	*aws.Request
	Input *DescribeUserInput
	Copy  func(*DescribeUserInput) DescribeUserRequest
}

// Send marshals and sends the DescribeUser API request.
func (r DescribeUserRequest) Send(ctx context.Context) (*DescribeUserOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DescribeUserOutput), nil
}

// DescribeUserRequest returns a request value for making API operation for
// AmazonMQ.
//
// Returns information about an ActiveMQ user.
//
//    // Example sending a request using the DescribeUserRequest method.
//    req := client.DescribeUserRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeUser
func (c *MQ) DescribeUserRequest(input *DescribeUserInput) DescribeUserRequest {
	op := &aws.Operation{
		Name:       opDescribeUser,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/brokers/{broker-id}/users/{username}",
	}

	if input == nil {
		input = &DescribeUserInput{}
	}

	output := &DescribeUserOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DescribeUserRequest{Request: req, Input: input, Copy: c.DescribeUserRequest}
}

const opListBrokers = "ListBrokers"

// ListBrokersRequest is a API request type for the ListBrokers API operation.
type ListBrokersRequest struct {
	*aws.Request
	Input *ListBrokersInput
	Copy  func(*ListBrokersInput) ListBrokersRequest
}

// Send marshals and sends the ListBrokers API request.
func (r ListBrokersRequest) Send(ctx context.Context) (*ListBrokersOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListBrokersOutput), nil
}

// ListBrokersRequest returns a request value for making API operation for
// AmazonMQ.
//
// Returns a list of all brokers.
//
//    // Example sending a request using the ListBrokersRequest method.
//    req := client.ListBrokersRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListBrokers
func (c *MQ) ListBrokersRequest(input *ListBrokersInput) ListBrokersRequest {
	op := &aws.Operation{
		Name:       opListBrokers,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/brokers",
	}

	if input == nil {
		input = &ListBrokersInput{}
	}

	output := &ListBrokersOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListBrokersRequest{Request: req, Input: input, Copy: c.ListBrokersRequest}
}

const opListConfigurationRevisions = "ListConfigurationRevisions"

// ListConfigurationRevisionsRequest is a API request type for the ListConfigurationRevisions API operation.
type ListConfigurationRevisionsRequest struct {
	*aws.Request
	Input *ListConfigurationRevisionsInput
	Copy  func(*ListConfigurationRevisionsInput) ListConfigurationRevisionsRequest
}

// Send marshals and sends the ListConfigurationRevisions API request.
func (r ListConfigurationRevisionsRequest) Send(ctx context.Context) (*ListConfigurationRevisionsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListConfigurationRevisionsOutput), nil
}

// ListConfigurationRevisionsRequest returns a request value for making API operation for
// AmazonMQ.
//
// Returns a list of all revisions for the specified configuration.
//
//    // Example sending a request using the ListConfigurationRevisionsRequest method.
//    req := client.ListConfigurationRevisionsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListConfigurationRevisions
func (c *MQ) ListConfigurationRevisionsRequest(input *ListConfigurationRevisionsInput) ListConfigurationRevisionsRequest {
	op := &aws.Operation{
		Name:       opListConfigurationRevisions,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/configurations/{configuration-id}/revisions",
	}

	if input == nil {
		input = &ListConfigurationRevisionsInput{}
	}

	output := &ListConfigurationRevisionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListConfigurationRevisionsRequest{Request: req, Input: input, Copy: c.ListConfigurationRevisionsRequest}
}

const opListConfigurations = "ListConfigurations"

// ListConfigurationsRequest is a API request type for the ListConfigurations API operation.
type ListConfigurationsRequest struct {
	*aws.Request
	Input *ListConfigurationsInput
	Copy  func(*ListConfigurationsInput) ListConfigurationsRequest
}

// Send marshals and sends the ListConfigurations API request.
func (r ListConfigurationsRequest) Send(ctx context.Context) (*ListConfigurationsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListConfigurationsOutput), nil
}

// ListConfigurationsRequest returns a request value for making API operation for
// AmazonMQ.
//
// Returns a list of all configurations.
//
//    // Example sending a request using the ListConfigurationsRequest method.
//    req := client.ListConfigurationsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListConfigurations
func (c *MQ) ListConfigurationsRequest(input *ListConfigurationsInput) ListConfigurationsRequest {
	op := &aws.Operation{
		Name:       opListConfigurations,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/configurations",
	}

	if input == nil {
		input = &ListConfigurationsInput{}
	}

	output := &ListConfigurationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListConfigurationsRequest{Request: req, Input: input, Copy: c.ListConfigurationsRequest}
}

const opListTags = "ListTags"

// ListTagsRequest is a API request type for the ListTags API operation.
type ListTagsRequest struct {
	*aws.Request
	Input *ListTagsInput
	Copy  func(*ListTagsInput) ListTagsRequest
}

// Send marshals and sends the ListTags API request.
func (r ListTagsRequest) Send(ctx context.Context) (*ListTagsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTagsOutput), nil
}

// ListTagsRequest returns a request value for making API operation for
// AmazonMQ.
//
// Lists tags for a resource.
//
//    // Example sending a request using the ListTagsRequest method.
//    req := client.ListTagsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListTags
func (c *MQ) ListTagsRequest(input *ListTagsInput) ListTagsRequest {
	op := &aws.Operation{
		Name:       opListTags,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/tags/{resource-arn}",
	}

	if input == nil {
		input = &ListTagsInput{}
	}

	output := &ListTagsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTagsRequest{Request: req, Input: input, Copy: c.ListTagsRequest}
}

const opListUsers = "ListUsers"

// ListUsersRequest is a API request type for the ListUsers API operation.
type ListUsersRequest struct {
	*aws.Request
	Input *ListUsersInput
	Copy  func(*ListUsersInput) ListUsersRequest
}

// Send marshals and sends the ListUsers API request.
func (r ListUsersRequest) Send(ctx context.Context) (*ListUsersOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListUsersOutput), nil
}

// ListUsersRequest returns a request value for making API operation for
// AmazonMQ.
//
// Returns a list of all ActiveMQ users.
//
//    // Example sending a request using the ListUsersRequest method.
//    req := client.ListUsersRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListUsers
func (c *MQ) ListUsersRequest(input *ListUsersInput) ListUsersRequest {
	op := &aws.Operation{
		Name:       opListUsers,
		HTTPMethod: "GET",
		HTTPPath:   "/v1/brokers/{broker-id}/users",
	}

	if input == nil {
		input = &ListUsersInput{}
	}

	output := &ListUsersOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListUsersRequest{Request: req, Input: input, Copy: c.ListUsersRequest}
}

const opRebootBroker = "RebootBroker"

// RebootBrokerRequest is a API request type for the RebootBroker API operation.
type RebootBrokerRequest struct {
	*aws.Request
	Input *RebootBrokerInput
	Copy  func(*RebootBrokerInput) RebootBrokerRequest
}

// Send marshals and sends the RebootBroker API request.
func (r RebootBrokerRequest) Send(ctx context.Context) (*RebootBrokerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*RebootBrokerOutput), nil
}

// RebootBrokerRequest returns a request value for making API operation for
// AmazonMQ.
//
// Reboots a broker. Note: This API is asynchronous.
//
//    // Example sending a request using the RebootBrokerRequest method.
//    req := client.RebootBrokerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/RebootBroker
func (c *MQ) RebootBrokerRequest(input *RebootBrokerInput) RebootBrokerRequest {
	op := &aws.Operation{
		Name:       opRebootBroker,
		HTTPMethod: "POST",
		HTTPPath:   "/v1/brokers/{broker-id}/reboot",
	}

	if input == nil {
		input = &RebootBrokerInput{}
	}

	output := &RebootBrokerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return RebootBrokerRequest{Request: req, Input: input, Copy: c.RebootBrokerRequest}
}

const opUpdateBroker = "UpdateBroker"

// UpdateBrokerRequest is a API request type for the UpdateBroker API operation.
type UpdateBrokerRequest struct {
	*aws.Request
	Input *UpdateBrokerInput
	Copy  func(*UpdateBrokerInput) UpdateBrokerRequest
}

// Send marshals and sends the UpdateBroker API request.
func (r UpdateBrokerRequest) Send(ctx context.Context) (*UpdateBrokerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateBrokerOutput), nil
}

// UpdateBrokerRequest returns a request value for making API operation for
// AmazonMQ.
//
// Adds a pending configuration change to a broker.
//
//    // Example sending a request using the UpdateBrokerRequest method.
//    req := client.UpdateBrokerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateBroker
func (c *MQ) UpdateBrokerRequest(input *UpdateBrokerInput) UpdateBrokerRequest {
	op := &aws.Operation{
		Name:       opUpdateBroker,
		HTTPMethod: "PUT",
		HTTPPath:   "/v1/brokers/{broker-id}",
	}

	if input == nil {
		input = &UpdateBrokerInput{}
	}

	output := &UpdateBrokerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateBrokerRequest{Request: req, Input: input, Copy: c.UpdateBrokerRequest}
}

const opUpdateConfiguration = "UpdateConfiguration"

// UpdateConfigurationRequest is a API request type for the UpdateConfiguration API operation.
type UpdateConfigurationRequest struct {
	*aws.Request
	Input *UpdateConfigurationInput
	Copy  func(*UpdateConfigurationInput) UpdateConfigurationRequest
}

// Send marshals and sends the UpdateConfiguration API request.
func (r UpdateConfigurationRequest) Send(ctx context.Context) (*UpdateConfigurationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateConfigurationOutput), nil
}

// UpdateConfigurationRequest returns a request value for making API operation for
// AmazonMQ.
//
// Updates the specified configuration.
//
//    // Example sending a request using the UpdateConfigurationRequest method.
//    req := client.UpdateConfigurationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateConfiguration
func (c *MQ) UpdateConfigurationRequest(input *UpdateConfigurationInput) UpdateConfigurationRequest {
	op := &aws.Operation{
		Name:       opUpdateConfiguration,
		HTTPMethod: "PUT",
		HTTPPath:   "/v1/configurations/{configuration-id}",
	}

	if input == nil {
		input = &UpdateConfigurationInput{}
	}

	output := &UpdateConfigurationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateConfigurationRequest{Request: req, Input: input, Copy: c.UpdateConfigurationRequest}
}

const opUpdateUser = "UpdateUser"

// UpdateUserRequest is a API request type for the UpdateUser API operation.
type UpdateUserRequest struct {
	*aws.Request
	Input *UpdateUserInput
	Copy  func(*UpdateUserInput) UpdateUserRequest
}

// Send marshals and sends the UpdateUser API request.
func (r UpdateUserRequest) Send(ctx context.Context) (*UpdateUserOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateUserOutput), nil
}

// UpdateUserRequest returns a request value for making API operation for
// AmazonMQ.
//
// Updates the information for an ActiveMQ user.
//
//    // Example sending a request using the UpdateUserRequest method.
//    req := client.UpdateUserRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateUser
func (c *MQ) UpdateUserRequest(input *UpdateUserInput) UpdateUserRequest {
	op := &aws.Operation{
		Name:       opUpdateUser,
		HTTPMethod: "PUT",
		HTTPPath:   "/v1/brokers/{broker-id}/users/{username}",
	}

	if input == nil {
		input = &UpdateUserInput{}
	}

	output := &UpdateUserOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateUserRequest{Request: req, Input: input, Copy: c.UpdateUserRequest}
}

// Returns information about all brokers.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/BrokerInstance
type BrokerInstance struct {
	_ struct{} `type:"structure"`

	// The URL of the broker's ActiveMQ Web Console.
	ConsoleURL *string `locationName:"consoleURL" type:"string"`

	// The broker's wire-level protocol endpoints.
	Endpoints []string `locationName:"endpoints" type:"list"`

	// The IP address of the Elastic Network Interface (ENI) attached to the broker.
	IpAddress *string `locationName:"ipAddress" type:"string"`
}

// String returns the string representation
func (s BrokerInstance) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BrokerInstance) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BrokerInstance) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConsoleURL != nil {
		v := *s.ConsoleURL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "consoleURL", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Endpoints) > 0 {
		v := s.Endpoints

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "endpoints", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.IpAddress != nil {
		v := *s.IpAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ipAddress", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The Amazon Resource Name (ARN) of the broker.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/BrokerSummary
type BrokerSummary struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the broker.
	BrokerArn *string `locationName:"brokerArn" type:"string"`

	// The unique ID that Amazon MQ generates for the broker.
	BrokerId *string `locationName:"brokerId" type:"string"`

	// The name of the broker. This value must be unique in your AWS account, 1-50
	// characters long, must contain only letters, numbers, dashes, and underscores,
	// and must not contain whitespaces, brackets, wildcard characters, or special
	// characters.
	BrokerName *string `locationName:"brokerName" type:"string"`

	// The status of the broker.
	BrokerState BrokerState `locationName:"brokerState" type:"string" enum:"true"`

	// The time when the broker was created.
	Created *time.Time `locationName:"created" type:"timestamp" timestampFormat:"unix"`

	// Required. The deployment mode of the broker.
	DeploymentMode DeploymentMode `locationName:"deploymentMode" type:"string" enum:"true"`

	// The broker's instance type.
	HostInstanceType *string `locationName:"hostInstanceType" type:"string"`
}

// String returns the string representation
func (s BrokerSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BrokerSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s BrokerSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.BrokerArn != nil {
		v := *s.BrokerArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BrokerName != nil {
		v := *s.BrokerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.BrokerState) > 0 {
		v := s.BrokerState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "created", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.DeploymentMode) > 0 {
		v := s.DeploymentMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deploymentMode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.HostInstanceType != nil {
		v := *s.HostInstanceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hostInstanceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Returns information about all configurations.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/Configuration
type Configuration struct {
	_ struct{} `type:"structure"`

	// Required. The ARN of the configuration.
	Arn *string `locationName:"arn" type:"string"`

	// Required. The date and time of the configuration revision.
	Created *time.Time `locationName:"created" type:"timestamp" timestampFormat:"unix"`

	// Required. The description of the configuration.
	Description *string `locationName:"description" type:"string"`

	// Required. The type of broker engine. Note: Currently, Amazon MQ supports
	// only ACTIVEMQ.
	EngineType EngineType `locationName:"engineType" type:"string" enum:"true"`

	// Required. The version of the broker engine. For a list of supported engine
	// versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
	EngineVersion *string `locationName:"engineVersion" type:"string"`

	// Required. The unique ID that Amazon MQ generates for the configuration.
	Id *string `locationName:"id" type:"string"`

	// Required. The latest revision of the configuration.
	LatestRevision *ConfigurationRevision `locationName:"latestRevision" type:"structure"`

	// Required. The name of the configuration. This value can contain only alphanumeric
	// characters, dashes, periods, underscores, and tildes (- . _ ~). This value
	// must be 1-150 characters long.
	Name *string `locationName:"name" type:"string"`

	// The list of all tags associated with this configuration.
	Tags map[string]string `locationName:"tags" type:"map"`
}

// String returns the string representation
func (s Configuration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Configuration) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Configuration) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "created", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EngineType) > 0 {
		v := s.EngineType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.EngineVersion != nil {
		v := *s.EngineVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LatestRevision != nil {
		v := s.LatestRevision

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "latestRevision", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// A list of information about the configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ConfigurationId
type ConfigurationId struct {
	_ struct{} `type:"structure"`

	// Required. The unique ID that Amazon MQ generates for the configuration.
	Id *string `locationName:"id" type:"string"`

	// The revision number of the configuration.
	Revision *int64 `locationName:"revision" type:"integer"`
}

// String returns the string representation
func (s ConfigurationId) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ConfigurationId) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ConfigurationId) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Revision != nil {
		v := *s.Revision

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "revision", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Returns information about the specified configuration revision.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ConfigurationRevision
type ConfigurationRevision struct {
	_ struct{} `type:"structure"`

	// Required. The date and time of the configuration revision.
	Created *time.Time `locationName:"created" type:"timestamp" timestampFormat:"unix"`

	// The description of the configuration revision.
	Description *string `locationName:"description" type:"string"`

	// Required. The revision number of the configuration.
	Revision *int64 `locationName:"revision" type:"integer"`
}

// String returns the string representation
func (s ConfigurationRevision) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ConfigurationRevision) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ConfigurationRevision) MarshalFields(e protocol.FieldEncoder) error {
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "created", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Revision != nil {
		v := *s.Revision

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "revision", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Broker configuration information
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/Configurations
type Configurations struct {
	_ struct{} `type:"structure"`

	// The current configuration of the broker.
	Current *ConfigurationId `locationName:"current" type:"structure"`

	// The history of configurations applied to the broker.
	History []ConfigurationId `locationName:"history" type:"list"`

	// The pending configuration of the broker.
	Pending *ConfigurationId `locationName:"pending" type:"structure"`
}

// String returns the string representation
func (s Configurations) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Configurations) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Configurations) MarshalFields(e protocol.FieldEncoder) error {
	if s.Current != nil {
		v := s.Current

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "current", v, metadata)
	}
	if len(s.History) > 0 {
		v := s.History

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "history", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Pending != nil {
		v := s.Pending

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "pending", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateBrokerRequest
type CreateBrokerInput struct {
	_ struct{} `type:"structure"`

	AutoMinorVersionUpgrade *bool `locationName:"autoMinorVersionUpgrade" type:"boolean"`

	BrokerName *string `locationName:"brokerName" type:"string"`

	// A list of information about the configuration.
	Configuration *ConfigurationId `locationName:"configuration" type:"structure"`

	CreatorRequestId *string `locationName:"creatorRequestId" type:"string" idempotencyToken:"true"`

	// The deployment mode of the broker.
	DeploymentMode DeploymentMode `locationName:"deploymentMode" type:"string" enum:"true"`

	// The type of broker engine. Note: Currently, Amazon MQ supports only ActiveMQ.
	EngineType EngineType `locationName:"engineType" type:"string" enum:"true"`

	EngineVersion *string `locationName:"engineVersion" type:"string"`

	HostInstanceType *string `locationName:"hostInstanceType" type:"string"`

	// The list of information about logs to be enabled for the specified broker.
	Logs *Logs `locationName:"logs" type:"structure"`

	// The scheduled time period relative to UTC during which Amazon MQ begins to
	// apply pending updates or patches to the broker.
	MaintenanceWindowStartTime *WeeklyStartTime `locationName:"maintenanceWindowStartTime" type:"structure"`

	PubliclyAccessible *bool `locationName:"publiclyAccessible" type:"boolean"`

	SecurityGroups []string `locationName:"securityGroups" type:"list"`

	SubnetIds []string `locationName:"subnetIds" type:"list"`

	Tags map[string]string `locationName:"tags" type:"map"`

	Users []User `locationName:"users" type:"list"`
}

// String returns the string representation
func (s CreateBrokerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBrokerInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBrokerInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AutoMinorVersionUpgrade != nil {
		v := *s.AutoMinorVersionUpgrade

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "autoMinorVersionUpgrade", protocol.BoolValue(v), metadata)
	}
	if s.BrokerName != nil {
		v := *s.BrokerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Configuration != nil {
		v := s.Configuration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "configuration", v, metadata)
	}
	var CreatorRequestId string
	if s.CreatorRequestId != nil {
		CreatorRequestId = *s.CreatorRequestId
	} else {
		CreatorRequestId = protocol.GetIdempotencyToken()
	}
	{
		v := CreatorRequestId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "creatorRequestId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.DeploymentMode) > 0 {
		v := s.DeploymentMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deploymentMode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.EngineType) > 0 {
		v := s.EngineType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.EngineVersion != nil {
		v := *s.EngineVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HostInstanceType != nil {
		v := *s.HostInstanceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hostInstanceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Logs != nil {
		v := s.Logs

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logs", v, metadata)
	}
	if s.MaintenanceWindowStartTime != nil {
		v := s.MaintenanceWindowStartTime

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "maintenanceWindowStartTime", v, metadata)
	}
	if s.PubliclyAccessible != nil {
		v := *s.PubliclyAccessible

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "publiclyAccessible", protocol.BoolValue(v), metadata)
	}
	if len(s.SecurityGroups) > 0 {
		v := s.SecurityGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "securityGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.SubnetIds) > 0 {
		v := s.SubnetIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "subnetIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.Users) > 0 {
		v := s.Users

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "users", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateBrokerResponse
type CreateBrokerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	BrokerArn *string `locationName:"brokerArn" type:"string"`

	BrokerId *string `locationName:"brokerId" type:"string"`
}

// String returns the string representation
func (s CreateBrokerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBrokerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateBrokerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBrokerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BrokerArn != nil {
		v := *s.BrokerArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateConfigurationRequest
type CreateConfigurationInput struct {
	_ struct{} `type:"structure"`

	// The type of broker engine. Note: Currently, Amazon MQ supports only ActiveMQ.
	EngineType EngineType `locationName:"engineType" type:"string" enum:"true"`

	EngineVersion *string `locationName:"engineVersion" type:"string"`

	Name *string `locationName:"name" type:"string"`

	Tags map[string]string `locationName:"tags" type:"map"`
}

// String returns the string representation
func (s CreateConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateConfigurationInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateConfigurationInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.EngineType) > 0 {
		v := s.EngineType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.EngineVersion != nil {
		v := *s.EngineVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateConfigurationResponse
type CreateConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	Created *time.Time `locationName:"created" type:"timestamp" timestampFormat:"unix"`

	Id *string `locationName:"id" type:"string"`

	// Returns information about the specified configuration revision.
	LatestRevision *ConfigurationRevision `locationName:"latestRevision" type:"structure"`

	Name *string `locationName:"name" type:"string"`
}

// String returns the string representation
func (s CreateConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateConfigurationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "created", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LatestRevision != nil {
		v := s.LatestRevision

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "latestRevision", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateTagsRequest
type CreateTagsInput struct {
	_ struct{} `type:"structure"`

	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resource-arn" type:"string" required:"true"`

	Tags map[string]string `locationName:"tags" type:"map"`
}

// String returns the string representation
func (s CreateTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTagsInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTagsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource-arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateTagsOutput
type CreateTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateUserRequest
type CreateUserInput struct {
	_ struct{} `type:"structure"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`

	ConsoleAccess *bool `locationName:"consoleAccess" type:"boolean"`

	Groups []string `locationName:"groups" type:"list"`

	Password *string `locationName:"password" type:"string"`

	// Username is a required field
	Username *string `location:"uri" locationName:"username" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateUserInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}

	if s.Username == nil {
		invalidParams.Add(aws.NewErrParamRequired("Username"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ConsoleAccess != nil {
		v := *s.ConsoleAccess

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "consoleAccess", protocol.BoolValue(v), metadata)
	}
	if len(s.Groups) > 0 {
		v := s.Groups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "groups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Password != nil {
		v := *s.Password

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "password", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/CreateUserResponse
type CreateUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s CreateUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteBrokerRequest
type DeleteBrokerInput struct {
	_ struct{} `type:"structure"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBrokerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBrokerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBrokerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBrokerInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBrokerInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteBrokerResponse
type DeleteBrokerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	BrokerId *string `locationName:"brokerId" type:"string"`
}

// String returns the string representation
func (s DeleteBrokerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBrokerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBrokerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBrokerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteTagsRequest
type DeleteTagsInput struct {
	_ struct{} `type:"structure"`

	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resource-arn" type:"string" required:"true"`

	// TagKeys is a required field
	TagKeys []string `location:"querystring" locationName:"tagKeys" type:"list" required:"true"`
}

// String returns the string representation
func (s DeleteTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTagsInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if s.TagKeys == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTagsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource-arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TagKeys) > 0 {
		v := s.TagKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.QueryTarget, "tagKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteTagsOutput
type DeleteTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteUserRequest
type DeleteUserInput struct {
	_ struct{} `type:"structure"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`

	// Username is a required field
	Username *string `location:"uri" locationName:"username" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteUserInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}

	if s.Username == nil {
		invalidParams.Add(aws.NewErrParamRequired("Username"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DeleteUserResponse
type DeleteUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeBrokerRequest
type DescribeBrokerInput struct {
	_ struct{} `type:"structure"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeBrokerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBrokerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeBrokerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeBrokerInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeBrokerInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeBrokerResponse
type DescribeBrokerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	AutoMinorVersionUpgrade *bool `locationName:"autoMinorVersionUpgrade" type:"boolean"`

	BrokerArn *string `locationName:"brokerArn" type:"string"`

	BrokerId *string `locationName:"brokerId" type:"string"`

	BrokerInstances []BrokerInstance `locationName:"brokerInstances" type:"list"`

	BrokerName *string `locationName:"brokerName" type:"string"`

	// The status of the broker.
	BrokerState BrokerState `locationName:"brokerState" type:"string" enum:"true"`

	// Broker configuration information
	Configurations *Configurations `locationName:"configurations" type:"structure"`

	Created *time.Time `locationName:"created" type:"timestamp" timestampFormat:"unix"`

	// The deployment mode of the broker.
	DeploymentMode DeploymentMode `locationName:"deploymentMode" type:"string" enum:"true"`

	// The type of broker engine. Note: Currently, Amazon MQ supports only ActiveMQ.
	EngineType EngineType `locationName:"engineType" type:"string" enum:"true"`

	EngineVersion *string `locationName:"engineVersion" type:"string"`

	HostInstanceType *string `locationName:"hostInstanceType" type:"string"`

	// The list of information about logs currently enabled and pending to be deployed
	// for the specified broker.
	Logs *LogsSummary `locationName:"logs" type:"structure"`

	// The scheduled time period relative to UTC during which Amazon MQ begins to
	// apply pending updates or patches to the broker.
	MaintenanceWindowStartTime *WeeklyStartTime `locationName:"maintenanceWindowStartTime" type:"structure"`

	PendingEngineVersion *string `locationName:"pendingEngineVersion" type:"string"`

	PubliclyAccessible *bool `locationName:"publiclyAccessible" type:"boolean"`

	SecurityGroups []string `locationName:"securityGroups" type:"list"`

	SubnetIds []string `locationName:"subnetIds" type:"list"`

	Tags map[string]string `locationName:"tags" type:"map"`

	Users []UserSummary `locationName:"users" type:"list"`
}

// String returns the string representation
func (s DescribeBrokerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBrokerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeBrokerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeBrokerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AutoMinorVersionUpgrade != nil {
		v := *s.AutoMinorVersionUpgrade

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "autoMinorVersionUpgrade", protocol.BoolValue(v), metadata)
	}
	if s.BrokerArn != nil {
		v := *s.BrokerArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.BrokerInstances) > 0 {
		v := s.BrokerInstances

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "brokerInstances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.BrokerName != nil {
		v := *s.BrokerName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.BrokerState) > 0 {
		v := s.BrokerState

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerState", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Configurations != nil {
		v := s.Configurations

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "configurations", v, metadata)
	}
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "created", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.DeploymentMode) > 0 {
		v := s.DeploymentMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deploymentMode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.EngineType) > 0 {
		v := s.EngineType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.EngineVersion != nil {
		v := *s.EngineVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HostInstanceType != nil {
		v := *s.HostInstanceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "hostInstanceType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Logs != nil {
		v := s.Logs

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logs", v, metadata)
	}
	if s.MaintenanceWindowStartTime != nil {
		v := s.MaintenanceWindowStartTime

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "maintenanceWindowStartTime", v, metadata)
	}
	if s.PendingEngineVersion != nil {
		v := *s.PendingEngineVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "pendingEngineVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PubliclyAccessible != nil {
		v := *s.PubliclyAccessible

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "publiclyAccessible", protocol.BoolValue(v), metadata)
	}
	if len(s.SecurityGroups) > 0 {
		v := s.SecurityGroups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "securityGroups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.SubnetIds) > 0 {
		v := s.SubnetIds

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "subnetIds", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.Users) > 0 {
		v := s.Users

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "users", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeConfigurationRequest
type DescribeConfigurationInput struct {
	_ struct{} `type:"structure"`

	// ConfigurationId is a required field
	ConfigurationId *string `location:"uri" locationName:"configuration-id" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeConfigurationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeConfigurationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeConfigurationInput"}

	if s.ConfigurationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConfigurationId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeConfigurationInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ConfigurationId != nil {
		v := *s.ConfigurationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "configuration-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeConfigurationResponse
type DescribeConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	Created *time.Time `locationName:"created" type:"timestamp" timestampFormat:"unix"`

	Description *string `locationName:"description" type:"string"`

	// The type of broker engine. Note: Currently, Amazon MQ supports only ActiveMQ.
	EngineType EngineType `locationName:"engineType" type:"string" enum:"true"`

	EngineVersion *string `locationName:"engineVersion" type:"string"`

	Id *string `locationName:"id" type:"string"`

	// Returns information about the specified configuration revision.
	LatestRevision *ConfigurationRevision `locationName:"latestRevision" type:"structure"`

	Name *string `locationName:"name" type:"string"`

	Tags map[string]string `locationName:"tags" type:"map"`
}

// String returns the string representation
func (s DescribeConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeConfigurationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "created", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.EngineType) > 0 {
		v := s.EngineType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.EngineVersion != nil {
		v := *s.EngineVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LatestRevision != nil {
		v := s.LatestRevision

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "latestRevision", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeConfigurationRevisionRequest
type DescribeConfigurationRevisionInput struct {
	_ struct{} `type:"structure"`

	// ConfigurationId is a required field
	ConfigurationId *string `location:"uri" locationName:"configuration-id" type:"string" required:"true"`

	// ConfigurationRevision is a required field
	ConfigurationRevision *string `location:"uri" locationName:"configuration-revision" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeConfigurationRevisionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeConfigurationRevisionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeConfigurationRevisionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeConfigurationRevisionInput"}

	if s.ConfigurationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConfigurationId"))
	}

	if s.ConfigurationRevision == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConfigurationRevision"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeConfigurationRevisionInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ConfigurationId != nil {
		v := *s.ConfigurationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "configuration-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConfigurationRevision != nil {
		v := *s.ConfigurationRevision

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "configuration-revision", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeConfigurationRevisionResponse
type DescribeConfigurationRevisionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	ConfigurationId *string `locationName:"configurationId" type:"string"`

	Created *time.Time `locationName:"created" type:"timestamp" timestampFormat:"unix"`

	Data *string `locationName:"data" type:"string"`

	Description *string `locationName:"description" type:"string"`
}

// String returns the string representation
func (s DescribeConfigurationRevisionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeConfigurationRevisionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeConfigurationRevisionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeConfigurationRevisionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConfigurationId != nil {
		v := *s.ConfigurationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "configurationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "created", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Data != nil {
		v := *s.Data

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "data", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeUserRequest
type DescribeUserInput struct {
	_ struct{} `type:"structure"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`

	// Username is a required field
	Username *string `location:"uri" locationName:"username" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DescribeUserInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}

	if s.Username == nil {
		invalidParams.Add(aws.NewErrParamRequired("Username"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/DescribeUserResponse
type DescribeUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	BrokerId *string `locationName:"brokerId" type:"string"`

	ConsoleAccess *bool `locationName:"consoleAccess" type:"boolean"`

	Groups []string `locationName:"groups" type:"list"`

	// Returns information about the status of the changes pending for the ActiveMQ
	// user.
	Pending *UserPendingChanges `locationName:"pending" type:"structure"`

	Username *string `locationName:"username" type:"string"`
}

// String returns the string representation
func (s DescribeUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DescribeUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DescribeUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConsoleAccess != nil {
		v := *s.ConsoleAccess

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "consoleAccess", protocol.BoolValue(v), metadata)
	}
	if len(s.Groups) > 0 {
		v := s.Groups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "groups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Pending != nil {
		v := s.Pending

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "pending", v, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListBrokersRequest
type ListBrokersInput struct {
	_ struct{} `type:"structure"`

	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBrokersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBrokersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBrokersInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListBrokersInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBrokersInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListBrokersResponse
type ListBrokersOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	BrokerSummaries []BrokerSummary `locationName:"brokerSummaries" type:"list"`

	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBrokersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBrokersOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListBrokersOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListBrokersOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.BrokerSummaries) > 0 {
		v := s.BrokerSummaries

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "brokerSummaries", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListConfigurationRevisionsRequest
type ListConfigurationRevisionsInput struct {
	_ struct{} `type:"structure"`

	// ConfigurationId is a required field
	ConfigurationId *string `location:"uri" locationName:"configuration-id" type:"string" required:"true"`

	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListConfigurationRevisionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListConfigurationRevisionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListConfigurationRevisionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListConfigurationRevisionsInput"}

	if s.ConfigurationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConfigurationId"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListConfigurationRevisionsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ConfigurationId != nil {
		v := *s.ConfigurationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "configuration-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListConfigurationRevisionsResponse
type ListConfigurationRevisionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	ConfigurationId *string `locationName:"configurationId" type:"string"`

	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	NextToken *string `locationName:"nextToken" type:"string"`

	Revisions []ConfigurationRevision `locationName:"revisions" type:"list"`
}

// String returns the string representation
func (s ListConfigurationRevisionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListConfigurationRevisionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListConfigurationRevisionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListConfigurationRevisionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConfigurationId != nil {
		v := *s.ConfigurationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "configurationId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Revisions) > 0 {
		v := s.Revisions

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "revisions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListConfigurationsRequest
type ListConfigurationsInput struct {
	_ struct{} `type:"structure"`

	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListConfigurationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListConfigurationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListConfigurationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListConfigurationsInput"}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListConfigurationsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListConfigurationsResponse
type ListConfigurationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Configurations []Configuration `locationName:"configurations" type:"list"`

	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListConfigurationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListConfigurationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListConfigurationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListConfigurationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Configurations) > 0 {
		v := s.Configurations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "configurations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListTagsRequest
type ListTagsInput struct {
	_ struct{} `type:"structure"`

	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resource-arn" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTagsInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource-arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListTagsResponse
type ListTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Tags map[string]string `locationName:"tags" type:"map"`
}

// String returns the string representation
func (s ListTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListUsersRequest
type ListUsersInput struct {
	_ struct{} `type:"structure"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`

	MaxResults *int64 `location:"querystring" locationName:"maxResults" min:"1" type:"integer"`

	NextToken *string `location:"querystring" locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListUsersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListUsersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListUsersInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListUsersInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListUsersInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/ListUsersResponse
type ListUsersOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	BrokerId *string `locationName:"brokerId" type:"string"`

	MaxResults *int64 `locationName:"maxResults" min:"5" type:"integer"`

	NextToken *string `locationName:"nextToken" type:"string"`

	Users []UserSummary `locationName:"users" type:"list"`
}

// String returns the string representation
func (s ListUsersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListUsersOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListUsersOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListUsersOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "maxResults", protocol.Int64Value(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "nextToken", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Users) > 0 {
		v := s.Users

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "users", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// The list of information about logs to be enabled for the specified broker.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/Logs
type Logs struct {
	_ struct{} `type:"structure"`

	// Enables audit logging. Every user management action made using JMX or the
	// ActiveMQ Web Console is logged.
	Audit *bool `locationName:"audit" type:"boolean"`

	// Enables general logging.
	General *bool `locationName:"general" type:"boolean"`
}

// String returns the string representation
func (s Logs) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Logs) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Logs) MarshalFields(e protocol.FieldEncoder) error {
	if s.Audit != nil {
		v := *s.Audit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "audit", protocol.BoolValue(v), metadata)
	}
	if s.General != nil {
		v := *s.General

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "general", protocol.BoolValue(v), metadata)
	}
	return nil
}

// The list of information about logs currently enabled and pending to be deployed
// for the specified broker.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/LogsSummary
type LogsSummary struct {
	_ struct{} `type:"structure"`

	// Enables audit logging. Every user management action made using JMX or the
	// ActiveMQ Web Console is logged.
	Audit *bool `locationName:"audit" type:"boolean"`

	// The location of the CloudWatch Logs log group where audit logs are sent.
	AuditLogGroup *string `locationName:"auditLogGroup" type:"string"`

	// Enables general logging.
	General *bool `locationName:"general" type:"boolean"`

	// The location of the CloudWatch Logs log group where general logs are sent.
	GeneralLogGroup *string `locationName:"generalLogGroup" type:"string"`

	// The list of information about logs pending to be deployed for the specified
	// broker.
	Pending *PendingLogs `locationName:"pending" type:"structure"`
}

// String returns the string representation
func (s LogsSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LogsSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LogsSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.Audit != nil {
		v := *s.Audit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "audit", protocol.BoolValue(v), metadata)
	}
	if s.AuditLogGroup != nil {
		v := *s.AuditLogGroup

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "auditLogGroup", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.General != nil {
		v := *s.General

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "general", protocol.BoolValue(v), metadata)
	}
	if s.GeneralLogGroup != nil {
		v := *s.GeneralLogGroup

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "generalLogGroup", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Pending != nil {
		v := s.Pending

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "pending", v, metadata)
	}
	return nil
}

// The list of information about logs to be enabled for the specified broker.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/PendingLogs
type PendingLogs struct {
	_ struct{} `type:"structure"`

	// Enables audit logging. Every user management action made using JMX or the
	// ActiveMQ Web Console is logged.
	Audit *bool `locationName:"audit" type:"boolean"`

	// Enables general logging.
	General *bool `locationName:"general" type:"boolean"`
}

// String returns the string representation
func (s PendingLogs) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PendingLogs) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PendingLogs) MarshalFields(e protocol.FieldEncoder) error {
	if s.Audit != nil {
		v := *s.Audit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "audit", protocol.BoolValue(v), metadata)
	}
	if s.General != nil {
		v := *s.General

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "general", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/RebootBrokerRequest
type RebootBrokerInput struct {
	_ struct{} `type:"structure"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`
}

// String returns the string representation
func (s RebootBrokerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RebootBrokerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RebootBrokerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "RebootBrokerInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RebootBrokerInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/RebootBrokerResponse
type RebootBrokerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s RebootBrokerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RebootBrokerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s RebootBrokerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s RebootBrokerOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Returns information about the XML element or attribute that was sanitized
// in the configuration.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/SanitizationWarning
type SanitizationWarning struct {
	_ struct{} `type:"structure"`

	// The name of the XML attribute that has been sanitized.
	AttributeName *string `locationName:"attributeName" type:"string"`

	// The name of the XML element that has been sanitized.
	ElementName *string `locationName:"elementName" type:"string"`

	// Required. The reason for which the XML elements or attributes were sanitized.
	Reason SanitizationWarningReason `locationName:"reason" type:"string" enum:"true"`
}

// String returns the string representation
func (s SanitizationWarning) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SanitizationWarning) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SanitizationWarning) MarshalFields(e protocol.FieldEncoder) error {
	if s.AttributeName != nil {
		v := *s.AttributeName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "attributeName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ElementName != nil {
		v := *s.ElementName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "elementName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Reason) > 0 {
		v := s.Reason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "reason", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateBrokerRequest
type UpdateBrokerInput struct {
	_ struct{} `type:"structure"`

	AutoMinorVersionUpgrade *bool `locationName:"autoMinorVersionUpgrade" type:"boolean"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`

	// A list of information about the configuration.
	Configuration *ConfigurationId `locationName:"configuration" type:"structure"`

	EngineVersion *string `locationName:"engineVersion" type:"string"`

	// The list of information about logs to be enabled for the specified broker.
	Logs *Logs `locationName:"logs" type:"structure"`
}

// String returns the string representation
func (s UpdateBrokerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBrokerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateBrokerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateBrokerInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateBrokerInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.AutoMinorVersionUpgrade != nil {
		v := *s.AutoMinorVersionUpgrade

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "autoMinorVersionUpgrade", protocol.BoolValue(v), metadata)
	}
	if s.Configuration != nil {
		v := s.Configuration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "configuration", v, metadata)
	}
	if s.EngineVersion != nil {
		v := *s.EngineVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Logs != nil {
		v := s.Logs

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logs", v, metadata)
	}
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateBrokerResponse
type UpdateBrokerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	AutoMinorVersionUpgrade *bool `locationName:"autoMinorVersionUpgrade" type:"boolean"`

	BrokerId *string `locationName:"brokerId" type:"string"`

	// A list of information about the configuration.
	Configuration *ConfigurationId `locationName:"configuration" type:"structure"`

	EngineVersion *string `locationName:"engineVersion" type:"string"`

	// The list of information about logs to be enabled for the specified broker.
	Logs *Logs `locationName:"logs" type:"structure"`
}

// String returns the string representation
func (s UpdateBrokerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBrokerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateBrokerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateBrokerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AutoMinorVersionUpgrade != nil {
		v := *s.AutoMinorVersionUpgrade

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "autoMinorVersionUpgrade", protocol.BoolValue(v), metadata)
	}
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "brokerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Configuration != nil {
		v := s.Configuration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "configuration", v, metadata)
	}
	if s.EngineVersion != nil {
		v := *s.EngineVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "engineVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Logs != nil {
		v := s.Logs

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "logs", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateConfigurationRequest
type UpdateConfigurationInput struct {
	_ struct{} `type:"structure"`

	// ConfigurationId is a required field
	ConfigurationId *string `location:"uri" locationName:"configuration-id" type:"string" required:"true"`

	Data *string `locationName:"data" type:"string"`

	Description *string `locationName:"description" type:"string"`
}

// String returns the string representation
func (s UpdateConfigurationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateConfigurationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateConfigurationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateConfigurationInput"}

	if s.ConfigurationId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ConfigurationId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateConfigurationInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.Data != nil {
		v := *s.Data

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "data", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConfigurationId != nil {
		v := *s.ConfigurationId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "configuration-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateConfigurationResponse
type UpdateConfigurationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Arn *string `locationName:"arn" type:"string"`

	Created *time.Time `locationName:"created" type:"timestamp" timestampFormat:"unix"`

	Id *string `locationName:"id" type:"string"`

	// Returns information about the specified configuration revision.
	LatestRevision *ConfigurationRevision `locationName:"latestRevision" type:"structure"`

	Name *string `locationName:"name" type:"string"`

	Warnings []SanitizationWarning `locationName:"warnings" type:"list"`
}

// String returns the string representation
func (s UpdateConfigurationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateConfigurationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateConfigurationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateConfigurationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Arn != nil {
		v := *s.Arn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Created != nil {
		v := *s.Created

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "created", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LatestRevision != nil {
		v := s.LatestRevision

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "latestRevision", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Warnings) > 0 {
		v := s.Warnings

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "warnings", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateUserRequest
type UpdateUserInput struct {
	_ struct{} `type:"structure"`

	// BrokerId is a required field
	BrokerId *string `location:"uri" locationName:"broker-id" type:"string" required:"true"`

	ConsoleAccess *bool `locationName:"consoleAccess" type:"boolean"`

	Groups []string `locationName:"groups" type:"list"`

	Password *string `locationName:"password" type:"string"`

	// Username is a required field
	Username *string `location:"uri" locationName:"username" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateUserInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateUserInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateUserInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateUserInput"}

	if s.BrokerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("BrokerId"))
	}

	if s.Username == nil {
		invalidParams.Add(aws.NewErrParamRequired("Username"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateUserInput) MarshalFields(e protocol.FieldEncoder) error {
	e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.StringValue("application/x-amz-json-1.1"), protocol.Metadata{})

	if s.ConsoleAccess != nil {
		v := *s.ConsoleAccess

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "consoleAccess", protocol.BoolValue(v), metadata)
	}
	if len(s.Groups) > 0 {
		v := s.Groups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "groups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Password != nil {
		v := *s.Password

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "password", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.BrokerId != nil {
		v := *s.BrokerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "broker-id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UpdateUserResponse
type UpdateUserOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UpdateUserOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateUserOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateUserOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateUserOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// An ActiveMQ user associated with the broker.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/User
type User struct {
	_ struct{} `type:"structure"`

	// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
	ConsoleAccess *bool `locationName:"consoleAccess" type:"boolean"`

	// The list of groups (20 maximum) to which the ActiveMQ user belongs. This
	// value can contain only alphanumeric characters, dashes, periods, underscores,
	// and tildes (- . _ ~). This value must be 2-100 characters long.
	Groups []string `locationName:"groups" type:"list"`

	// Required. The password of the ActiveMQ user. This value must be at least
	// 12 characters long, must contain at least 4 unique characters, and must not
	// contain commas.
	Password *string `locationName:"password" type:"string"`

	// Required. The username of the ActiveMQ user. This value can contain only
	// alphanumeric characters, dashes, periods, underscores, and tildes (- . _
	// ~). This value must be 2-100 characters long.
	Username *string `locationName:"username" type:"string"`
}

// String returns the string representation
func (s User) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s User) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s User) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConsoleAccess != nil {
		v := *s.ConsoleAccess

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "consoleAccess", protocol.BoolValue(v), metadata)
	}
	if len(s.Groups) > 0 {
		v := s.Groups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "groups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Password != nil {
		v := *s.Password

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "password", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Returns information about the status of the changes pending for the ActiveMQ
// user.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UserPendingChanges
type UserPendingChanges struct {
	_ struct{} `type:"structure"`

	// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
	ConsoleAccess *bool `locationName:"consoleAccess" type:"boolean"`

	// The list of groups (20 maximum) to which the ActiveMQ user belongs. This
	// value can contain only alphanumeric characters, dashes, periods, underscores,
	// and tildes (- . _ ~). This value must be 2-100 characters long.
	Groups []string `locationName:"groups" type:"list"`

	// Required. The type of change pending for the ActiveMQ user.
	PendingChange ChangeType `locationName:"pendingChange" type:"string" enum:"true"`
}

// String returns the string representation
func (s UserPendingChanges) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UserPendingChanges) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UserPendingChanges) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConsoleAccess != nil {
		v := *s.ConsoleAccess

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "consoleAccess", protocol.BoolValue(v), metadata)
	}
	if len(s.Groups) > 0 {
		v := s.Groups

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "groups", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.PendingChange) > 0 {
		v := s.PendingChange

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "pendingChange", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Returns a list of all ActiveMQ users.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/UserSummary
type UserSummary struct {
	_ struct{} `type:"structure"`

	// The type of change pending for the ActiveMQ user.
	PendingChange ChangeType `locationName:"pendingChange" type:"string" enum:"true"`

	// Required. The username of the ActiveMQ user. This value can contain only
	// alphanumeric characters, dashes, periods, underscores, and tildes (- . _
	// ~). This value must be 2-100 characters long.
	Username *string `locationName:"username" type:"string"`
}

// String returns the string representation
func (s UserSummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UserSummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UserSummary) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.PendingChange) > 0 {
		v := s.PendingChange

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "pendingChange", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Username != nil {
		v := *s.Username

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "username", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The scheduled time period relative to UTC during which Amazon MQ begins to
// apply pending updates or patches to the broker.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/mq-2017-11-27/WeeklyStartTime
type WeeklyStartTime struct {
	_ struct{} `type:"structure"`

	// Required. The day of the week.
	DayOfWeek DayOfWeek `locationName:"dayOfWeek" type:"string" enum:"true"`

	// Required. The time, in 24-hour format.
	TimeOfDay *string `locationName:"timeOfDay" type:"string"`

	// The time zone, UTC by default, in either the Country/City format, or the
	// UTC offset format.
	TimeZone *string `locationName:"timeZone" type:"string"`
}

// String returns the string representation
func (s WeeklyStartTime) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s WeeklyStartTime) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s WeeklyStartTime) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DayOfWeek) > 0 {
		v := s.DayOfWeek

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "dayOfWeek", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.TimeOfDay != nil {
		v := *s.TimeOfDay

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeOfDay", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TimeZone != nil {
		v := *s.TimeZone

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeZone", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The status of the broker.
type BrokerState string

// Enum values for BrokerState
const (
	BrokerStateCreationInProgress BrokerState = "CREATION_IN_PROGRESS"
	BrokerStateCreationFailed     BrokerState = "CREATION_FAILED"
	BrokerStateDeletionInProgress BrokerState = "DELETION_IN_PROGRESS"
	BrokerStateRunning            BrokerState = "RUNNING"
	BrokerStateRebootInProgress   BrokerState = "REBOOT_IN_PROGRESS"
)

func (enum BrokerState) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum BrokerState) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The type of change pending for the ActiveMQ user.
type ChangeType string

// Enum values for ChangeType
const (
	ChangeTypeCreate ChangeType = "CREATE"
	ChangeTypeUpdate ChangeType = "UPDATE"
	ChangeTypeDelete ChangeType = "DELETE"
)

func (enum ChangeType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ChangeType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DayOfWeek string

// Enum values for DayOfWeek
const (
	DayOfWeekMonday    DayOfWeek = "MONDAY"
	DayOfWeekTuesday   DayOfWeek = "TUESDAY"
	DayOfWeekWednesday DayOfWeek = "WEDNESDAY"
	DayOfWeekThursday  DayOfWeek = "THURSDAY"
	DayOfWeekFriday    DayOfWeek = "FRIDAY"
	DayOfWeekSaturday  DayOfWeek = "SATURDAY"
	DayOfWeekSunday    DayOfWeek = "SUNDAY"
)

func (enum DayOfWeek) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DayOfWeek) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The deployment mode of the broker.
type DeploymentMode string

// Enum values for DeploymentMode
const (
	DeploymentModeSingleInstance       DeploymentMode = "SINGLE_INSTANCE"
	DeploymentModeActiveStandbyMultiAz DeploymentMode = "ACTIVE_STANDBY_MULTI_AZ"
)

func (enum DeploymentMode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DeploymentMode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The type of broker engine. Note: Currently, Amazon MQ supports only ActiveMQ.
type EngineType string

// Enum values for EngineType
const (
	EngineTypeActivemq EngineType = "ACTIVEMQ"
)

func (enum EngineType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EngineType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The reason for which the XML elements or attributes were sanitized.
type SanitizationWarningReason string

// Enum values for SanitizationWarningReason
const (
	SanitizationWarningReasonDisallowedElementRemoved     SanitizationWarningReason = "DISALLOWED_ELEMENT_REMOVED"
	SanitizationWarningReasonDisallowedAttributeRemoved   SanitizationWarningReason = "DISALLOWED_ATTRIBUTE_REMOVED"
	SanitizationWarningReasonInvalidAttributeValueRemoved SanitizationWarningReason = "INVALID_ATTRIBUTE_VALUE_REMOVED"
)

func (enum SanitizationWarningReason) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum SanitizationWarningReason) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
