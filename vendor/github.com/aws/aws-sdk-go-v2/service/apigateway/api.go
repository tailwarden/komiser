// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package apigateway

import (
	"context"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
	"github.com/aws/aws-sdk-go-v2/private/protocol/restjson"
)

const opCreateApiKey = "CreateApiKey"

// CreateApiKeyRequest is a API request type for the CreateApiKey API operation.
type CreateApiKeyRequest struct {
	*aws.Request
	Input *CreateApiKeyInput
	Copy  func(*CreateApiKeyInput) CreateApiKeyRequest
}

// Send marshals and sends the CreateApiKey API request.
func (r CreateApiKeyRequest) Send(ctx context.Context) (*UpdateApiKeyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateApiKeyOutput), nil
}

// CreateApiKeyRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Create an ApiKey resource.
//
// AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/create-api-key.html)
//
//    // Example sending a request using the CreateApiKeyRequest method.
//    req := client.CreateApiKeyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateApiKeyRequest(input *CreateApiKeyInput) CreateApiKeyRequest {
	op := &aws.Operation{
		Name:       opCreateApiKey,
		HTTPMethod: "POST",
		HTTPPath:   "/apikeys",
	}

	if input == nil {
		input = &CreateApiKeyInput{}
	}

	output := &UpdateApiKeyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateApiKeyRequest{Request: req, Input: input, Copy: c.CreateApiKeyRequest}
}

const opCreateAuthorizer = "CreateAuthorizer"

// CreateAuthorizerRequest is a API request type for the CreateAuthorizer API operation.
type CreateAuthorizerRequest struct {
	*aws.Request
	Input *CreateAuthorizerInput
	Copy  func(*CreateAuthorizerInput) CreateAuthorizerRequest
}

// Send marshals and sends the CreateAuthorizer API request.
func (r CreateAuthorizerRequest) Send(ctx context.Context) (*UpdateAuthorizerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateAuthorizerOutput), nil
}

// CreateAuthorizerRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Adds a new Authorizer resource to an existing RestApi resource.
//
// AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/create-authorizer.html)
//
//    // Example sending a request using the CreateAuthorizerRequest method.
//    req := client.CreateAuthorizerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateAuthorizerRequest(input *CreateAuthorizerInput) CreateAuthorizerRequest {
	op := &aws.Operation{
		Name:       opCreateAuthorizer,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/authorizers",
	}

	if input == nil {
		input = &CreateAuthorizerInput{}
	}

	output := &UpdateAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateAuthorizerRequest{Request: req, Input: input, Copy: c.CreateAuthorizerRequest}
}

const opCreateBasePathMapping = "CreateBasePathMapping"

// CreateBasePathMappingRequest is a API request type for the CreateBasePathMapping API operation.
type CreateBasePathMappingRequest struct {
	*aws.Request
	Input *CreateBasePathMappingInput
	Copy  func(*CreateBasePathMappingInput) CreateBasePathMappingRequest
}

// Send marshals and sends the CreateBasePathMapping API request.
func (r CreateBasePathMappingRequest) Send(ctx context.Context) (*UpdateBasePathMappingOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateBasePathMappingOutput), nil
}

// CreateBasePathMappingRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a new BasePathMapping resource.
//
//    // Example sending a request using the CreateBasePathMappingRequest method.
//    req := client.CreateBasePathMappingRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateBasePathMappingRequest(input *CreateBasePathMappingInput) CreateBasePathMappingRequest {
	op := &aws.Operation{
		Name:       opCreateBasePathMapping,
		HTTPMethod: "POST",
		HTTPPath:   "/domainnames/{domain_name}/basepathmappings",
	}

	if input == nil {
		input = &CreateBasePathMappingInput{}
	}

	output := &UpdateBasePathMappingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateBasePathMappingRequest{Request: req, Input: input, Copy: c.CreateBasePathMappingRequest}
}

const opCreateDeployment = "CreateDeployment"

// CreateDeploymentRequest is a API request type for the CreateDeployment API operation.
type CreateDeploymentRequest struct {
	*aws.Request
	Input *CreateDeploymentInput
	Copy  func(*CreateDeploymentInput) CreateDeploymentRequest
}

// Send marshals and sends the CreateDeployment API request.
func (r CreateDeploymentRequest) Send(ctx context.Context) (*UpdateDeploymentOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDeploymentOutput), nil
}

// CreateDeploymentRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a Deployment resource, which makes a specified RestApi callable over
// the internet.
//
//    // Example sending a request using the CreateDeploymentRequest method.
//    req := client.CreateDeploymentRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateDeploymentRequest(input *CreateDeploymentInput) CreateDeploymentRequest {
	op := &aws.Operation{
		Name:       opCreateDeployment,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/deployments",
	}

	if input == nil {
		input = &CreateDeploymentInput{}
	}

	output := &UpdateDeploymentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDeploymentRequest{Request: req, Input: input, Copy: c.CreateDeploymentRequest}
}

const opCreateDocumentationPart = "CreateDocumentationPart"

// CreateDocumentationPartRequest is a API request type for the CreateDocumentationPart API operation.
type CreateDocumentationPartRequest struct {
	*aws.Request
	Input *CreateDocumentationPartInput
	Copy  func(*CreateDocumentationPartInput) CreateDocumentationPartRequest
}

// Send marshals and sends the CreateDocumentationPart API request.
func (r CreateDocumentationPartRequest) Send(ctx context.Context) (*UpdateDocumentationPartOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDocumentationPartOutput), nil
}

// CreateDocumentationPartRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the CreateDocumentationPartRequest method.
//    req := client.CreateDocumentationPartRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateDocumentationPartRequest(input *CreateDocumentationPartInput) CreateDocumentationPartRequest {
	op := &aws.Operation{
		Name:       opCreateDocumentationPart,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/documentation/parts",
	}

	if input == nil {
		input = &CreateDocumentationPartInput{}
	}

	output := &UpdateDocumentationPartOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDocumentationPartRequest{Request: req, Input: input, Copy: c.CreateDocumentationPartRequest}
}

const opCreateDocumentationVersion = "CreateDocumentationVersion"

// CreateDocumentationVersionRequest is a API request type for the CreateDocumentationVersion API operation.
type CreateDocumentationVersionRequest struct {
	*aws.Request
	Input *CreateDocumentationVersionInput
	Copy  func(*CreateDocumentationVersionInput) CreateDocumentationVersionRequest
}

// Send marshals and sends the CreateDocumentationVersion API request.
func (r CreateDocumentationVersionRequest) Send(ctx context.Context) (*UpdateDocumentationVersionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDocumentationVersionOutput), nil
}

// CreateDocumentationVersionRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the CreateDocumentationVersionRequest method.
//    req := client.CreateDocumentationVersionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateDocumentationVersionRequest(input *CreateDocumentationVersionInput) CreateDocumentationVersionRequest {
	op := &aws.Operation{
		Name:       opCreateDocumentationVersion,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/documentation/versions",
	}

	if input == nil {
		input = &CreateDocumentationVersionInput{}
	}

	output := &UpdateDocumentationVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDocumentationVersionRequest{Request: req, Input: input, Copy: c.CreateDocumentationVersionRequest}
}

const opCreateDomainName = "CreateDomainName"

// CreateDomainNameRequest is a API request type for the CreateDomainName API operation.
type CreateDomainNameRequest struct {
	*aws.Request
	Input *CreateDomainNameInput
	Copy  func(*CreateDomainNameInput) CreateDomainNameRequest
}

// Send marshals and sends the CreateDomainName API request.
func (r CreateDomainNameRequest) Send(ctx context.Context) (*UpdateDomainNameOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDomainNameOutput), nil
}

// CreateDomainNameRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a new domain name.
//
//    // Example sending a request using the CreateDomainNameRequest method.
//    req := client.CreateDomainNameRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateDomainNameRequest(input *CreateDomainNameInput) CreateDomainNameRequest {
	op := &aws.Operation{
		Name:       opCreateDomainName,
		HTTPMethod: "POST",
		HTTPPath:   "/domainnames",
	}

	if input == nil {
		input = &CreateDomainNameInput{}
	}

	output := &UpdateDomainNameOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateDomainNameRequest{Request: req, Input: input, Copy: c.CreateDomainNameRequest}
}

const opCreateModel = "CreateModel"

// CreateModelRequest is a API request type for the CreateModel API operation.
type CreateModelRequest struct {
	*aws.Request
	Input *CreateModelInput
	Copy  func(*CreateModelInput) CreateModelRequest
}

// Send marshals and sends the CreateModel API request.
func (r CreateModelRequest) Send(ctx context.Context) (*UpdateModelOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateModelOutput), nil
}

// CreateModelRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Adds a new Model resource to an existing RestApi resource.
//
//    // Example sending a request using the CreateModelRequest method.
//    req := client.CreateModelRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateModelRequest(input *CreateModelInput) CreateModelRequest {
	op := &aws.Operation{
		Name:       opCreateModel,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/models",
	}

	if input == nil {
		input = &CreateModelInput{}
	}

	output := &UpdateModelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateModelRequest{Request: req, Input: input, Copy: c.CreateModelRequest}
}

const opCreateRequestValidator = "CreateRequestValidator"

// CreateRequestValidatorRequest is a API request type for the CreateRequestValidator API operation.
type CreateRequestValidatorRequest struct {
	*aws.Request
	Input *CreateRequestValidatorInput
	Copy  func(*CreateRequestValidatorInput) CreateRequestValidatorRequest
}

// Send marshals and sends the CreateRequestValidator API request.
func (r CreateRequestValidatorRequest) Send(ctx context.Context) (*UpdateRequestValidatorOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRequestValidatorOutput), nil
}

// CreateRequestValidatorRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a ReqeustValidator of a given RestApi.
//
//    // Example sending a request using the CreateRequestValidatorRequest method.
//    req := client.CreateRequestValidatorRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateRequestValidatorRequest(input *CreateRequestValidatorInput) CreateRequestValidatorRequest {
	op := &aws.Operation{
		Name:       opCreateRequestValidator,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/requestvalidators",
	}

	if input == nil {
		input = &CreateRequestValidatorInput{}
	}

	output := &UpdateRequestValidatorOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateRequestValidatorRequest{Request: req, Input: input, Copy: c.CreateRequestValidatorRequest}
}

const opCreateResource = "CreateResource"

// CreateResourceRequest is a API request type for the CreateResource API operation.
type CreateResourceRequest struct {
	*aws.Request
	Input *CreateResourceInput
	Copy  func(*CreateResourceInput) CreateResourceRequest
}

// Send marshals and sends the CreateResource API request.
func (r CreateResourceRequest) Send(ctx context.Context) (*UpdateResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateResourceOutput), nil
}

// CreateResourceRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a Resource resource.
//
//    // Example sending a request using the CreateResourceRequest method.
//    req := client.CreateResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateResourceRequest(input *CreateResourceInput) CreateResourceRequest {
	op := &aws.Operation{
		Name:       opCreateResource,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/resources/{parent_id}",
	}

	if input == nil {
		input = &CreateResourceInput{}
	}

	output := &UpdateResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateResourceRequest{Request: req, Input: input, Copy: c.CreateResourceRequest}
}

const opCreateRestApi = "CreateRestApi"

// CreateRestApiRequest is a API request type for the CreateRestApi API operation.
type CreateRestApiRequest struct {
	*aws.Request
	Input *CreateRestApiInput
	Copy  func(*CreateRestApiInput) CreateRestApiRequest
}

// Send marshals and sends the CreateRestApi API request.
func (r CreateRestApiRequest) Send(ctx context.Context) (*UpdateRestApiOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRestApiOutput), nil
}

// CreateRestApiRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a new RestApi resource.
//
//    // Example sending a request using the CreateRestApiRequest method.
//    req := client.CreateRestApiRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateRestApiRequest(input *CreateRestApiInput) CreateRestApiRequest {
	op := &aws.Operation{
		Name:       opCreateRestApi,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis",
	}

	if input == nil {
		input = &CreateRestApiInput{}
	}

	output := &UpdateRestApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateRestApiRequest{Request: req, Input: input, Copy: c.CreateRestApiRequest}
}

const opCreateStage = "CreateStage"

// CreateStageRequest is a API request type for the CreateStage API operation.
type CreateStageRequest struct {
	*aws.Request
	Input *CreateStageInput
	Copy  func(*CreateStageInput) CreateStageRequest
}

// Send marshals and sends the CreateStage API request.
func (r CreateStageRequest) Send(ctx context.Context) (*UpdateStageOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateStageOutput), nil
}

// CreateStageRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a new Stage resource that references a pre-existing Deployment for
// the API.
//
//    // Example sending a request using the CreateStageRequest method.
//    req := client.CreateStageRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateStageRequest(input *CreateStageInput) CreateStageRequest {
	op := &aws.Operation{
		Name:       opCreateStage,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/stages",
	}

	if input == nil {
		input = &CreateStageInput{}
	}

	output := &UpdateStageOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateStageRequest{Request: req, Input: input, Copy: c.CreateStageRequest}
}

const opCreateUsagePlan = "CreateUsagePlan"

// CreateUsagePlanRequest is a API request type for the CreateUsagePlan API operation.
type CreateUsagePlanRequest struct {
	*aws.Request
	Input *CreateUsagePlanInput
	Copy  func(*CreateUsagePlanInput) CreateUsagePlanRequest
}

// Send marshals and sends the CreateUsagePlan API request.
func (r CreateUsagePlanRequest) Send(ctx context.Context) (*UpdateUsagePlanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateUsagePlanOutput), nil
}

// CreateUsagePlanRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a usage plan with the throttle and quota limits, as well as the associated
// API stages, specified in the payload.
//
//    // Example sending a request using the CreateUsagePlanRequest method.
//    req := client.CreateUsagePlanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateUsagePlanRequest(input *CreateUsagePlanInput) CreateUsagePlanRequest {
	op := &aws.Operation{
		Name:       opCreateUsagePlan,
		HTTPMethod: "POST",
		HTTPPath:   "/usageplans",
	}

	if input == nil {
		input = &CreateUsagePlanInput{}
	}

	output := &UpdateUsagePlanOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateUsagePlanRequest{Request: req, Input: input, Copy: c.CreateUsagePlanRequest}
}

const opCreateUsagePlanKey = "CreateUsagePlanKey"

// CreateUsagePlanKeyRequest is a API request type for the CreateUsagePlanKey API operation.
type CreateUsagePlanKeyRequest struct {
	*aws.Request
	Input *CreateUsagePlanKeyInput
	Copy  func(*CreateUsagePlanKeyInput) CreateUsagePlanKeyRequest
}

// Send marshals and sends the CreateUsagePlanKey API request.
func (r CreateUsagePlanKeyRequest) Send(ctx context.Context) (*GetUsagePlanKeyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetUsagePlanKeyOutput), nil
}

// CreateUsagePlanKeyRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a usage plan key for adding an existing API key to a usage plan.
//
//    // Example sending a request using the CreateUsagePlanKeyRequest method.
//    req := client.CreateUsagePlanKeyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateUsagePlanKeyRequest(input *CreateUsagePlanKeyInput) CreateUsagePlanKeyRequest {
	op := &aws.Operation{
		Name:       opCreateUsagePlanKey,
		HTTPMethod: "POST",
		HTTPPath:   "/usageplans/{usageplanId}/keys",
	}

	if input == nil {
		input = &CreateUsagePlanKeyInput{}
	}

	output := &GetUsagePlanKeyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateUsagePlanKeyRequest{Request: req, Input: input, Copy: c.CreateUsagePlanKeyRequest}
}

const opCreateVpcLink = "CreateVpcLink"

// CreateVpcLinkRequest is a API request type for the CreateVpcLink API operation.
type CreateVpcLinkRequest struct {
	*aws.Request
	Input *CreateVpcLinkInput
	Copy  func(*CreateVpcLinkInput) CreateVpcLinkRequest
}

// Send marshals and sends the CreateVpcLink API request.
func (r CreateVpcLinkRequest) Send(ctx context.Context) (*UpdateVpcLinkOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateVpcLinkOutput), nil
}

// CreateVpcLinkRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a VPC link, under the caller's account in a selected region, in an
// asynchronous operation that typically takes 2-4 minutes to complete and become
// operational. The caller must have permissions to create and update VPC Endpoint
// services.
//
//    // Example sending a request using the CreateVpcLinkRequest method.
//    req := client.CreateVpcLinkRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) CreateVpcLinkRequest(input *CreateVpcLinkInput) CreateVpcLinkRequest {
	op := &aws.Operation{
		Name:       opCreateVpcLink,
		HTTPMethod: "POST",
		HTTPPath:   "/vpclinks",
	}

	if input == nil {
		input = &CreateVpcLinkInput{}
	}

	output := &UpdateVpcLinkOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateVpcLinkRequest{Request: req, Input: input, Copy: c.CreateVpcLinkRequest}
}

const opDeleteApiKey = "DeleteApiKey"

// DeleteApiKeyRequest is a API request type for the DeleteApiKey API operation.
type DeleteApiKeyRequest struct {
	*aws.Request
	Input *DeleteApiKeyInput
	Copy  func(*DeleteApiKeyInput) DeleteApiKeyRequest
}

// Send marshals and sends the DeleteApiKey API request.
func (r DeleteApiKeyRequest) Send(ctx context.Context) (*DeleteApiKeyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteApiKeyOutput), nil
}

// DeleteApiKeyRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes the ApiKey resource.
//
//    // Example sending a request using the DeleteApiKeyRequest method.
//    req := client.DeleteApiKeyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteApiKeyRequest(input *DeleteApiKeyInput) DeleteApiKeyRequest {
	op := &aws.Operation{
		Name:       opDeleteApiKey,
		HTTPMethod: "DELETE",
		HTTPPath:   "/apikeys/{api_Key}",
	}

	if input == nil {
		input = &DeleteApiKeyInput{}
	}

	output := &DeleteApiKeyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteApiKeyRequest{Request: req, Input: input, Copy: c.DeleteApiKeyRequest}
}

const opDeleteAuthorizer = "DeleteAuthorizer"

// DeleteAuthorizerRequest is a API request type for the DeleteAuthorizer API operation.
type DeleteAuthorizerRequest struct {
	*aws.Request
	Input *DeleteAuthorizerInput
	Copy  func(*DeleteAuthorizerInput) DeleteAuthorizerRequest
}

// Send marshals and sends the DeleteAuthorizer API request.
func (r DeleteAuthorizerRequest) Send(ctx context.Context) (*DeleteAuthorizerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteAuthorizerOutput), nil
}

// DeleteAuthorizerRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes an existing Authorizer resource.
//
// AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/delete-authorizer.html)
//
//    // Example sending a request using the DeleteAuthorizerRequest method.
//    req := client.DeleteAuthorizerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteAuthorizerRequest(input *DeleteAuthorizerInput) DeleteAuthorizerRequest {
	op := &aws.Operation{
		Name:       opDeleteAuthorizer,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/authorizers/{authorizer_id}",
	}

	if input == nil {
		input = &DeleteAuthorizerInput{}
	}

	output := &DeleteAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteAuthorizerRequest{Request: req, Input: input, Copy: c.DeleteAuthorizerRequest}
}

const opDeleteBasePathMapping = "DeleteBasePathMapping"

// DeleteBasePathMappingRequest is a API request type for the DeleteBasePathMapping API operation.
type DeleteBasePathMappingRequest struct {
	*aws.Request
	Input *DeleteBasePathMappingInput
	Copy  func(*DeleteBasePathMappingInput) DeleteBasePathMappingRequest
}

// Send marshals and sends the DeleteBasePathMapping API request.
func (r DeleteBasePathMappingRequest) Send(ctx context.Context) (*DeleteBasePathMappingOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteBasePathMappingOutput), nil
}

// DeleteBasePathMappingRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes the BasePathMapping resource.
//
//    // Example sending a request using the DeleteBasePathMappingRequest method.
//    req := client.DeleteBasePathMappingRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteBasePathMappingRequest(input *DeleteBasePathMappingInput) DeleteBasePathMappingRequest {
	op := &aws.Operation{
		Name:       opDeleteBasePathMapping,
		HTTPMethod: "DELETE",
		HTTPPath:   "/domainnames/{domain_name}/basepathmappings/{base_path}",
	}

	if input == nil {
		input = &DeleteBasePathMappingInput{}
	}

	output := &DeleteBasePathMappingOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteBasePathMappingRequest{Request: req, Input: input, Copy: c.DeleteBasePathMappingRequest}
}

const opDeleteClientCertificate = "DeleteClientCertificate"

// DeleteClientCertificateRequest is a API request type for the DeleteClientCertificate API operation.
type DeleteClientCertificateRequest struct {
	*aws.Request
	Input *DeleteClientCertificateInput
	Copy  func(*DeleteClientCertificateInput) DeleteClientCertificateRequest
}

// Send marshals and sends the DeleteClientCertificate API request.
func (r DeleteClientCertificateRequest) Send(ctx context.Context) (*DeleteClientCertificateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteClientCertificateOutput), nil
}

// DeleteClientCertificateRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes the ClientCertificate resource.
//
//    // Example sending a request using the DeleteClientCertificateRequest method.
//    req := client.DeleteClientCertificateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteClientCertificateRequest(input *DeleteClientCertificateInput) DeleteClientCertificateRequest {
	op := &aws.Operation{
		Name:       opDeleteClientCertificate,
		HTTPMethod: "DELETE",
		HTTPPath:   "/clientcertificates/{clientcertificate_id}",
	}

	if input == nil {
		input = &DeleteClientCertificateInput{}
	}

	output := &DeleteClientCertificateOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteClientCertificateRequest{Request: req, Input: input, Copy: c.DeleteClientCertificateRequest}
}

const opDeleteDeployment = "DeleteDeployment"

// DeleteDeploymentRequest is a API request type for the DeleteDeployment API operation.
type DeleteDeploymentRequest struct {
	*aws.Request
	Input *DeleteDeploymentInput
	Copy  func(*DeleteDeploymentInput) DeleteDeploymentRequest
}

// Send marshals and sends the DeleteDeployment API request.
func (r DeleteDeploymentRequest) Send(ctx context.Context) (*DeleteDeploymentOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteDeploymentOutput), nil
}

// DeleteDeploymentRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes a Deployment resource. Deleting a deployment will only succeed if
// there are no Stage resources associated with it.
//
//    // Example sending a request using the DeleteDeploymentRequest method.
//    req := client.DeleteDeploymentRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteDeploymentRequest(input *DeleteDeploymentInput) DeleteDeploymentRequest {
	op := &aws.Operation{
		Name:       opDeleteDeployment,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/deployments/{deployment_id}",
	}

	if input == nil {
		input = &DeleteDeploymentInput{}
	}

	output := &DeleteDeploymentOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteDeploymentRequest{Request: req, Input: input, Copy: c.DeleteDeploymentRequest}
}

const opDeleteDocumentationPart = "DeleteDocumentationPart"

// DeleteDocumentationPartRequest is a API request type for the DeleteDocumentationPart API operation.
type DeleteDocumentationPartRequest struct {
	*aws.Request
	Input *DeleteDocumentationPartInput
	Copy  func(*DeleteDocumentationPartInput) DeleteDocumentationPartRequest
}

// Send marshals and sends the DeleteDocumentationPart API request.
func (r DeleteDocumentationPartRequest) Send(ctx context.Context) (*DeleteDocumentationPartOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteDocumentationPartOutput), nil
}

// DeleteDocumentationPartRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the DeleteDocumentationPartRequest method.
//    req := client.DeleteDocumentationPartRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteDocumentationPartRequest(input *DeleteDocumentationPartInput) DeleteDocumentationPartRequest {
	op := &aws.Operation{
		Name:       opDeleteDocumentationPart,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/documentation/parts/{part_id}",
	}

	if input == nil {
		input = &DeleteDocumentationPartInput{}
	}

	output := &DeleteDocumentationPartOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteDocumentationPartRequest{Request: req, Input: input, Copy: c.DeleteDocumentationPartRequest}
}

const opDeleteDocumentationVersion = "DeleteDocumentationVersion"

// DeleteDocumentationVersionRequest is a API request type for the DeleteDocumentationVersion API operation.
type DeleteDocumentationVersionRequest struct {
	*aws.Request
	Input *DeleteDocumentationVersionInput
	Copy  func(*DeleteDocumentationVersionInput) DeleteDocumentationVersionRequest
}

// Send marshals and sends the DeleteDocumentationVersion API request.
func (r DeleteDocumentationVersionRequest) Send(ctx context.Context) (*DeleteDocumentationVersionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteDocumentationVersionOutput), nil
}

// DeleteDocumentationVersionRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the DeleteDocumentationVersionRequest method.
//    req := client.DeleteDocumentationVersionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteDocumentationVersionRequest(input *DeleteDocumentationVersionInput) DeleteDocumentationVersionRequest {
	op := &aws.Operation{
		Name:       opDeleteDocumentationVersion,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/documentation/versions/{doc_version}",
	}

	if input == nil {
		input = &DeleteDocumentationVersionInput{}
	}

	output := &DeleteDocumentationVersionOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteDocumentationVersionRequest{Request: req, Input: input, Copy: c.DeleteDocumentationVersionRequest}
}

const opDeleteDomainName = "DeleteDomainName"

// DeleteDomainNameRequest is a API request type for the DeleteDomainName API operation.
type DeleteDomainNameRequest struct {
	*aws.Request
	Input *DeleteDomainNameInput
	Copy  func(*DeleteDomainNameInput) DeleteDomainNameRequest
}

// Send marshals and sends the DeleteDomainName API request.
func (r DeleteDomainNameRequest) Send(ctx context.Context) (*DeleteDomainNameOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteDomainNameOutput), nil
}

// DeleteDomainNameRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes the DomainName resource.
//
//    // Example sending a request using the DeleteDomainNameRequest method.
//    req := client.DeleteDomainNameRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteDomainNameRequest(input *DeleteDomainNameInput) DeleteDomainNameRequest {
	op := &aws.Operation{
		Name:       opDeleteDomainName,
		HTTPMethod: "DELETE",
		HTTPPath:   "/domainnames/{domain_name}",
	}

	if input == nil {
		input = &DeleteDomainNameInput{}
	}

	output := &DeleteDomainNameOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteDomainNameRequest{Request: req, Input: input, Copy: c.DeleteDomainNameRequest}
}

const opDeleteGatewayResponse = "DeleteGatewayResponse"

// DeleteGatewayResponseRequest is a API request type for the DeleteGatewayResponse API operation.
type DeleteGatewayResponseRequest struct {
	*aws.Request
	Input *DeleteGatewayResponseInput
	Copy  func(*DeleteGatewayResponseInput) DeleteGatewayResponseRequest
}

// Send marshals and sends the DeleteGatewayResponse API request.
func (r DeleteGatewayResponseRequest) Send(ctx context.Context) (*DeleteGatewayResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteGatewayResponseOutput), nil
}

// DeleteGatewayResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Clears any customization of a GatewayResponse of a specified response type
// on the given RestApi and resets it with the default settings.
//
//    // Example sending a request using the DeleteGatewayResponseRequest method.
//    req := client.DeleteGatewayResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteGatewayResponseRequest(input *DeleteGatewayResponseInput) DeleteGatewayResponseRequest {
	op := &aws.Operation{
		Name:       opDeleteGatewayResponse,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/gatewayresponses/{response_type}",
	}

	if input == nil {
		input = &DeleteGatewayResponseInput{}
	}

	output := &DeleteGatewayResponseOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteGatewayResponseRequest{Request: req, Input: input, Copy: c.DeleteGatewayResponseRequest}
}

const opDeleteIntegration = "DeleteIntegration"

// DeleteIntegrationRequest is a API request type for the DeleteIntegration API operation.
type DeleteIntegrationRequest struct {
	*aws.Request
	Input *DeleteIntegrationInput
	Copy  func(*DeleteIntegrationInput) DeleteIntegrationRequest
}

// Send marshals and sends the DeleteIntegration API request.
func (r DeleteIntegrationRequest) Send(ctx context.Context) (*DeleteIntegrationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteIntegrationOutput), nil
}

// DeleteIntegrationRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents a delete integration.
//
//    // Example sending a request using the DeleteIntegrationRequest method.
//    req := client.DeleteIntegrationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteIntegrationRequest(input *DeleteIntegrationInput) DeleteIntegrationRequest {
	op := &aws.Operation{
		Name:       opDeleteIntegration,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration",
	}

	if input == nil {
		input = &DeleteIntegrationInput{}
	}

	output := &DeleteIntegrationOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteIntegrationRequest{Request: req, Input: input, Copy: c.DeleteIntegrationRequest}
}

const opDeleteIntegrationResponse = "DeleteIntegrationResponse"

// DeleteIntegrationResponseRequest is a API request type for the DeleteIntegrationResponse API operation.
type DeleteIntegrationResponseRequest struct {
	*aws.Request
	Input *DeleteIntegrationResponseInput
	Copy  func(*DeleteIntegrationResponseInput) DeleteIntegrationResponseRequest
}

// Send marshals and sends the DeleteIntegrationResponse API request.
func (r DeleteIntegrationResponseRequest) Send(ctx context.Context) (*DeleteIntegrationResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteIntegrationResponseOutput), nil
}

// DeleteIntegrationResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents a delete integration response.
//
//    // Example sending a request using the DeleteIntegrationResponseRequest method.
//    req := client.DeleteIntegrationResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteIntegrationResponseRequest(input *DeleteIntegrationResponseInput) DeleteIntegrationResponseRequest {
	op := &aws.Operation{
		Name:       opDeleteIntegrationResponse,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}",
	}

	if input == nil {
		input = &DeleteIntegrationResponseInput{}
	}

	output := &DeleteIntegrationResponseOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteIntegrationResponseRequest{Request: req, Input: input, Copy: c.DeleteIntegrationResponseRequest}
}

const opDeleteMethod = "DeleteMethod"

// DeleteMethodRequest is a API request type for the DeleteMethod API operation.
type DeleteMethodRequest struct {
	*aws.Request
	Input *DeleteMethodInput
	Copy  func(*DeleteMethodInput) DeleteMethodRequest
}

// Send marshals and sends the DeleteMethod API request.
func (r DeleteMethodRequest) Send(ctx context.Context) (*DeleteMethodOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteMethodOutput), nil
}

// DeleteMethodRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes an existing Method resource.
//
//    // Example sending a request using the DeleteMethodRequest method.
//    req := client.DeleteMethodRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteMethodRequest(input *DeleteMethodInput) DeleteMethodRequest {
	op := &aws.Operation{
		Name:       opDeleteMethod,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
	}

	if input == nil {
		input = &DeleteMethodInput{}
	}

	output := &DeleteMethodOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteMethodRequest{Request: req, Input: input, Copy: c.DeleteMethodRequest}
}

const opDeleteMethodResponse = "DeleteMethodResponse"

// DeleteMethodResponseRequest is a API request type for the DeleteMethodResponse API operation.
type DeleteMethodResponseRequest struct {
	*aws.Request
	Input *DeleteMethodResponseInput
	Copy  func(*DeleteMethodResponseInput) DeleteMethodResponseRequest
}

// Send marshals and sends the DeleteMethodResponse API request.
func (r DeleteMethodResponseRequest) Send(ctx context.Context) (*DeleteMethodResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteMethodResponseOutput), nil
}

// DeleteMethodResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes an existing MethodResponse resource.
//
//    // Example sending a request using the DeleteMethodResponseRequest method.
//    req := client.DeleteMethodResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteMethodResponseRequest(input *DeleteMethodResponseInput) DeleteMethodResponseRequest {
	op := &aws.Operation{
		Name:       opDeleteMethodResponse,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
	}

	if input == nil {
		input = &DeleteMethodResponseInput{}
	}

	output := &DeleteMethodResponseOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteMethodResponseRequest{Request: req, Input: input, Copy: c.DeleteMethodResponseRequest}
}

const opDeleteModel = "DeleteModel"

// DeleteModelRequest is a API request type for the DeleteModel API operation.
type DeleteModelRequest struct {
	*aws.Request
	Input *DeleteModelInput
	Copy  func(*DeleteModelInput) DeleteModelRequest
}

// Send marshals and sends the DeleteModel API request.
func (r DeleteModelRequest) Send(ctx context.Context) (*DeleteModelOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteModelOutput), nil
}

// DeleteModelRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes a model.
//
//    // Example sending a request using the DeleteModelRequest method.
//    req := client.DeleteModelRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteModelRequest(input *DeleteModelInput) DeleteModelRequest {
	op := &aws.Operation{
		Name:       opDeleteModel,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/models/{model_name}",
	}

	if input == nil {
		input = &DeleteModelInput{}
	}

	output := &DeleteModelOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteModelRequest{Request: req, Input: input, Copy: c.DeleteModelRequest}
}

const opDeleteRequestValidator = "DeleteRequestValidator"

// DeleteRequestValidatorRequest is a API request type for the DeleteRequestValidator API operation.
type DeleteRequestValidatorRequest struct {
	*aws.Request
	Input *DeleteRequestValidatorInput
	Copy  func(*DeleteRequestValidatorInput) DeleteRequestValidatorRequest
}

// Send marshals and sends the DeleteRequestValidator API request.
func (r DeleteRequestValidatorRequest) Send(ctx context.Context) (*DeleteRequestValidatorOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteRequestValidatorOutput), nil
}

// DeleteRequestValidatorRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes a RequestValidator of a given RestApi.
//
//    // Example sending a request using the DeleteRequestValidatorRequest method.
//    req := client.DeleteRequestValidatorRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteRequestValidatorRequest(input *DeleteRequestValidatorInput) DeleteRequestValidatorRequest {
	op := &aws.Operation{
		Name:       opDeleteRequestValidator,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}",
	}

	if input == nil {
		input = &DeleteRequestValidatorInput{}
	}

	output := &DeleteRequestValidatorOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteRequestValidatorRequest{Request: req, Input: input, Copy: c.DeleteRequestValidatorRequest}
}

const opDeleteResource = "DeleteResource"

// DeleteResourceRequest is a API request type for the DeleteResource API operation.
type DeleteResourceRequest struct {
	*aws.Request
	Input *DeleteResourceInput
	Copy  func(*DeleteResourceInput) DeleteResourceRequest
}

// Send marshals and sends the DeleteResource API request.
func (r DeleteResourceRequest) Send(ctx context.Context) (*DeleteResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteResourceOutput), nil
}

// DeleteResourceRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes a Resource resource.
//
//    // Example sending a request using the DeleteResourceRequest method.
//    req := client.DeleteResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteResourceRequest(input *DeleteResourceInput) DeleteResourceRequest {
	op := &aws.Operation{
		Name:       opDeleteResource,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}",
	}

	if input == nil {
		input = &DeleteResourceInput{}
	}

	output := &DeleteResourceOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteResourceRequest{Request: req, Input: input, Copy: c.DeleteResourceRequest}
}

const opDeleteRestApi = "DeleteRestApi"

// DeleteRestApiRequest is a API request type for the DeleteRestApi API operation.
type DeleteRestApiRequest struct {
	*aws.Request
	Input *DeleteRestApiInput
	Copy  func(*DeleteRestApiInput) DeleteRestApiRequest
}

// Send marshals and sends the DeleteRestApi API request.
func (r DeleteRestApiRequest) Send(ctx context.Context) (*DeleteRestApiOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteRestApiOutput), nil
}

// DeleteRestApiRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes the specified API.
//
//    // Example sending a request using the DeleteRestApiRequest method.
//    req := client.DeleteRestApiRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteRestApiRequest(input *DeleteRestApiInput) DeleteRestApiRequest {
	op := &aws.Operation{
		Name:       opDeleteRestApi,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}",
	}

	if input == nil {
		input = &DeleteRestApiInput{}
	}

	output := &DeleteRestApiOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteRestApiRequest{Request: req, Input: input, Copy: c.DeleteRestApiRequest}
}

const opDeleteStage = "DeleteStage"

// DeleteStageRequest is a API request type for the DeleteStage API operation.
type DeleteStageRequest struct {
	*aws.Request
	Input *DeleteStageInput
	Copy  func(*DeleteStageInput) DeleteStageRequest
}

// Send marshals and sends the DeleteStage API request.
func (r DeleteStageRequest) Send(ctx context.Context) (*DeleteStageOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteStageOutput), nil
}

// DeleteStageRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes a Stage resource.
//
//    // Example sending a request using the DeleteStageRequest method.
//    req := client.DeleteStageRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteStageRequest(input *DeleteStageInput) DeleteStageRequest {
	op := &aws.Operation{
		Name:       opDeleteStage,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/stages/{stage_name}",
	}

	if input == nil {
		input = &DeleteStageInput{}
	}

	output := &DeleteStageOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteStageRequest{Request: req, Input: input, Copy: c.DeleteStageRequest}
}

const opDeleteUsagePlan = "DeleteUsagePlan"

// DeleteUsagePlanRequest is a API request type for the DeleteUsagePlan API operation.
type DeleteUsagePlanRequest struct {
	*aws.Request
	Input *DeleteUsagePlanInput
	Copy  func(*DeleteUsagePlanInput) DeleteUsagePlanRequest
}

// Send marshals and sends the DeleteUsagePlan API request.
func (r DeleteUsagePlanRequest) Send(ctx context.Context) (*DeleteUsagePlanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteUsagePlanOutput), nil
}

// DeleteUsagePlanRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes a usage plan of a given plan Id.
//
//    // Example sending a request using the DeleteUsagePlanRequest method.
//    req := client.DeleteUsagePlanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteUsagePlanRequest(input *DeleteUsagePlanInput) DeleteUsagePlanRequest {
	op := &aws.Operation{
		Name:       opDeleteUsagePlan,
		HTTPMethod: "DELETE",
		HTTPPath:   "/usageplans/{usageplanId}",
	}

	if input == nil {
		input = &DeleteUsagePlanInput{}
	}

	output := &DeleteUsagePlanOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteUsagePlanRequest{Request: req, Input: input, Copy: c.DeleteUsagePlanRequest}
}

const opDeleteUsagePlanKey = "DeleteUsagePlanKey"

// DeleteUsagePlanKeyRequest is a API request type for the DeleteUsagePlanKey API operation.
type DeleteUsagePlanKeyRequest struct {
	*aws.Request
	Input *DeleteUsagePlanKeyInput
	Copy  func(*DeleteUsagePlanKeyInput) DeleteUsagePlanKeyRequest
}

// Send marshals and sends the DeleteUsagePlanKey API request.
func (r DeleteUsagePlanKeyRequest) Send(ctx context.Context) (*DeleteUsagePlanKeyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteUsagePlanKeyOutput), nil
}

// DeleteUsagePlanKeyRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes a usage plan key and remove the underlying API key from the associated
// usage plan.
//
//    // Example sending a request using the DeleteUsagePlanKeyRequest method.
//    req := client.DeleteUsagePlanKeyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteUsagePlanKeyRequest(input *DeleteUsagePlanKeyInput) DeleteUsagePlanKeyRequest {
	op := &aws.Operation{
		Name:       opDeleteUsagePlanKey,
		HTTPMethod: "DELETE",
		HTTPPath:   "/usageplans/{usageplanId}/keys/{keyId}",
	}

	if input == nil {
		input = &DeleteUsagePlanKeyInput{}
	}

	output := &DeleteUsagePlanKeyOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteUsagePlanKeyRequest{Request: req, Input: input, Copy: c.DeleteUsagePlanKeyRequest}
}

const opDeleteVpcLink = "DeleteVpcLink"

// DeleteVpcLinkRequest is a API request type for the DeleteVpcLink API operation.
type DeleteVpcLinkRequest struct {
	*aws.Request
	Input *DeleteVpcLinkInput
	Copy  func(*DeleteVpcLinkInput) DeleteVpcLinkRequest
}

// Send marshals and sends the DeleteVpcLink API request.
func (r DeleteVpcLinkRequest) Send(ctx context.Context) (*DeleteVpcLinkOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteVpcLinkOutput), nil
}

// DeleteVpcLinkRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Deletes an existing VpcLink of a specified identifier.
//
//    // Example sending a request using the DeleteVpcLinkRequest method.
//    req := client.DeleteVpcLinkRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) DeleteVpcLinkRequest(input *DeleteVpcLinkInput) DeleteVpcLinkRequest {
	op := &aws.Operation{
		Name:       opDeleteVpcLink,
		HTTPMethod: "DELETE",
		HTTPPath:   "/vpclinks/{vpclink_id}",
	}

	if input == nil {
		input = &DeleteVpcLinkInput{}
	}

	output := &DeleteVpcLinkOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteVpcLinkRequest{Request: req, Input: input, Copy: c.DeleteVpcLinkRequest}
}

const opFlushStageAuthorizersCache = "FlushStageAuthorizersCache"

// FlushStageAuthorizersCacheRequest is a API request type for the FlushStageAuthorizersCache API operation.
type FlushStageAuthorizersCacheRequest struct {
	*aws.Request
	Input *FlushStageAuthorizersCacheInput
	Copy  func(*FlushStageAuthorizersCacheInput) FlushStageAuthorizersCacheRequest
}

// Send marshals and sends the FlushStageAuthorizersCache API request.
func (r FlushStageAuthorizersCacheRequest) Send(ctx context.Context) (*FlushStageAuthorizersCacheOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*FlushStageAuthorizersCacheOutput), nil
}

// FlushStageAuthorizersCacheRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Flushes all authorizer cache entries on a stage.
//
//    // Example sending a request using the FlushStageAuthorizersCacheRequest method.
//    req := client.FlushStageAuthorizersCacheRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) FlushStageAuthorizersCacheRequest(input *FlushStageAuthorizersCacheInput) FlushStageAuthorizersCacheRequest {
	op := &aws.Operation{
		Name:       opFlushStageAuthorizersCache,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/stages/{stage_name}/cache/authorizers",
	}

	if input == nil {
		input = &FlushStageAuthorizersCacheInput{}
	}

	output := &FlushStageAuthorizersCacheOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return FlushStageAuthorizersCacheRequest{Request: req, Input: input, Copy: c.FlushStageAuthorizersCacheRequest}
}

const opFlushStageCache = "FlushStageCache"

// FlushStageCacheRequest is a API request type for the FlushStageCache API operation.
type FlushStageCacheRequest struct {
	*aws.Request
	Input *FlushStageCacheInput
	Copy  func(*FlushStageCacheInput) FlushStageCacheRequest
}

// Send marshals and sends the FlushStageCache API request.
func (r FlushStageCacheRequest) Send(ctx context.Context) (*FlushStageCacheOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*FlushStageCacheOutput), nil
}

// FlushStageCacheRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Flushes a stage's cache.
//
//    // Example sending a request using the FlushStageCacheRequest method.
//    req := client.FlushStageCacheRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) FlushStageCacheRequest(input *FlushStageCacheInput) FlushStageCacheRequest {
	op := &aws.Operation{
		Name:       opFlushStageCache,
		HTTPMethod: "DELETE",
		HTTPPath:   "/restapis/{restapi_id}/stages/{stage_name}/cache/data",
	}

	if input == nil {
		input = &FlushStageCacheInput{}
	}

	output := &FlushStageCacheOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return FlushStageCacheRequest{Request: req, Input: input, Copy: c.FlushStageCacheRequest}
}

const opGenerateClientCertificate = "GenerateClientCertificate"

// GenerateClientCertificateRequest is a API request type for the GenerateClientCertificate API operation.
type GenerateClientCertificateRequest struct {
	*aws.Request
	Input *GenerateClientCertificateInput
	Copy  func(*GenerateClientCertificateInput) GenerateClientCertificateRequest
}

// Send marshals and sends the GenerateClientCertificate API request.
func (r GenerateClientCertificateRequest) Send(ctx context.Context) (*UpdateClientCertificateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateClientCertificateOutput), nil
}

// GenerateClientCertificateRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Generates a ClientCertificate resource.
//
//    // Example sending a request using the GenerateClientCertificateRequest method.
//    req := client.GenerateClientCertificateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GenerateClientCertificateRequest(input *GenerateClientCertificateInput) GenerateClientCertificateRequest {
	op := &aws.Operation{
		Name:       opGenerateClientCertificate,
		HTTPMethod: "POST",
		HTTPPath:   "/clientcertificates",
	}

	if input == nil {
		input = &GenerateClientCertificateInput{}
	}

	output := &UpdateClientCertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GenerateClientCertificateRequest{Request: req, Input: input, Copy: c.GenerateClientCertificateRequest}
}

const opGetAccount = "GetAccount"

// GetAccountRequest is a API request type for the GetAccount API operation.
type GetAccountRequest struct {
	*aws.Request
	Input *GetAccountInput
	Copy  func(*GetAccountInput) GetAccountRequest
}

// Send marshals and sends the GetAccount API request.
func (r GetAccountRequest) Send(ctx context.Context) (*UpdateAccountOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateAccountOutput), nil
}

// GetAccountRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets information about the current Account resource.
//
//    // Example sending a request using the GetAccountRequest method.
//    req := client.GetAccountRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetAccountRequest(input *GetAccountInput) GetAccountRequest {
	op := &aws.Operation{
		Name:       opGetAccount,
		HTTPMethod: "GET",
		HTTPPath:   "/account",
	}

	if input == nil {
		input = &GetAccountInput{}
	}

	output := &UpdateAccountOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetAccountRequest{Request: req, Input: input, Copy: c.GetAccountRequest}
}

const opGetApiKey = "GetApiKey"

// GetApiKeyRequest is a API request type for the GetApiKey API operation.
type GetApiKeyRequest struct {
	*aws.Request
	Input *GetApiKeyInput
	Copy  func(*GetApiKeyInput) GetApiKeyRequest
}

// Send marshals and sends the GetApiKey API request.
func (r GetApiKeyRequest) Send(ctx context.Context) (*UpdateApiKeyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateApiKeyOutput), nil
}

// GetApiKeyRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets information about the current ApiKey resource.
//
//    // Example sending a request using the GetApiKeyRequest method.
//    req := client.GetApiKeyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetApiKeyRequest(input *GetApiKeyInput) GetApiKeyRequest {
	op := &aws.Operation{
		Name:       opGetApiKey,
		HTTPMethod: "GET",
		HTTPPath:   "/apikeys/{api_Key}",
	}

	if input == nil {
		input = &GetApiKeyInput{}
	}

	output := &UpdateApiKeyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetApiKeyRequest{Request: req, Input: input, Copy: c.GetApiKeyRequest}
}

const opGetApiKeys = "GetApiKeys"

// GetApiKeysRequest is a API request type for the GetApiKeys API operation.
type GetApiKeysRequest struct {
	*aws.Request
	Input *GetApiKeysInput
	Copy  func(*GetApiKeysInput) GetApiKeysRequest
}

// Send marshals and sends the GetApiKeys API request.
func (r GetApiKeysRequest) Send(ctx context.Context) (*GetApiKeysOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetApiKeysOutput), nil
}

// GetApiKeysRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets information about the current ApiKeys resource.
//
//    // Example sending a request using the GetApiKeysRequest method.
//    req := client.GetApiKeysRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetApiKeysRequest(input *GetApiKeysInput) GetApiKeysRequest {
	op := &aws.Operation{
		Name:       opGetApiKeys,
		HTTPMethod: "GET",
		HTTPPath:   "/apikeys",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetApiKeysInput{}
	}

	output := &GetApiKeysOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetApiKeysRequest{Request: req, Input: input, Copy: c.GetApiKeysRequest}
}

// Paginate pages iterates over the pages of a GetApiKeysRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetApiKeys operation.
//		req := client.GetApiKeysRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetApiKeysRequest) Paginate(opts ...aws.Option) GetApiKeysPager {
	return GetApiKeysPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetApiKeysInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetApiKeysPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetApiKeysPager struct {
	aws.Pager
}

func (p *GetApiKeysPager) CurrentPage() *GetApiKeysOutput {
	return p.Pager.CurrentPage().(*GetApiKeysOutput)
}

const opGetAuthorizer = "GetAuthorizer"

// GetAuthorizerRequest is a API request type for the GetAuthorizer API operation.
type GetAuthorizerRequest struct {
	*aws.Request
	Input *GetAuthorizerInput
	Copy  func(*GetAuthorizerInput) GetAuthorizerRequest
}

// Send marshals and sends the GetAuthorizer API request.
func (r GetAuthorizerRequest) Send(ctx context.Context) (*UpdateAuthorizerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateAuthorizerOutput), nil
}

// GetAuthorizerRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Describe an existing Authorizer resource.
//
// AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-authorizer.html)
//
//    // Example sending a request using the GetAuthorizerRequest method.
//    req := client.GetAuthorizerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetAuthorizerRequest(input *GetAuthorizerInput) GetAuthorizerRequest {
	op := &aws.Operation{
		Name:       opGetAuthorizer,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/authorizers/{authorizer_id}",
	}

	if input == nil {
		input = &GetAuthorizerInput{}
	}

	output := &UpdateAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetAuthorizerRequest{Request: req, Input: input, Copy: c.GetAuthorizerRequest}
}

const opGetAuthorizers = "GetAuthorizers"

// GetAuthorizersRequest is a API request type for the GetAuthorizers API operation.
type GetAuthorizersRequest struct {
	*aws.Request
	Input *GetAuthorizersInput
	Copy  func(*GetAuthorizersInput) GetAuthorizersRequest
}

// Send marshals and sends the GetAuthorizers API request.
func (r GetAuthorizersRequest) Send(ctx context.Context) (*GetAuthorizersOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetAuthorizersOutput), nil
}

// GetAuthorizersRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Describe an existing Authorizers resource.
//
// AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-authorizers.html)
//
//    // Example sending a request using the GetAuthorizersRequest method.
//    req := client.GetAuthorizersRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetAuthorizersRequest(input *GetAuthorizersInput) GetAuthorizersRequest {
	op := &aws.Operation{
		Name:       opGetAuthorizers,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/authorizers",
	}

	if input == nil {
		input = &GetAuthorizersInput{}
	}

	output := &GetAuthorizersOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetAuthorizersRequest{Request: req, Input: input, Copy: c.GetAuthorizersRequest}
}

const opGetBasePathMapping = "GetBasePathMapping"

// GetBasePathMappingRequest is a API request type for the GetBasePathMapping API operation.
type GetBasePathMappingRequest struct {
	*aws.Request
	Input *GetBasePathMappingInput
	Copy  func(*GetBasePathMappingInput) GetBasePathMappingRequest
}

// Send marshals and sends the GetBasePathMapping API request.
func (r GetBasePathMappingRequest) Send(ctx context.Context) (*UpdateBasePathMappingOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateBasePathMappingOutput), nil
}

// GetBasePathMappingRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Describe a BasePathMapping resource.
//
//    // Example sending a request using the GetBasePathMappingRequest method.
//    req := client.GetBasePathMappingRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetBasePathMappingRequest(input *GetBasePathMappingInput) GetBasePathMappingRequest {
	op := &aws.Operation{
		Name:       opGetBasePathMapping,
		HTTPMethod: "GET",
		HTTPPath:   "/domainnames/{domain_name}/basepathmappings/{base_path}",
	}

	if input == nil {
		input = &GetBasePathMappingInput{}
	}

	output := &UpdateBasePathMappingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBasePathMappingRequest{Request: req, Input: input, Copy: c.GetBasePathMappingRequest}
}

const opGetBasePathMappings = "GetBasePathMappings"

// GetBasePathMappingsRequest is a API request type for the GetBasePathMappings API operation.
type GetBasePathMappingsRequest struct {
	*aws.Request
	Input *GetBasePathMappingsInput
	Copy  func(*GetBasePathMappingsInput) GetBasePathMappingsRequest
}

// Send marshals and sends the GetBasePathMappings API request.
func (r GetBasePathMappingsRequest) Send(ctx context.Context) (*GetBasePathMappingsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetBasePathMappingsOutput), nil
}

// GetBasePathMappingsRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents a collection of BasePathMapping resources.
//
//    // Example sending a request using the GetBasePathMappingsRequest method.
//    req := client.GetBasePathMappingsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetBasePathMappingsRequest(input *GetBasePathMappingsInput) GetBasePathMappingsRequest {
	op := &aws.Operation{
		Name:       opGetBasePathMappings,
		HTTPMethod: "GET",
		HTTPPath:   "/domainnames/{domain_name}/basepathmappings",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetBasePathMappingsInput{}
	}

	output := &GetBasePathMappingsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetBasePathMappingsRequest{Request: req, Input: input, Copy: c.GetBasePathMappingsRequest}
}

// Paginate pages iterates over the pages of a GetBasePathMappingsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetBasePathMappings operation.
//		req := client.GetBasePathMappingsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetBasePathMappingsRequest) Paginate(opts ...aws.Option) GetBasePathMappingsPager {
	return GetBasePathMappingsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetBasePathMappingsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetBasePathMappingsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetBasePathMappingsPager struct {
	aws.Pager
}

func (p *GetBasePathMappingsPager) CurrentPage() *GetBasePathMappingsOutput {
	return p.Pager.CurrentPage().(*GetBasePathMappingsOutput)
}

const opGetClientCertificate = "GetClientCertificate"

// GetClientCertificateRequest is a API request type for the GetClientCertificate API operation.
type GetClientCertificateRequest struct {
	*aws.Request
	Input *GetClientCertificateInput
	Copy  func(*GetClientCertificateInput) GetClientCertificateRequest
}

// Send marshals and sends the GetClientCertificate API request.
func (r GetClientCertificateRequest) Send(ctx context.Context) (*UpdateClientCertificateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateClientCertificateOutput), nil
}

// GetClientCertificateRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets information about the current ClientCertificate resource.
//
//    // Example sending a request using the GetClientCertificateRequest method.
//    req := client.GetClientCertificateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetClientCertificateRequest(input *GetClientCertificateInput) GetClientCertificateRequest {
	op := &aws.Operation{
		Name:       opGetClientCertificate,
		HTTPMethod: "GET",
		HTTPPath:   "/clientcertificates/{clientcertificate_id}",
	}

	if input == nil {
		input = &GetClientCertificateInput{}
	}

	output := &UpdateClientCertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetClientCertificateRequest{Request: req, Input: input, Copy: c.GetClientCertificateRequest}
}

const opGetClientCertificates = "GetClientCertificates"

// GetClientCertificatesRequest is a API request type for the GetClientCertificates API operation.
type GetClientCertificatesRequest struct {
	*aws.Request
	Input *GetClientCertificatesInput
	Copy  func(*GetClientCertificatesInput) GetClientCertificatesRequest
}

// Send marshals and sends the GetClientCertificates API request.
func (r GetClientCertificatesRequest) Send(ctx context.Context) (*GetClientCertificatesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetClientCertificatesOutput), nil
}

// GetClientCertificatesRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets a collection of ClientCertificate resources.
//
//    // Example sending a request using the GetClientCertificatesRequest method.
//    req := client.GetClientCertificatesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetClientCertificatesRequest(input *GetClientCertificatesInput) GetClientCertificatesRequest {
	op := &aws.Operation{
		Name:       opGetClientCertificates,
		HTTPMethod: "GET",
		HTTPPath:   "/clientcertificates",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetClientCertificatesInput{}
	}

	output := &GetClientCertificatesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetClientCertificatesRequest{Request: req, Input: input, Copy: c.GetClientCertificatesRequest}
}

// Paginate pages iterates over the pages of a GetClientCertificatesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetClientCertificates operation.
//		req := client.GetClientCertificatesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetClientCertificatesRequest) Paginate(opts ...aws.Option) GetClientCertificatesPager {
	return GetClientCertificatesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetClientCertificatesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetClientCertificatesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetClientCertificatesPager struct {
	aws.Pager
}

func (p *GetClientCertificatesPager) CurrentPage() *GetClientCertificatesOutput {
	return p.Pager.CurrentPage().(*GetClientCertificatesOutput)
}

const opGetDeployment = "GetDeployment"

// GetDeploymentRequest is a API request type for the GetDeployment API operation.
type GetDeploymentRequest struct {
	*aws.Request
	Input *GetDeploymentInput
	Copy  func(*GetDeploymentInput) GetDeploymentRequest
}

// Send marshals and sends the GetDeployment API request.
func (r GetDeploymentRequest) Send(ctx context.Context) (*UpdateDeploymentOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDeploymentOutput), nil
}

// GetDeploymentRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets information about a Deployment resource.
//
//    // Example sending a request using the GetDeploymentRequest method.
//    req := client.GetDeploymentRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetDeploymentRequest(input *GetDeploymentInput) GetDeploymentRequest {
	op := &aws.Operation{
		Name:       opGetDeployment,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/deployments/{deployment_id}",
	}

	if input == nil {
		input = &GetDeploymentInput{}
	}

	output := &UpdateDeploymentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDeploymentRequest{Request: req, Input: input, Copy: c.GetDeploymentRequest}
}

const opGetDeployments = "GetDeployments"

// GetDeploymentsRequest is a API request type for the GetDeployments API operation.
type GetDeploymentsRequest struct {
	*aws.Request
	Input *GetDeploymentsInput
	Copy  func(*GetDeploymentsInput) GetDeploymentsRequest
}

// Send marshals and sends the GetDeployments API request.
func (r GetDeploymentsRequest) Send(ctx context.Context) (*GetDeploymentsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDeploymentsOutput), nil
}

// GetDeploymentsRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets information about a Deployments collection.
//
//    // Example sending a request using the GetDeploymentsRequest method.
//    req := client.GetDeploymentsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetDeploymentsRequest(input *GetDeploymentsInput) GetDeploymentsRequest {
	op := &aws.Operation{
		Name:       opGetDeployments,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/deployments",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetDeploymentsInput{}
	}

	output := &GetDeploymentsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDeploymentsRequest{Request: req, Input: input, Copy: c.GetDeploymentsRequest}
}

// Paginate pages iterates over the pages of a GetDeploymentsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetDeployments operation.
//		req := client.GetDeploymentsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetDeploymentsRequest) Paginate(opts ...aws.Option) GetDeploymentsPager {
	return GetDeploymentsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetDeploymentsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetDeploymentsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetDeploymentsPager struct {
	aws.Pager
}

func (p *GetDeploymentsPager) CurrentPage() *GetDeploymentsOutput {
	return p.Pager.CurrentPage().(*GetDeploymentsOutput)
}

const opGetDocumentationPart = "GetDocumentationPart"

// GetDocumentationPartRequest is a API request type for the GetDocumentationPart API operation.
type GetDocumentationPartRequest struct {
	*aws.Request
	Input *GetDocumentationPartInput
	Copy  func(*GetDocumentationPartInput) GetDocumentationPartRequest
}

// Send marshals and sends the GetDocumentationPart API request.
func (r GetDocumentationPartRequest) Send(ctx context.Context) (*UpdateDocumentationPartOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDocumentationPartOutput), nil
}

// GetDocumentationPartRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the GetDocumentationPartRequest method.
//    req := client.GetDocumentationPartRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetDocumentationPartRequest(input *GetDocumentationPartInput) GetDocumentationPartRequest {
	op := &aws.Operation{
		Name:       opGetDocumentationPart,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/documentation/parts/{part_id}",
	}

	if input == nil {
		input = &GetDocumentationPartInput{}
	}

	output := &UpdateDocumentationPartOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDocumentationPartRequest{Request: req, Input: input, Copy: c.GetDocumentationPartRequest}
}

const opGetDocumentationParts = "GetDocumentationParts"

// GetDocumentationPartsRequest is a API request type for the GetDocumentationParts API operation.
type GetDocumentationPartsRequest struct {
	*aws.Request
	Input *GetDocumentationPartsInput
	Copy  func(*GetDocumentationPartsInput) GetDocumentationPartsRequest
}

// Send marshals and sends the GetDocumentationParts API request.
func (r GetDocumentationPartsRequest) Send(ctx context.Context) (*GetDocumentationPartsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDocumentationPartsOutput), nil
}

// GetDocumentationPartsRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the GetDocumentationPartsRequest method.
//    req := client.GetDocumentationPartsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetDocumentationPartsRequest(input *GetDocumentationPartsInput) GetDocumentationPartsRequest {
	op := &aws.Operation{
		Name:       opGetDocumentationParts,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/documentation/parts",
	}

	if input == nil {
		input = &GetDocumentationPartsInput{}
	}

	output := &GetDocumentationPartsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDocumentationPartsRequest{Request: req, Input: input, Copy: c.GetDocumentationPartsRequest}
}

const opGetDocumentationVersion = "GetDocumentationVersion"

// GetDocumentationVersionRequest is a API request type for the GetDocumentationVersion API operation.
type GetDocumentationVersionRequest struct {
	*aws.Request
	Input *GetDocumentationVersionInput
	Copy  func(*GetDocumentationVersionInput) GetDocumentationVersionRequest
}

// Send marshals and sends the GetDocumentationVersion API request.
func (r GetDocumentationVersionRequest) Send(ctx context.Context) (*UpdateDocumentationVersionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDocumentationVersionOutput), nil
}

// GetDocumentationVersionRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the GetDocumentationVersionRequest method.
//    req := client.GetDocumentationVersionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetDocumentationVersionRequest(input *GetDocumentationVersionInput) GetDocumentationVersionRequest {
	op := &aws.Operation{
		Name:       opGetDocumentationVersion,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/documentation/versions/{doc_version}",
	}

	if input == nil {
		input = &GetDocumentationVersionInput{}
	}

	output := &UpdateDocumentationVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDocumentationVersionRequest{Request: req, Input: input, Copy: c.GetDocumentationVersionRequest}
}

const opGetDocumentationVersions = "GetDocumentationVersions"

// GetDocumentationVersionsRequest is a API request type for the GetDocumentationVersions API operation.
type GetDocumentationVersionsRequest struct {
	*aws.Request
	Input *GetDocumentationVersionsInput
	Copy  func(*GetDocumentationVersionsInput) GetDocumentationVersionsRequest
}

// Send marshals and sends the GetDocumentationVersions API request.
func (r GetDocumentationVersionsRequest) Send(ctx context.Context) (*GetDocumentationVersionsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDocumentationVersionsOutput), nil
}

// GetDocumentationVersionsRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the GetDocumentationVersionsRequest method.
//    req := client.GetDocumentationVersionsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetDocumentationVersionsRequest(input *GetDocumentationVersionsInput) GetDocumentationVersionsRequest {
	op := &aws.Operation{
		Name:       opGetDocumentationVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/documentation/versions",
	}

	if input == nil {
		input = &GetDocumentationVersionsInput{}
	}

	output := &GetDocumentationVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDocumentationVersionsRequest{Request: req, Input: input, Copy: c.GetDocumentationVersionsRequest}
}

const opGetDomainName = "GetDomainName"

// GetDomainNameRequest is a API request type for the GetDomainName API operation.
type GetDomainNameRequest struct {
	*aws.Request
	Input *GetDomainNameInput
	Copy  func(*GetDomainNameInput) GetDomainNameRequest
}

// Send marshals and sends the GetDomainName API request.
func (r GetDomainNameRequest) Send(ctx context.Context) (*UpdateDomainNameOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDomainNameOutput), nil
}

// GetDomainNameRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents a domain name that is contained in a simpler, more intuitive URL
// that can be called.
//
//    // Example sending a request using the GetDomainNameRequest method.
//    req := client.GetDomainNameRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetDomainNameRequest(input *GetDomainNameInput) GetDomainNameRequest {
	op := &aws.Operation{
		Name:       opGetDomainName,
		HTTPMethod: "GET",
		HTTPPath:   "/domainnames/{domain_name}",
	}

	if input == nil {
		input = &GetDomainNameInput{}
	}

	output := &UpdateDomainNameOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDomainNameRequest{Request: req, Input: input, Copy: c.GetDomainNameRequest}
}

const opGetDomainNames = "GetDomainNames"

// GetDomainNamesRequest is a API request type for the GetDomainNames API operation.
type GetDomainNamesRequest struct {
	*aws.Request
	Input *GetDomainNamesInput
	Copy  func(*GetDomainNamesInput) GetDomainNamesRequest
}

// Send marshals and sends the GetDomainNames API request.
func (r GetDomainNamesRequest) Send(ctx context.Context) (*GetDomainNamesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetDomainNamesOutput), nil
}

// GetDomainNamesRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents a collection of DomainName resources.
//
//    // Example sending a request using the GetDomainNamesRequest method.
//    req := client.GetDomainNamesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetDomainNamesRequest(input *GetDomainNamesInput) GetDomainNamesRequest {
	op := &aws.Operation{
		Name:       opGetDomainNames,
		HTTPMethod: "GET",
		HTTPPath:   "/domainnames",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetDomainNamesInput{}
	}

	output := &GetDomainNamesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetDomainNamesRequest{Request: req, Input: input, Copy: c.GetDomainNamesRequest}
}

// Paginate pages iterates over the pages of a GetDomainNamesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetDomainNames operation.
//		req := client.GetDomainNamesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetDomainNamesRequest) Paginate(opts ...aws.Option) GetDomainNamesPager {
	return GetDomainNamesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetDomainNamesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetDomainNamesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetDomainNamesPager struct {
	aws.Pager
}

func (p *GetDomainNamesPager) CurrentPage() *GetDomainNamesOutput {
	return p.Pager.CurrentPage().(*GetDomainNamesOutput)
}

const opGetExport = "GetExport"

// GetExportRequest is a API request type for the GetExport API operation.
type GetExportRequest struct {
	*aws.Request
	Input *GetExportInput
	Copy  func(*GetExportInput) GetExportRequest
}

// Send marshals and sends the GetExport API request.
func (r GetExportRequest) Send(ctx context.Context) (*GetExportOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetExportOutput), nil
}

// GetExportRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Exports a deployed version of a RestApi in a specified format.
//
//    // Example sending a request using the GetExportRequest method.
//    req := client.GetExportRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetExportRequest(input *GetExportInput) GetExportRequest {
	op := &aws.Operation{
		Name:       opGetExport,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/stages/{stage_name}/exports/{export_type}",
	}

	if input == nil {
		input = &GetExportInput{}
	}

	output := &GetExportOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetExportRequest{Request: req, Input: input, Copy: c.GetExportRequest}
}

const opGetGatewayResponse = "GetGatewayResponse"

// GetGatewayResponseRequest is a API request type for the GetGatewayResponse API operation.
type GetGatewayResponseRequest struct {
	*aws.Request
	Input *GetGatewayResponseInput
	Copy  func(*GetGatewayResponseInput) GetGatewayResponseRequest
}

// Send marshals and sends the GetGatewayResponse API request.
func (r GetGatewayResponseRequest) Send(ctx context.Context) (*UpdateGatewayResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGatewayResponseOutput), nil
}

// GetGatewayResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets a GatewayResponse of a specified response type on the given RestApi.
//
//    // Example sending a request using the GetGatewayResponseRequest method.
//    req := client.GetGatewayResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetGatewayResponseRequest(input *GetGatewayResponseInput) GetGatewayResponseRequest {
	op := &aws.Operation{
		Name:       opGetGatewayResponse,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/gatewayresponses/{response_type}",
	}

	if input == nil {
		input = &GetGatewayResponseInput{}
	}

	output := &UpdateGatewayResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetGatewayResponseRequest{Request: req, Input: input, Copy: c.GetGatewayResponseRequest}
}

const opGetGatewayResponses = "GetGatewayResponses"

// GetGatewayResponsesRequest is a API request type for the GetGatewayResponses API operation.
type GetGatewayResponsesRequest struct {
	*aws.Request
	Input *GetGatewayResponsesInput
	Copy  func(*GetGatewayResponsesInput) GetGatewayResponsesRequest
}

// Send marshals and sends the GetGatewayResponses API request.
func (r GetGatewayResponsesRequest) Send(ctx context.Context) (*GetGatewayResponsesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetGatewayResponsesOutput), nil
}

// GetGatewayResponsesRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets the GatewayResponses collection on the given RestApi. If an API developer
// has not added any definitions for gateway responses, the result will be the
// API Gateway-generated default GatewayResponses collection for the supported
// response types.
//
//    // Example sending a request using the GetGatewayResponsesRequest method.
//    req := client.GetGatewayResponsesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetGatewayResponsesRequest(input *GetGatewayResponsesInput) GetGatewayResponsesRequest {
	op := &aws.Operation{
		Name:       opGetGatewayResponses,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/gatewayresponses",
	}

	if input == nil {
		input = &GetGatewayResponsesInput{}
	}

	output := &GetGatewayResponsesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetGatewayResponsesRequest{Request: req, Input: input, Copy: c.GetGatewayResponsesRequest}
}

const opGetIntegration = "GetIntegration"

// GetIntegrationRequest is a API request type for the GetIntegration API operation.
type GetIntegrationRequest struct {
	*aws.Request
	Input *GetIntegrationInput
	Copy  func(*GetIntegrationInput) GetIntegrationRequest
}

// Send marshals and sends the GetIntegration API request.
func (r GetIntegrationRequest) Send(ctx context.Context) (*UpdateIntegrationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateIntegrationOutput), nil
}

// GetIntegrationRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Get the integration settings.
//
//    // Example sending a request using the GetIntegrationRequest method.
//    req := client.GetIntegrationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetIntegrationRequest(input *GetIntegrationInput) GetIntegrationRequest {
	op := &aws.Operation{
		Name:       opGetIntegration,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration",
	}

	if input == nil {
		input = &GetIntegrationInput{}
	}

	output := &UpdateIntegrationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetIntegrationRequest{Request: req, Input: input, Copy: c.GetIntegrationRequest}
}

const opGetIntegrationResponse = "GetIntegrationResponse"

// GetIntegrationResponseRequest is a API request type for the GetIntegrationResponse API operation.
type GetIntegrationResponseRequest struct {
	*aws.Request
	Input *GetIntegrationResponseInput
	Copy  func(*GetIntegrationResponseInput) GetIntegrationResponseRequest
}

// Send marshals and sends the GetIntegrationResponse API request.
func (r GetIntegrationResponseRequest) Send(ctx context.Context) (*UpdateIntegrationResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateIntegrationResponseOutput), nil
}

// GetIntegrationResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents a get integration response.
//
//    // Example sending a request using the GetIntegrationResponseRequest method.
//    req := client.GetIntegrationResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetIntegrationResponseRequest(input *GetIntegrationResponseInput) GetIntegrationResponseRequest {
	op := &aws.Operation{
		Name:       opGetIntegrationResponse,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}",
	}

	if input == nil {
		input = &GetIntegrationResponseInput{}
	}

	output := &UpdateIntegrationResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetIntegrationResponseRequest{Request: req, Input: input, Copy: c.GetIntegrationResponseRequest}
}

const opGetMethod = "GetMethod"

// GetMethodRequest is a API request type for the GetMethod API operation.
type GetMethodRequest struct {
	*aws.Request
	Input *GetMethodInput
	Copy  func(*GetMethodInput) GetMethodRequest
}

// Send marshals and sends the GetMethod API request.
func (r GetMethodRequest) Send(ctx context.Context) (*UpdateMethodOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateMethodOutput), nil
}

// GetMethodRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Describe an existing Method resource.
//
//    // Example sending a request using the GetMethodRequest method.
//    req := client.GetMethodRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetMethodRequest(input *GetMethodInput) GetMethodRequest {
	op := &aws.Operation{
		Name:       opGetMethod,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
	}

	if input == nil {
		input = &GetMethodInput{}
	}

	output := &UpdateMethodOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetMethodRequest{Request: req, Input: input, Copy: c.GetMethodRequest}
}

const opGetMethodResponse = "GetMethodResponse"

// GetMethodResponseRequest is a API request type for the GetMethodResponse API operation.
type GetMethodResponseRequest struct {
	*aws.Request
	Input *GetMethodResponseInput
	Copy  func(*GetMethodResponseInput) GetMethodResponseRequest
}

// Send marshals and sends the GetMethodResponse API request.
func (r GetMethodResponseRequest) Send(ctx context.Context) (*UpdateMethodResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateMethodResponseOutput), nil
}

// GetMethodResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Describes a MethodResponse resource.
//
//    // Example sending a request using the GetMethodResponseRequest method.
//    req := client.GetMethodResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetMethodResponseRequest(input *GetMethodResponseInput) GetMethodResponseRequest {
	op := &aws.Operation{
		Name:       opGetMethodResponse,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
	}

	if input == nil {
		input = &GetMethodResponseInput{}
	}

	output := &UpdateMethodResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetMethodResponseRequest{Request: req, Input: input, Copy: c.GetMethodResponseRequest}
}

const opGetModel = "GetModel"

// GetModelRequest is a API request type for the GetModel API operation.
type GetModelRequest struct {
	*aws.Request
	Input *GetModelInput
	Copy  func(*GetModelInput) GetModelRequest
}

// Send marshals and sends the GetModel API request.
func (r GetModelRequest) Send(ctx context.Context) (*UpdateModelOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateModelOutput), nil
}

// GetModelRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Describes an existing model defined for a RestApi resource.
//
//    // Example sending a request using the GetModelRequest method.
//    req := client.GetModelRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetModelRequest(input *GetModelInput) GetModelRequest {
	op := &aws.Operation{
		Name:       opGetModel,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/models/{model_name}",
	}

	if input == nil {
		input = &GetModelInput{}
	}

	output := &UpdateModelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetModelRequest{Request: req, Input: input, Copy: c.GetModelRequest}
}

const opGetModelTemplate = "GetModelTemplate"

// GetModelTemplateRequest is a API request type for the GetModelTemplate API operation.
type GetModelTemplateRequest struct {
	*aws.Request
	Input *GetModelTemplateInput
	Copy  func(*GetModelTemplateInput) GetModelTemplateRequest
}

// Send marshals and sends the GetModelTemplate API request.
func (r GetModelTemplateRequest) Send(ctx context.Context) (*GetModelTemplateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetModelTemplateOutput), nil
}

// GetModelTemplateRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Generates a sample mapping template that can be used to transform a payload
// into the structure of a model.
//
//    // Example sending a request using the GetModelTemplateRequest method.
//    req := client.GetModelTemplateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetModelTemplateRequest(input *GetModelTemplateInput) GetModelTemplateRequest {
	op := &aws.Operation{
		Name:       opGetModelTemplate,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/models/{model_name}/default_template",
	}

	if input == nil {
		input = &GetModelTemplateInput{}
	}

	output := &GetModelTemplateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetModelTemplateRequest{Request: req, Input: input, Copy: c.GetModelTemplateRequest}
}

const opGetModels = "GetModels"

// GetModelsRequest is a API request type for the GetModels API operation.
type GetModelsRequest struct {
	*aws.Request
	Input *GetModelsInput
	Copy  func(*GetModelsInput) GetModelsRequest
}

// Send marshals and sends the GetModels API request.
func (r GetModelsRequest) Send(ctx context.Context) (*GetModelsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetModelsOutput), nil
}

// GetModelsRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Describes existing Models defined for a RestApi resource.
//
//    // Example sending a request using the GetModelsRequest method.
//    req := client.GetModelsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetModelsRequest(input *GetModelsInput) GetModelsRequest {
	op := &aws.Operation{
		Name:       opGetModels,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/models",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetModelsInput{}
	}

	output := &GetModelsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetModelsRequest{Request: req, Input: input, Copy: c.GetModelsRequest}
}

// Paginate pages iterates over the pages of a GetModelsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetModels operation.
//		req := client.GetModelsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetModelsRequest) Paginate(opts ...aws.Option) GetModelsPager {
	return GetModelsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetModelsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetModelsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetModelsPager struct {
	aws.Pager
}

func (p *GetModelsPager) CurrentPage() *GetModelsOutput {
	return p.Pager.CurrentPage().(*GetModelsOutput)
}

const opGetRequestValidator = "GetRequestValidator"

// GetRequestValidatorRequest is a API request type for the GetRequestValidator API operation.
type GetRequestValidatorRequest struct {
	*aws.Request
	Input *GetRequestValidatorInput
	Copy  func(*GetRequestValidatorInput) GetRequestValidatorRequest
}

// Send marshals and sends the GetRequestValidator API request.
func (r GetRequestValidatorRequest) Send(ctx context.Context) (*UpdateRequestValidatorOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRequestValidatorOutput), nil
}

// GetRequestValidatorRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets a RequestValidator of a given RestApi.
//
//    // Example sending a request using the GetRequestValidatorRequest method.
//    req := client.GetRequestValidatorRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetRequestValidatorRequest(input *GetRequestValidatorInput) GetRequestValidatorRequest {
	op := &aws.Operation{
		Name:       opGetRequestValidator,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}",
	}

	if input == nil {
		input = &GetRequestValidatorInput{}
	}

	output := &UpdateRequestValidatorOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetRequestValidatorRequest{Request: req, Input: input, Copy: c.GetRequestValidatorRequest}
}

const opGetRequestValidators = "GetRequestValidators"

// GetRequestValidatorsRequest is a API request type for the GetRequestValidators API operation.
type GetRequestValidatorsRequest struct {
	*aws.Request
	Input *GetRequestValidatorsInput
	Copy  func(*GetRequestValidatorsInput) GetRequestValidatorsRequest
}

// Send marshals and sends the GetRequestValidators API request.
func (r GetRequestValidatorsRequest) Send(ctx context.Context) (*GetRequestValidatorsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetRequestValidatorsOutput), nil
}

// GetRequestValidatorsRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets the RequestValidators collection of a given RestApi.
//
//    // Example sending a request using the GetRequestValidatorsRequest method.
//    req := client.GetRequestValidatorsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetRequestValidatorsRequest(input *GetRequestValidatorsInput) GetRequestValidatorsRequest {
	op := &aws.Operation{
		Name:       opGetRequestValidators,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/requestvalidators",
	}

	if input == nil {
		input = &GetRequestValidatorsInput{}
	}

	output := &GetRequestValidatorsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetRequestValidatorsRequest{Request: req, Input: input, Copy: c.GetRequestValidatorsRequest}
}

const opGetResource = "GetResource"

// GetResourceRequest is a API request type for the GetResource API operation.
type GetResourceRequest struct {
	*aws.Request
	Input *GetResourceInput
	Copy  func(*GetResourceInput) GetResourceRequest
}

// Send marshals and sends the GetResource API request.
func (r GetResourceRequest) Send(ctx context.Context) (*UpdateResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateResourceOutput), nil
}

// GetResourceRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Lists information about a resource.
//
//    // Example sending a request using the GetResourceRequest method.
//    req := client.GetResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetResourceRequest(input *GetResourceInput) GetResourceRequest {
	op := &aws.Operation{
		Name:       opGetResource,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}",
	}

	if input == nil {
		input = &GetResourceInput{}
	}

	output := &UpdateResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetResourceRequest{Request: req, Input: input, Copy: c.GetResourceRequest}
}

const opGetResources = "GetResources"

// GetResourcesRequest is a API request type for the GetResources API operation.
type GetResourcesRequest struct {
	*aws.Request
	Input *GetResourcesInput
	Copy  func(*GetResourcesInput) GetResourcesRequest
}

// Send marshals and sends the GetResources API request.
func (r GetResourcesRequest) Send(ctx context.Context) (*GetResourcesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetResourcesOutput), nil
}

// GetResourcesRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Lists information about a collection of Resource resources.
//
//    // Example sending a request using the GetResourcesRequest method.
//    req := client.GetResourcesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetResourcesRequest(input *GetResourcesInput) GetResourcesRequest {
	op := &aws.Operation{
		Name:       opGetResources,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/resources",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetResourcesInput{}
	}

	output := &GetResourcesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetResourcesRequest{Request: req, Input: input, Copy: c.GetResourcesRequest}
}

// Paginate pages iterates over the pages of a GetResourcesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetResources operation.
//		req := client.GetResourcesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetResourcesRequest) Paginate(opts ...aws.Option) GetResourcesPager {
	return GetResourcesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetResourcesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetResourcesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetResourcesPager struct {
	aws.Pager
}

func (p *GetResourcesPager) CurrentPage() *GetResourcesOutput {
	return p.Pager.CurrentPage().(*GetResourcesOutput)
}

const opGetRestApi = "GetRestApi"

// GetRestApiRequest is a API request type for the GetRestApi API operation.
type GetRestApiRequest struct {
	*aws.Request
	Input *GetRestApiInput
	Copy  func(*GetRestApiInput) GetRestApiRequest
}

// Send marshals and sends the GetRestApi API request.
func (r GetRestApiRequest) Send(ctx context.Context) (*UpdateRestApiOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRestApiOutput), nil
}

// GetRestApiRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Lists the RestApi resource in the collection.
//
//    // Example sending a request using the GetRestApiRequest method.
//    req := client.GetRestApiRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetRestApiRequest(input *GetRestApiInput) GetRestApiRequest {
	op := &aws.Operation{
		Name:       opGetRestApi,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}",
	}

	if input == nil {
		input = &GetRestApiInput{}
	}

	output := &UpdateRestApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetRestApiRequest{Request: req, Input: input, Copy: c.GetRestApiRequest}
}

const opGetRestApis = "GetRestApis"

// GetRestApisRequest is a API request type for the GetRestApis API operation.
type GetRestApisRequest struct {
	*aws.Request
	Input *GetRestApisInput
	Copy  func(*GetRestApisInput) GetRestApisRequest
}

// Send marshals and sends the GetRestApis API request.
func (r GetRestApisRequest) Send(ctx context.Context) (*GetRestApisOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetRestApisOutput), nil
}

// GetRestApisRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Lists the RestApis resources for your collection.
//
//    // Example sending a request using the GetRestApisRequest method.
//    req := client.GetRestApisRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetRestApisRequest(input *GetRestApisInput) GetRestApisRequest {
	op := &aws.Operation{
		Name:       opGetRestApis,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetRestApisInput{}
	}

	output := &GetRestApisOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetRestApisRequest{Request: req, Input: input, Copy: c.GetRestApisRequest}
}

// Paginate pages iterates over the pages of a GetRestApisRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetRestApis operation.
//		req := client.GetRestApisRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetRestApisRequest) Paginate(opts ...aws.Option) GetRestApisPager {
	return GetRestApisPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetRestApisInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetRestApisPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetRestApisPager struct {
	aws.Pager
}

func (p *GetRestApisPager) CurrentPage() *GetRestApisOutput {
	return p.Pager.CurrentPage().(*GetRestApisOutput)
}

const opGetSdk = "GetSdk"

// GetSdkRequest is a API request type for the GetSdk API operation.
type GetSdkRequest struct {
	*aws.Request
	Input *GetSdkInput
	Copy  func(*GetSdkInput) GetSdkRequest
}

// Send marshals and sends the GetSdk API request.
func (r GetSdkRequest) Send(ctx context.Context) (*GetSdkOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSdkOutput), nil
}

// GetSdkRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Generates a client SDK for a RestApi and Stage.
//
//    // Example sending a request using the GetSdkRequest method.
//    req := client.GetSdkRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetSdkRequest(input *GetSdkInput) GetSdkRequest {
	op := &aws.Operation{
		Name:       opGetSdk,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/stages/{stage_name}/sdks/{sdk_type}",
	}

	if input == nil {
		input = &GetSdkInput{}
	}

	output := &GetSdkOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSdkRequest{Request: req, Input: input, Copy: c.GetSdkRequest}
}

const opGetSdkType = "GetSdkType"

// GetSdkTypeRequest is a API request type for the GetSdkType API operation.
type GetSdkTypeRequest struct {
	*aws.Request
	Input *GetSdkTypeInput
	Copy  func(*GetSdkTypeInput) GetSdkTypeRequest
}

// Send marshals and sends the GetSdkType API request.
func (r GetSdkTypeRequest) Send(ctx context.Context) (*GetSdkTypeOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSdkTypeOutput), nil
}

// GetSdkTypeRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the GetSdkTypeRequest method.
//    req := client.GetSdkTypeRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetSdkTypeRequest(input *GetSdkTypeInput) GetSdkTypeRequest {
	op := &aws.Operation{
		Name:       opGetSdkType,
		HTTPMethod: "GET",
		HTTPPath:   "/sdktypes/{sdktype_id}",
	}

	if input == nil {
		input = &GetSdkTypeInput{}
	}

	output := &GetSdkTypeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSdkTypeRequest{Request: req, Input: input, Copy: c.GetSdkTypeRequest}
}

const opGetSdkTypes = "GetSdkTypes"

// GetSdkTypesRequest is a API request type for the GetSdkTypes API operation.
type GetSdkTypesRequest struct {
	*aws.Request
	Input *GetSdkTypesInput
	Copy  func(*GetSdkTypesInput) GetSdkTypesRequest
}

// Send marshals and sends the GetSdkTypes API request.
func (r GetSdkTypesRequest) Send(ctx context.Context) (*GetSdkTypesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetSdkTypesOutput), nil
}

// GetSdkTypesRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the GetSdkTypesRequest method.
//    req := client.GetSdkTypesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetSdkTypesRequest(input *GetSdkTypesInput) GetSdkTypesRequest {
	op := &aws.Operation{
		Name:       opGetSdkTypes,
		HTTPMethod: "GET",
		HTTPPath:   "/sdktypes",
	}

	if input == nil {
		input = &GetSdkTypesInput{}
	}

	output := &GetSdkTypesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetSdkTypesRequest{Request: req, Input: input, Copy: c.GetSdkTypesRequest}
}

const opGetStage = "GetStage"

// GetStageRequest is a API request type for the GetStage API operation.
type GetStageRequest struct {
	*aws.Request
	Input *GetStageInput
	Copy  func(*GetStageInput) GetStageRequest
}

// Send marshals and sends the GetStage API request.
func (r GetStageRequest) Send(ctx context.Context) (*UpdateStageOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateStageOutput), nil
}

// GetStageRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets information about a Stage resource.
//
//    // Example sending a request using the GetStageRequest method.
//    req := client.GetStageRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetStageRequest(input *GetStageInput) GetStageRequest {
	op := &aws.Operation{
		Name:       opGetStage,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/stages/{stage_name}",
	}

	if input == nil {
		input = &GetStageInput{}
	}

	output := &UpdateStageOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetStageRequest{Request: req, Input: input, Copy: c.GetStageRequest}
}

const opGetStages = "GetStages"

// GetStagesRequest is a API request type for the GetStages API operation.
type GetStagesRequest struct {
	*aws.Request
	Input *GetStagesInput
	Copy  func(*GetStagesInput) GetStagesRequest
}

// Send marshals and sends the GetStages API request.
func (r GetStagesRequest) Send(ctx context.Context) (*GetStagesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetStagesOutput), nil
}

// GetStagesRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets information about one or more Stage resources.
//
//    // Example sending a request using the GetStagesRequest method.
//    req := client.GetStagesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetStagesRequest(input *GetStagesInput) GetStagesRequest {
	op := &aws.Operation{
		Name:       opGetStages,
		HTTPMethod: "GET",
		HTTPPath:   "/restapis/{restapi_id}/stages",
	}

	if input == nil {
		input = &GetStagesInput{}
	}

	output := &GetStagesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetStagesRequest{Request: req, Input: input, Copy: c.GetStagesRequest}
}

const opGetTags = "GetTags"

// GetTagsRequest is a API request type for the GetTags API operation.
type GetTagsRequest struct {
	*aws.Request
	Input *GetTagsInput
	Copy  func(*GetTagsInput) GetTagsRequest
}

// Send marshals and sends the GetTags API request.
func (r GetTagsRequest) Send(ctx context.Context) (*GetTagsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTagsOutput), nil
}

// GetTagsRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets the Tags collection for a given resource.
//
//    // Example sending a request using the GetTagsRequest method.
//    req := client.GetTagsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetTagsRequest(input *GetTagsInput) GetTagsRequest {
	op := &aws.Operation{
		Name:       opGetTags,
		HTTPMethod: "GET",
		HTTPPath:   "/tags/{resource_arn}",
	}

	if input == nil {
		input = &GetTagsInput{}
	}

	output := &GetTagsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTagsRequest{Request: req, Input: input, Copy: c.GetTagsRequest}
}

const opGetUsage = "GetUsage"

// GetUsageRequest is a API request type for the GetUsage API operation.
type GetUsageRequest struct {
	*aws.Request
	Input *GetUsageInput
	Copy  func(*GetUsageInput) GetUsageRequest
}

// Send marshals and sends the GetUsage API request.
func (r GetUsageRequest) Send(ctx context.Context) (*UpdateUsageOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateUsageOutput), nil
}

// GetUsageRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets the usage data of a usage plan in a specified time interval.
//
//    // Example sending a request using the GetUsageRequest method.
//    req := client.GetUsageRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetUsageRequest(input *GetUsageInput) GetUsageRequest {
	op := &aws.Operation{
		Name:       opGetUsage,
		HTTPMethod: "GET",
		HTTPPath:   "/usageplans/{usageplanId}/usage",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetUsageInput{}
	}

	output := &UpdateUsageOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetUsageRequest{Request: req, Input: input, Copy: c.GetUsageRequest}
}

// Paginate pages iterates over the pages of a GetUsageRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetUsage operation.
//		req := client.GetUsageRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetUsageRequest) Paginate(opts ...aws.Option) GetUsagePager {
	return GetUsagePager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetUsageInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetUsagePager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetUsagePager struct {
	aws.Pager
}

func (p *GetUsagePager) CurrentPage() *UpdateUsageOutput {
	return p.Pager.CurrentPage().(*UpdateUsageOutput)
}

const opGetUsagePlan = "GetUsagePlan"

// GetUsagePlanRequest is a API request type for the GetUsagePlan API operation.
type GetUsagePlanRequest struct {
	*aws.Request
	Input *GetUsagePlanInput
	Copy  func(*GetUsagePlanInput) GetUsagePlanRequest
}

// Send marshals and sends the GetUsagePlan API request.
func (r GetUsagePlanRequest) Send(ctx context.Context) (*UpdateUsagePlanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateUsagePlanOutput), nil
}

// GetUsagePlanRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets a usage plan of a given plan identifier.
//
//    // Example sending a request using the GetUsagePlanRequest method.
//    req := client.GetUsagePlanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetUsagePlanRequest(input *GetUsagePlanInput) GetUsagePlanRequest {
	op := &aws.Operation{
		Name:       opGetUsagePlan,
		HTTPMethod: "GET",
		HTTPPath:   "/usageplans/{usageplanId}",
	}

	if input == nil {
		input = &GetUsagePlanInput{}
	}

	output := &UpdateUsagePlanOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetUsagePlanRequest{Request: req, Input: input, Copy: c.GetUsagePlanRequest}
}

const opGetUsagePlanKey = "GetUsagePlanKey"

// GetUsagePlanKeyRequest is a API request type for the GetUsagePlanKey API operation.
type GetUsagePlanKeyRequest struct {
	*aws.Request
	Input *GetUsagePlanKeyInput
	Copy  func(*GetUsagePlanKeyInput) GetUsagePlanKeyRequest
}

// Send marshals and sends the GetUsagePlanKey API request.
func (r GetUsagePlanKeyRequest) Send(ctx context.Context) (*GetUsagePlanKeyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetUsagePlanKeyOutput), nil
}

// GetUsagePlanKeyRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets a usage plan key of a given key identifier.
//
//    // Example sending a request using the GetUsagePlanKeyRequest method.
//    req := client.GetUsagePlanKeyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetUsagePlanKeyRequest(input *GetUsagePlanKeyInput) GetUsagePlanKeyRequest {
	op := &aws.Operation{
		Name:       opGetUsagePlanKey,
		HTTPMethod: "GET",
		HTTPPath:   "/usageplans/{usageplanId}/keys/{keyId}",
	}

	if input == nil {
		input = &GetUsagePlanKeyInput{}
	}

	output := &GetUsagePlanKeyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetUsagePlanKeyRequest{Request: req, Input: input, Copy: c.GetUsagePlanKeyRequest}
}

const opGetUsagePlanKeys = "GetUsagePlanKeys"

// GetUsagePlanKeysRequest is a API request type for the GetUsagePlanKeys API operation.
type GetUsagePlanKeysRequest struct {
	*aws.Request
	Input *GetUsagePlanKeysInput
	Copy  func(*GetUsagePlanKeysInput) GetUsagePlanKeysRequest
}

// Send marshals and sends the GetUsagePlanKeys API request.
func (r GetUsagePlanKeysRequest) Send(ctx context.Context) (*GetUsagePlanKeysOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetUsagePlanKeysOutput), nil
}

// GetUsagePlanKeysRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets all the usage plan keys representing the API keys added to a specified
// usage plan.
//
//    // Example sending a request using the GetUsagePlanKeysRequest method.
//    req := client.GetUsagePlanKeysRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetUsagePlanKeysRequest(input *GetUsagePlanKeysInput) GetUsagePlanKeysRequest {
	op := &aws.Operation{
		Name:       opGetUsagePlanKeys,
		HTTPMethod: "GET",
		HTTPPath:   "/usageplans/{usageplanId}/keys",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetUsagePlanKeysInput{}
	}

	output := &GetUsagePlanKeysOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetUsagePlanKeysRequest{Request: req, Input: input, Copy: c.GetUsagePlanKeysRequest}
}

// Paginate pages iterates over the pages of a GetUsagePlanKeysRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetUsagePlanKeys operation.
//		req := client.GetUsagePlanKeysRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetUsagePlanKeysRequest) Paginate(opts ...aws.Option) GetUsagePlanKeysPager {
	return GetUsagePlanKeysPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetUsagePlanKeysInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetUsagePlanKeysPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetUsagePlanKeysPager struct {
	aws.Pager
}

func (p *GetUsagePlanKeysPager) CurrentPage() *GetUsagePlanKeysOutput {
	return p.Pager.CurrentPage().(*GetUsagePlanKeysOutput)
}

const opGetUsagePlans = "GetUsagePlans"

// GetUsagePlansRequest is a API request type for the GetUsagePlans API operation.
type GetUsagePlansRequest struct {
	*aws.Request
	Input *GetUsagePlansInput
	Copy  func(*GetUsagePlansInput) GetUsagePlansRequest
}

// Send marshals and sends the GetUsagePlans API request.
func (r GetUsagePlansRequest) Send(ctx context.Context) (*GetUsagePlansOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetUsagePlansOutput), nil
}

// GetUsagePlansRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets all the usage plans of the caller's account.
//
//    // Example sending a request using the GetUsagePlansRequest method.
//    req := client.GetUsagePlansRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetUsagePlansRequest(input *GetUsagePlansInput) GetUsagePlansRequest {
	op := &aws.Operation{
		Name:       opGetUsagePlans,
		HTTPMethod: "GET",
		HTTPPath:   "/usageplans",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetUsagePlansInput{}
	}

	output := &GetUsagePlansOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetUsagePlansRequest{Request: req, Input: input, Copy: c.GetUsagePlansRequest}
}

// Paginate pages iterates over the pages of a GetUsagePlansRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetUsagePlans operation.
//		req := client.GetUsagePlansRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetUsagePlansRequest) Paginate(opts ...aws.Option) GetUsagePlansPager {
	return GetUsagePlansPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetUsagePlansInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetUsagePlansPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetUsagePlansPager struct {
	aws.Pager
}

func (p *GetUsagePlansPager) CurrentPage() *GetUsagePlansOutput {
	return p.Pager.CurrentPage().(*GetUsagePlansOutput)
}

const opGetVpcLink = "GetVpcLink"

// GetVpcLinkRequest is a API request type for the GetVpcLink API operation.
type GetVpcLinkRequest struct {
	*aws.Request
	Input *GetVpcLinkInput
	Copy  func(*GetVpcLinkInput) GetVpcLinkRequest
}

// Send marshals and sends the GetVpcLink API request.
func (r GetVpcLinkRequest) Send(ctx context.Context) (*UpdateVpcLinkOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateVpcLinkOutput), nil
}

// GetVpcLinkRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets a specified VPC link under the caller's account in a region.
//
//    // Example sending a request using the GetVpcLinkRequest method.
//    req := client.GetVpcLinkRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetVpcLinkRequest(input *GetVpcLinkInput) GetVpcLinkRequest {
	op := &aws.Operation{
		Name:       opGetVpcLink,
		HTTPMethod: "GET",
		HTTPPath:   "/vpclinks/{vpclink_id}",
	}

	if input == nil {
		input = &GetVpcLinkInput{}
	}

	output := &UpdateVpcLinkOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetVpcLinkRequest{Request: req, Input: input, Copy: c.GetVpcLinkRequest}
}

const opGetVpcLinks = "GetVpcLinks"

// GetVpcLinksRequest is a API request type for the GetVpcLinks API operation.
type GetVpcLinksRequest struct {
	*aws.Request
	Input *GetVpcLinksInput
	Copy  func(*GetVpcLinksInput) GetVpcLinksRequest
}

// Send marshals and sends the GetVpcLinks API request.
func (r GetVpcLinksRequest) Send(ctx context.Context) (*GetVpcLinksOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetVpcLinksOutput), nil
}

// GetVpcLinksRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Gets the VpcLinks collection under the caller's account in a selected region.
//
//    // Example sending a request using the GetVpcLinksRequest method.
//    req := client.GetVpcLinksRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) GetVpcLinksRequest(input *GetVpcLinksInput) GetVpcLinksRequest {
	op := &aws.Operation{
		Name:       opGetVpcLinks,
		HTTPMethod: "GET",
		HTTPPath:   "/vpclinks",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"position"},
			OutputTokens:    []string{"position"},
			LimitToken:      "limit",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetVpcLinksInput{}
	}

	output := &GetVpcLinksOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetVpcLinksRequest{Request: req, Input: input, Copy: c.GetVpcLinksRequest}
}

// Paginate pages iterates over the pages of a GetVpcLinksRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetVpcLinks operation.
//		req := client.GetVpcLinksRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *GetVpcLinksRequest) Paginate(opts ...aws.Option) GetVpcLinksPager {
	return GetVpcLinksPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *GetVpcLinksInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// GetVpcLinksPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type GetVpcLinksPager struct {
	aws.Pager
}

func (p *GetVpcLinksPager) CurrentPage() *GetVpcLinksOutput {
	return p.Pager.CurrentPage().(*GetVpcLinksOutput)
}

const opImportApiKeys = "ImportApiKeys"

// ImportApiKeysRequest is a API request type for the ImportApiKeys API operation.
type ImportApiKeysRequest struct {
	*aws.Request
	Input *ImportApiKeysInput
	Copy  func(*ImportApiKeysInput) ImportApiKeysRequest
}

// Send marshals and sends the ImportApiKeys API request.
func (r ImportApiKeysRequest) Send(ctx context.Context) (*ImportApiKeysOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ImportApiKeysOutput), nil
}

// ImportApiKeysRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Import API keys from an external source, such as a CSV-formatted file.
//
//    // Example sending a request using the ImportApiKeysRequest method.
//    req := client.ImportApiKeysRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) ImportApiKeysRequest(input *ImportApiKeysInput) ImportApiKeysRequest {
	op := &aws.Operation{
		Name:       opImportApiKeys,
		HTTPMethod: "POST",
		HTTPPath:   "/apikeys?mode=import",
	}

	if input == nil {
		input = &ImportApiKeysInput{}
	}

	output := &ImportApiKeysOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ImportApiKeysRequest{Request: req, Input: input, Copy: c.ImportApiKeysRequest}
}

const opImportDocumentationParts = "ImportDocumentationParts"

// ImportDocumentationPartsRequest is a API request type for the ImportDocumentationParts API operation.
type ImportDocumentationPartsRequest struct {
	*aws.Request
	Input *ImportDocumentationPartsInput
	Copy  func(*ImportDocumentationPartsInput) ImportDocumentationPartsRequest
}

// Send marshals and sends the ImportDocumentationParts API request.
func (r ImportDocumentationPartsRequest) Send(ctx context.Context) (*ImportDocumentationPartsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ImportDocumentationPartsOutput), nil
}

// ImportDocumentationPartsRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the ImportDocumentationPartsRequest method.
//    req := client.ImportDocumentationPartsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) ImportDocumentationPartsRequest(input *ImportDocumentationPartsInput) ImportDocumentationPartsRequest {
	op := &aws.Operation{
		Name:       opImportDocumentationParts,
		HTTPMethod: "PUT",
		HTTPPath:   "/restapis/{restapi_id}/documentation/parts",
	}

	if input == nil {
		input = &ImportDocumentationPartsInput{}
	}

	output := &ImportDocumentationPartsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ImportDocumentationPartsRequest{Request: req, Input: input, Copy: c.ImportDocumentationPartsRequest}
}

const opImportRestApi = "ImportRestApi"

// ImportRestApiRequest is a API request type for the ImportRestApi API operation.
type ImportRestApiRequest struct {
	*aws.Request
	Input *ImportRestApiInput
	Copy  func(*ImportRestApiInput) ImportRestApiRequest
}

// Send marshals and sends the ImportRestApi API request.
func (r ImportRestApiRequest) Send(ctx context.Context) (*UpdateRestApiOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRestApiOutput), nil
}

// ImportRestApiRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// A feature of the API Gateway control service for creating a new API from
// an external API definition file.
//
//    // Example sending a request using the ImportRestApiRequest method.
//    req := client.ImportRestApiRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) ImportRestApiRequest(input *ImportRestApiInput) ImportRestApiRequest {
	op := &aws.Operation{
		Name:       opImportRestApi,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis?mode=import",
	}

	if input == nil {
		input = &ImportRestApiInput{}
	}

	output := &UpdateRestApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ImportRestApiRequest{Request: req, Input: input, Copy: c.ImportRestApiRequest}
}

const opPutGatewayResponse = "PutGatewayResponse"

// PutGatewayResponseRequest is a API request type for the PutGatewayResponse API operation.
type PutGatewayResponseRequest struct {
	*aws.Request
	Input *PutGatewayResponseInput
	Copy  func(*PutGatewayResponseInput) PutGatewayResponseRequest
}

// Send marshals and sends the PutGatewayResponse API request.
func (r PutGatewayResponseRequest) Send(ctx context.Context) (*UpdateGatewayResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGatewayResponseOutput), nil
}

// PutGatewayResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Creates a customization of a GatewayResponse of a specified response type
// and status code on the given RestApi.
//
//    // Example sending a request using the PutGatewayResponseRequest method.
//    req := client.PutGatewayResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) PutGatewayResponseRequest(input *PutGatewayResponseInput) PutGatewayResponseRequest {
	op := &aws.Operation{
		Name:       opPutGatewayResponse,
		HTTPMethod: "PUT",
		HTTPPath:   "/restapis/{restapi_id}/gatewayresponses/{response_type}",
	}

	if input == nil {
		input = &PutGatewayResponseInput{}
	}

	output := &UpdateGatewayResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutGatewayResponseRequest{Request: req, Input: input, Copy: c.PutGatewayResponseRequest}
}

const opPutIntegration = "PutIntegration"

// PutIntegrationRequest is a API request type for the PutIntegration API operation.
type PutIntegrationRequest struct {
	*aws.Request
	Input *PutIntegrationInput
	Copy  func(*PutIntegrationInput) PutIntegrationRequest
}

// Send marshals and sends the PutIntegration API request.
func (r PutIntegrationRequest) Send(ctx context.Context) (*UpdateIntegrationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateIntegrationOutput), nil
}

// PutIntegrationRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Sets up a method's integration.
//
//    // Example sending a request using the PutIntegrationRequest method.
//    req := client.PutIntegrationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) PutIntegrationRequest(input *PutIntegrationInput) PutIntegrationRequest {
	op := &aws.Operation{
		Name:       opPutIntegration,
		HTTPMethod: "PUT",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration",
	}

	if input == nil {
		input = &PutIntegrationInput{}
	}

	output := &UpdateIntegrationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutIntegrationRequest{Request: req, Input: input, Copy: c.PutIntegrationRequest}
}

const opPutIntegrationResponse = "PutIntegrationResponse"

// PutIntegrationResponseRequest is a API request type for the PutIntegrationResponse API operation.
type PutIntegrationResponseRequest struct {
	*aws.Request
	Input *PutIntegrationResponseInput
	Copy  func(*PutIntegrationResponseInput) PutIntegrationResponseRequest
}

// Send marshals and sends the PutIntegrationResponse API request.
func (r PutIntegrationResponseRequest) Send(ctx context.Context) (*UpdateIntegrationResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateIntegrationResponseOutput), nil
}

// PutIntegrationResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents a put integration.
//
//    // Example sending a request using the PutIntegrationResponseRequest method.
//    req := client.PutIntegrationResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) PutIntegrationResponseRequest(input *PutIntegrationResponseInput) PutIntegrationResponseRequest {
	op := &aws.Operation{
		Name:       opPutIntegrationResponse,
		HTTPMethod: "PUT",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}",
	}

	if input == nil {
		input = &PutIntegrationResponseInput{}
	}

	output := &UpdateIntegrationResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutIntegrationResponseRequest{Request: req, Input: input, Copy: c.PutIntegrationResponseRequest}
}

const opPutMethod = "PutMethod"

// PutMethodRequest is a API request type for the PutMethod API operation.
type PutMethodRequest struct {
	*aws.Request
	Input *PutMethodInput
	Copy  func(*PutMethodInput) PutMethodRequest
}

// Send marshals and sends the PutMethod API request.
func (r PutMethodRequest) Send(ctx context.Context) (*UpdateMethodOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateMethodOutput), nil
}

// PutMethodRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Add a method to an existing Resource resource.
//
//    // Example sending a request using the PutMethodRequest method.
//    req := client.PutMethodRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) PutMethodRequest(input *PutMethodInput) PutMethodRequest {
	op := &aws.Operation{
		Name:       opPutMethod,
		HTTPMethod: "PUT",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
	}

	if input == nil {
		input = &PutMethodInput{}
	}

	output := &UpdateMethodOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutMethodRequest{Request: req, Input: input, Copy: c.PutMethodRequest}
}

const opPutMethodResponse = "PutMethodResponse"

// PutMethodResponseRequest is a API request type for the PutMethodResponse API operation.
type PutMethodResponseRequest struct {
	*aws.Request
	Input *PutMethodResponseInput
	Copy  func(*PutMethodResponseInput) PutMethodResponseRequest
}

// Send marshals and sends the PutMethodResponse API request.
func (r PutMethodResponseRequest) Send(ctx context.Context) (*UpdateMethodResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateMethodResponseOutput), nil
}

// PutMethodResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Adds a MethodResponse to an existing Method resource.
//
//    // Example sending a request using the PutMethodResponseRequest method.
//    req := client.PutMethodResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) PutMethodResponseRequest(input *PutMethodResponseInput) PutMethodResponseRequest {
	op := &aws.Operation{
		Name:       opPutMethodResponse,
		HTTPMethod: "PUT",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
	}

	if input == nil {
		input = &PutMethodResponseInput{}
	}

	output := &UpdateMethodResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutMethodResponseRequest{Request: req, Input: input, Copy: c.PutMethodResponseRequest}
}

const opPutRestApi = "PutRestApi"

// PutRestApiRequest is a API request type for the PutRestApi API operation.
type PutRestApiRequest struct {
	*aws.Request
	Input *PutRestApiInput
	Copy  func(*PutRestApiInput) PutRestApiRequest
}

// Send marshals and sends the PutRestApi API request.
func (r PutRestApiRequest) Send(ctx context.Context) (*UpdateRestApiOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRestApiOutput), nil
}

// PutRestApiRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// A feature of the API Gateway control service for updating an existing API
// with an input of external API definitions. The update can take the form of
// merging the supplied definition into the existing API or overwriting the
// existing API.
//
//    // Example sending a request using the PutRestApiRequest method.
//    req := client.PutRestApiRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) PutRestApiRequest(input *PutRestApiInput) PutRestApiRequest {
	op := &aws.Operation{
		Name:       opPutRestApi,
		HTTPMethod: "PUT",
		HTTPPath:   "/restapis/{restapi_id}",
	}

	if input == nil {
		input = &PutRestApiInput{}
	}

	output := &UpdateRestApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return PutRestApiRequest{Request: req, Input: input, Copy: c.PutRestApiRequest}
}

const opTagResource = "TagResource"

// TagResourceRequest is a API request type for the TagResource API operation.
type TagResourceRequest struct {
	*aws.Request
	Input *TagResourceInput
	Copy  func(*TagResourceInput) TagResourceRequest
}

// Send marshals and sends the TagResource API request.
func (r TagResourceRequest) Send(ctx context.Context) (*TagResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TagResourceOutput), nil
}

// TagResourceRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Adds or updates a tag on a given resource.
//
//    // Example sending a request using the TagResourceRequest method.
//    req := client.TagResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) TagResourceRequest(input *TagResourceInput) TagResourceRequest {
	op := &aws.Operation{
		Name:       opTagResource,
		HTTPMethod: "PUT",
		HTTPPath:   "/tags/{resource_arn}",
	}

	if input == nil {
		input = &TagResourceInput{}
	}

	output := &TagResourceOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return TagResourceRequest{Request: req, Input: input, Copy: c.TagResourceRequest}
}

const opTestInvokeAuthorizer = "TestInvokeAuthorizer"

// TestInvokeAuthorizerRequest is a API request type for the TestInvokeAuthorizer API operation.
type TestInvokeAuthorizerRequest struct {
	*aws.Request
	Input *TestInvokeAuthorizerInput
	Copy  func(*TestInvokeAuthorizerInput) TestInvokeAuthorizerRequest
}

// Send marshals and sends the TestInvokeAuthorizer API request.
func (r TestInvokeAuthorizerRequest) Send(ctx context.Context) (*TestInvokeAuthorizerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TestInvokeAuthorizerOutput), nil
}

// TestInvokeAuthorizerRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Simulate the execution of an Authorizer in your RestApi with headers, parameters,
// and an incoming request body.
//
// Enable custom authorizers (https://docs.aws.amazon.com/apigateway/latest/developerguide/use-custom-authorizer.html)
//
//    // Example sending a request using the TestInvokeAuthorizerRequest method.
//    req := client.TestInvokeAuthorizerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) TestInvokeAuthorizerRequest(input *TestInvokeAuthorizerInput) TestInvokeAuthorizerRequest {
	op := &aws.Operation{
		Name:       opTestInvokeAuthorizer,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/authorizers/{authorizer_id}",
	}

	if input == nil {
		input = &TestInvokeAuthorizerInput{}
	}

	output := &TestInvokeAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TestInvokeAuthorizerRequest{Request: req, Input: input, Copy: c.TestInvokeAuthorizerRequest}
}

const opTestInvokeMethod = "TestInvokeMethod"

// TestInvokeMethodRequest is a API request type for the TestInvokeMethod API operation.
type TestInvokeMethodRequest struct {
	*aws.Request
	Input *TestInvokeMethodInput
	Copy  func(*TestInvokeMethodInput) TestInvokeMethodRequest
}

// Send marshals and sends the TestInvokeMethod API request.
func (r TestInvokeMethodRequest) Send(ctx context.Context) (*TestInvokeMethodOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TestInvokeMethodOutput), nil
}

// TestInvokeMethodRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Simulate the execution of a Method in your RestApi with headers, parameters,
// and an incoming request body.
//
//    // Example sending a request using the TestInvokeMethodRequest method.
//    req := client.TestInvokeMethodRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) TestInvokeMethodRequest(input *TestInvokeMethodInput) TestInvokeMethodRequest {
	op := &aws.Operation{
		Name:       opTestInvokeMethod,
		HTTPMethod: "POST",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
	}

	if input == nil {
		input = &TestInvokeMethodInput{}
	}

	output := &TestInvokeMethodOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TestInvokeMethodRequest{Request: req, Input: input, Copy: c.TestInvokeMethodRequest}
}

const opUntagResource = "UntagResource"

// UntagResourceRequest is a API request type for the UntagResource API operation.
type UntagResourceRequest struct {
	*aws.Request
	Input *UntagResourceInput
	Copy  func(*UntagResourceInput) UntagResourceRequest
}

// Send marshals and sends the UntagResource API request.
func (r UntagResourceRequest) Send(ctx context.Context) (*UntagResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UntagResourceOutput), nil
}

// UntagResourceRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Removes a tag from a given resource.
//
//    // Example sending a request using the UntagResourceRequest method.
//    req := client.UntagResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UntagResourceRequest(input *UntagResourceInput) UntagResourceRequest {
	op := &aws.Operation{
		Name:       opUntagResource,
		HTTPMethod: "DELETE",
		HTTPPath:   "/tags/{resource_arn}",
	}

	if input == nil {
		input = &UntagResourceInput{}
	}

	output := &UntagResourceOutput{}
	req := c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Remove(restjson.UnmarshalHandler)
	req.Handlers.Unmarshal.PushBackNamed(protocol.UnmarshalDiscardBodyHandler)
	output.responseMetadata = aws.Response{Request: req}

	return UntagResourceRequest{Request: req, Input: input, Copy: c.UntagResourceRequest}
}

const opUpdateAccount = "UpdateAccount"

// UpdateAccountRequest is a API request type for the UpdateAccount API operation.
type UpdateAccountRequest struct {
	*aws.Request
	Input *UpdateAccountInput
	Copy  func(*UpdateAccountInput) UpdateAccountRequest
}

// Send marshals and sends the UpdateAccount API request.
func (r UpdateAccountRequest) Send(ctx context.Context) (*UpdateAccountOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateAccountOutput), nil
}

// UpdateAccountRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about the current Account resource.
//
//    // Example sending a request using the UpdateAccountRequest method.
//    req := client.UpdateAccountRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateAccountRequest(input *UpdateAccountInput) UpdateAccountRequest {
	op := &aws.Operation{
		Name:       opUpdateAccount,
		HTTPMethod: "PATCH",
		HTTPPath:   "/account",
	}

	if input == nil {
		input = &UpdateAccountInput{}
	}

	output := &UpdateAccountOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateAccountRequest{Request: req, Input: input, Copy: c.UpdateAccountRequest}
}

const opUpdateApiKey = "UpdateApiKey"

// UpdateApiKeyRequest is a API request type for the UpdateApiKey API operation.
type UpdateApiKeyRequest struct {
	*aws.Request
	Input *UpdateApiKeyInput
	Copy  func(*UpdateApiKeyInput) UpdateApiKeyRequest
}

// Send marshals and sends the UpdateApiKey API request.
func (r UpdateApiKeyRequest) Send(ctx context.Context) (*UpdateApiKeyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateApiKeyOutput), nil
}

// UpdateApiKeyRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about an ApiKey resource.
//
//    // Example sending a request using the UpdateApiKeyRequest method.
//    req := client.UpdateApiKeyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateApiKeyRequest(input *UpdateApiKeyInput) UpdateApiKeyRequest {
	op := &aws.Operation{
		Name:       opUpdateApiKey,
		HTTPMethod: "PATCH",
		HTTPPath:   "/apikeys/{api_Key}",
	}

	if input == nil {
		input = &UpdateApiKeyInput{}
	}

	output := &UpdateApiKeyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateApiKeyRequest{Request: req, Input: input, Copy: c.UpdateApiKeyRequest}
}

const opUpdateAuthorizer = "UpdateAuthorizer"

// UpdateAuthorizerRequest is a API request type for the UpdateAuthorizer API operation.
type UpdateAuthorizerRequest struct {
	*aws.Request
	Input *UpdateAuthorizerInput
	Copy  func(*UpdateAuthorizerInput) UpdateAuthorizerRequest
}

// Send marshals and sends the UpdateAuthorizer API request.
func (r UpdateAuthorizerRequest) Send(ctx context.Context) (*UpdateAuthorizerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateAuthorizerOutput), nil
}

// UpdateAuthorizerRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Updates an existing Authorizer resource.
//
// AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/update-authorizer.html)
//
//    // Example sending a request using the UpdateAuthorizerRequest method.
//    req := client.UpdateAuthorizerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateAuthorizerRequest(input *UpdateAuthorizerInput) UpdateAuthorizerRequest {
	op := &aws.Operation{
		Name:       opUpdateAuthorizer,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/authorizers/{authorizer_id}",
	}

	if input == nil {
		input = &UpdateAuthorizerInput{}
	}

	output := &UpdateAuthorizerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateAuthorizerRequest{Request: req, Input: input, Copy: c.UpdateAuthorizerRequest}
}

const opUpdateBasePathMapping = "UpdateBasePathMapping"

// UpdateBasePathMappingRequest is a API request type for the UpdateBasePathMapping API operation.
type UpdateBasePathMappingRequest struct {
	*aws.Request
	Input *UpdateBasePathMappingInput
	Copy  func(*UpdateBasePathMappingInput) UpdateBasePathMappingRequest
}

// Send marshals and sends the UpdateBasePathMapping API request.
func (r UpdateBasePathMappingRequest) Send(ctx context.Context) (*UpdateBasePathMappingOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateBasePathMappingOutput), nil
}

// UpdateBasePathMappingRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about the BasePathMapping resource.
//
//    // Example sending a request using the UpdateBasePathMappingRequest method.
//    req := client.UpdateBasePathMappingRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateBasePathMappingRequest(input *UpdateBasePathMappingInput) UpdateBasePathMappingRequest {
	op := &aws.Operation{
		Name:       opUpdateBasePathMapping,
		HTTPMethod: "PATCH",
		HTTPPath:   "/domainnames/{domain_name}/basepathmappings/{base_path}",
	}

	if input == nil {
		input = &UpdateBasePathMappingInput{}
	}

	output := &UpdateBasePathMappingOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateBasePathMappingRequest{Request: req, Input: input, Copy: c.UpdateBasePathMappingRequest}
}

const opUpdateClientCertificate = "UpdateClientCertificate"

// UpdateClientCertificateRequest is a API request type for the UpdateClientCertificate API operation.
type UpdateClientCertificateRequest struct {
	*aws.Request
	Input *UpdateClientCertificateInput
	Copy  func(*UpdateClientCertificateInput) UpdateClientCertificateRequest
}

// Send marshals and sends the UpdateClientCertificate API request.
func (r UpdateClientCertificateRequest) Send(ctx context.Context) (*UpdateClientCertificateOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateClientCertificateOutput), nil
}

// UpdateClientCertificateRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about an ClientCertificate resource.
//
//    // Example sending a request using the UpdateClientCertificateRequest method.
//    req := client.UpdateClientCertificateRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateClientCertificateRequest(input *UpdateClientCertificateInput) UpdateClientCertificateRequest {
	op := &aws.Operation{
		Name:       opUpdateClientCertificate,
		HTTPMethod: "PATCH",
		HTTPPath:   "/clientcertificates/{clientcertificate_id}",
	}

	if input == nil {
		input = &UpdateClientCertificateInput{}
	}

	output := &UpdateClientCertificateOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateClientCertificateRequest{Request: req, Input: input, Copy: c.UpdateClientCertificateRequest}
}

const opUpdateDeployment = "UpdateDeployment"

// UpdateDeploymentRequest is a API request type for the UpdateDeployment API operation.
type UpdateDeploymentRequest struct {
	*aws.Request
	Input *UpdateDeploymentInput
	Copy  func(*UpdateDeploymentInput) UpdateDeploymentRequest
}

// Send marshals and sends the UpdateDeployment API request.
func (r UpdateDeploymentRequest) Send(ctx context.Context) (*UpdateDeploymentOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDeploymentOutput), nil
}

// UpdateDeploymentRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about a Deployment resource.
//
//    // Example sending a request using the UpdateDeploymentRequest method.
//    req := client.UpdateDeploymentRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateDeploymentRequest(input *UpdateDeploymentInput) UpdateDeploymentRequest {
	op := &aws.Operation{
		Name:       opUpdateDeployment,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/deployments/{deployment_id}",
	}

	if input == nil {
		input = &UpdateDeploymentInput{}
	}

	output := &UpdateDeploymentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateDeploymentRequest{Request: req, Input: input, Copy: c.UpdateDeploymentRequest}
}

const opUpdateDocumentationPart = "UpdateDocumentationPart"

// UpdateDocumentationPartRequest is a API request type for the UpdateDocumentationPart API operation.
type UpdateDocumentationPartRequest struct {
	*aws.Request
	Input *UpdateDocumentationPartInput
	Copy  func(*UpdateDocumentationPartInput) UpdateDocumentationPartRequest
}

// Send marshals and sends the UpdateDocumentationPart API request.
func (r UpdateDocumentationPartRequest) Send(ctx context.Context) (*UpdateDocumentationPartOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDocumentationPartOutput), nil
}

// UpdateDocumentationPartRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the UpdateDocumentationPartRequest method.
//    req := client.UpdateDocumentationPartRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateDocumentationPartRequest(input *UpdateDocumentationPartInput) UpdateDocumentationPartRequest {
	op := &aws.Operation{
		Name:       opUpdateDocumentationPart,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/documentation/parts/{part_id}",
	}

	if input == nil {
		input = &UpdateDocumentationPartInput{}
	}

	output := &UpdateDocumentationPartOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateDocumentationPartRequest{Request: req, Input: input, Copy: c.UpdateDocumentationPartRequest}
}

const opUpdateDocumentationVersion = "UpdateDocumentationVersion"

// UpdateDocumentationVersionRequest is a API request type for the UpdateDocumentationVersion API operation.
type UpdateDocumentationVersionRequest struct {
	*aws.Request
	Input *UpdateDocumentationVersionInput
	Copy  func(*UpdateDocumentationVersionInput) UpdateDocumentationVersionRequest
}

// Send marshals and sends the UpdateDocumentationVersion API request.
func (r UpdateDocumentationVersionRequest) Send(ctx context.Context) (*UpdateDocumentationVersionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDocumentationVersionOutput), nil
}

// UpdateDocumentationVersionRequest returns a request value for making API operation for
// Amazon API Gateway.
//
//    // Example sending a request using the UpdateDocumentationVersionRequest method.
//    req := client.UpdateDocumentationVersionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateDocumentationVersionRequest(input *UpdateDocumentationVersionInput) UpdateDocumentationVersionRequest {
	op := &aws.Operation{
		Name:       opUpdateDocumentationVersion,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/documentation/versions/{doc_version}",
	}

	if input == nil {
		input = &UpdateDocumentationVersionInput{}
	}

	output := &UpdateDocumentationVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateDocumentationVersionRequest{Request: req, Input: input, Copy: c.UpdateDocumentationVersionRequest}
}

const opUpdateDomainName = "UpdateDomainName"

// UpdateDomainNameRequest is a API request type for the UpdateDomainName API operation.
type UpdateDomainNameRequest struct {
	*aws.Request
	Input *UpdateDomainNameInput
	Copy  func(*UpdateDomainNameInput) UpdateDomainNameRequest
}

// Send marshals and sends the UpdateDomainName API request.
func (r UpdateDomainNameRequest) Send(ctx context.Context) (*UpdateDomainNameOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateDomainNameOutput), nil
}

// UpdateDomainNameRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about the DomainName resource.
//
//    // Example sending a request using the UpdateDomainNameRequest method.
//    req := client.UpdateDomainNameRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateDomainNameRequest(input *UpdateDomainNameInput) UpdateDomainNameRequest {
	op := &aws.Operation{
		Name:       opUpdateDomainName,
		HTTPMethod: "PATCH",
		HTTPPath:   "/domainnames/{domain_name}",
	}

	if input == nil {
		input = &UpdateDomainNameInput{}
	}

	output := &UpdateDomainNameOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateDomainNameRequest{Request: req, Input: input, Copy: c.UpdateDomainNameRequest}
}

const opUpdateGatewayResponse = "UpdateGatewayResponse"

// UpdateGatewayResponseRequest is a API request type for the UpdateGatewayResponse API operation.
type UpdateGatewayResponseRequest struct {
	*aws.Request
	Input *UpdateGatewayResponseInput
	Copy  func(*UpdateGatewayResponseInput) UpdateGatewayResponseRequest
}

// Send marshals and sends the UpdateGatewayResponse API request.
func (r UpdateGatewayResponseRequest) Send(ctx context.Context) (*UpdateGatewayResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateGatewayResponseOutput), nil
}

// UpdateGatewayResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Updates a GatewayResponse of a specified response type on the given RestApi.
//
//    // Example sending a request using the UpdateGatewayResponseRequest method.
//    req := client.UpdateGatewayResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateGatewayResponseRequest(input *UpdateGatewayResponseInput) UpdateGatewayResponseRequest {
	op := &aws.Operation{
		Name:       opUpdateGatewayResponse,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/gatewayresponses/{response_type}",
	}

	if input == nil {
		input = &UpdateGatewayResponseInput{}
	}

	output := &UpdateGatewayResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateGatewayResponseRequest{Request: req, Input: input, Copy: c.UpdateGatewayResponseRequest}
}

const opUpdateIntegration = "UpdateIntegration"

// UpdateIntegrationRequest is a API request type for the UpdateIntegration API operation.
type UpdateIntegrationRequest struct {
	*aws.Request
	Input *UpdateIntegrationInput
	Copy  func(*UpdateIntegrationInput) UpdateIntegrationRequest
}

// Send marshals and sends the UpdateIntegration API request.
func (r UpdateIntegrationRequest) Send(ctx context.Context) (*UpdateIntegrationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateIntegrationOutput), nil
}

// UpdateIntegrationRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents an update integration.
//
//    // Example sending a request using the UpdateIntegrationRequest method.
//    req := client.UpdateIntegrationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateIntegrationRequest(input *UpdateIntegrationInput) UpdateIntegrationRequest {
	op := &aws.Operation{
		Name:       opUpdateIntegration,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration",
	}

	if input == nil {
		input = &UpdateIntegrationInput{}
	}

	output := &UpdateIntegrationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateIntegrationRequest{Request: req, Input: input, Copy: c.UpdateIntegrationRequest}
}

const opUpdateIntegrationResponse = "UpdateIntegrationResponse"

// UpdateIntegrationResponseRequest is a API request type for the UpdateIntegrationResponse API operation.
type UpdateIntegrationResponseRequest struct {
	*aws.Request
	Input *UpdateIntegrationResponseInput
	Copy  func(*UpdateIntegrationResponseInput) UpdateIntegrationResponseRequest
}

// Send marshals and sends the UpdateIntegrationResponse API request.
func (r UpdateIntegrationResponseRequest) Send(ctx context.Context) (*UpdateIntegrationResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateIntegrationResponseOutput), nil
}

// UpdateIntegrationResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Represents an update integration response.
//
//    // Example sending a request using the UpdateIntegrationResponseRequest method.
//    req := client.UpdateIntegrationResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateIntegrationResponseRequest(input *UpdateIntegrationResponseInput) UpdateIntegrationResponseRequest {
	op := &aws.Operation{
		Name:       opUpdateIntegrationResponse,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}",
	}

	if input == nil {
		input = &UpdateIntegrationResponseInput{}
	}

	output := &UpdateIntegrationResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateIntegrationResponseRequest{Request: req, Input: input, Copy: c.UpdateIntegrationResponseRequest}
}

const opUpdateMethod = "UpdateMethod"

// UpdateMethodRequest is a API request type for the UpdateMethod API operation.
type UpdateMethodRequest struct {
	*aws.Request
	Input *UpdateMethodInput
	Copy  func(*UpdateMethodInput) UpdateMethodRequest
}

// Send marshals and sends the UpdateMethod API request.
func (r UpdateMethodRequest) Send(ctx context.Context) (*UpdateMethodOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateMethodOutput), nil
}

// UpdateMethodRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Updates an existing Method resource.
//
//    // Example sending a request using the UpdateMethodRequest method.
//    req := client.UpdateMethodRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateMethodRequest(input *UpdateMethodInput) UpdateMethodRequest {
	op := &aws.Operation{
		Name:       opUpdateMethod,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}",
	}

	if input == nil {
		input = &UpdateMethodInput{}
	}

	output := &UpdateMethodOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateMethodRequest{Request: req, Input: input, Copy: c.UpdateMethodRequest}
}

const opUpdateMethodResponse = "UpdateMethodResponse"

// UpdateMethodResponseRequest is a API request type for the UpdateMethodResponse API operation.
type UpdateMethodResponseRequest struct {
	*aws.Request
	Input *UpdateMethodResponseInput
	Copy  func(*UpdateMethodResponseInput) UpdateMethodResponseRequest
}

// Send marshals and sends the UpdateMethodResponse API request.
func (r UpdateMethodResponseRequest) Send(ctx context.Context) (*UpdateMethodResponseOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateMethodResponseOutput), nil
}

// UpdateMethodResponseRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Updates an existing MethodResponse resource.
//
//    // Example sending a request using the UpdateMethodResponseRequest method.
//    req := client.UpdateMethodResponseRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateMethodResponseRequest(input *UpdateMethodResponseInput) UpdateMethodResponseRequest {
	op := &aws.Operation{
		Name:       opUpdateMethodResponse,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}",
	}

	if input == nil {
		input = &UpdateMethodResponseInput{}
	}

	output := &UpdateMethodResponseOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateMethodResponseRequest{Request: req, Input: input, Copy: c.UpdateMethodResponseRequest}
}

const opUpdateModel = "UpdateModel"

// UpdateModelRequest is a API request type for the UpdateModel API operation.
type UpdateModelRequest struct {
	*aws.Request
	Input *UpdateModelInput
	Copy  func(*UpdateModelInput) UpdateModelRequest
}

// Send marshals and sends the UpdateModel API request.
func (r UpdateModelRequest) Send(ctx context.Context) (*UpdateModelOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateModelOutput), nil
}

// UpdateModelRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about a model.
//
//    // Example sending a request using the UpdateModelRequest method.
//    req := client.UpdateModelRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateModelRequest(input *UpdateModelInput) UpdateModelRequest {
	op := &aws.Operation{
		Name:       opUpdateModel,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/models/{model_name}",
	}

	if input == nil {
		input = &UpdateModelInput{}
	}

	output := &UpdateModelOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateModelRequest{Request: req, Input: input, Copy: c.UpdateModelRequest}
}

const opUpdateRequestValidator = "UpdateRequestValidator"

// UpdateRequestValidatorRequest is a API request type for the UpdateRequestValidator API operation.
type UpdateRequestValidatorRequest struct {
	*aws.Request
	Input *UpdateRequestValidatorInput
	Copy  func(*UpdateRequestValidatorInput) UpdateRequestValidatorRequest
}

// Send marshals and sends the UpdateRequestValidator API request.
func (r UpdateRequestValidatorRequest) Send(ctx context.Context) (*UpdateRequestValidatorOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRequestValidatorOutput), nil
}

// UpdateRequestValidatorRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Updates a RequestValidator of a given RestApi.
//
//    // Example sending a request using the UpdateRequestValidatorRequest method.
//    req := client.UpdateRequestValidatorRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateRequestValidatorRequest(input *UpdateRequestValidatorInput) UpdateRequestValidatorRequest {
	op := &aws.Operation{
		Name:       opUpdateRequestValidator,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}",
	}

	if input == nil {
		input = &UpdateRequestValidatorInput{}
	}

	output := &UpdateRequestValidatorOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateRequestValidatorRequest{Request: req, Input: input, Copy: c.UpdateRequestValidatorRequest}
}

const opUpdateResource = "UpdateResource"

// UpdateResourceRequest is a API request type for the UpdateResource API operation.
type UpdateResourceRequest struct {
	*aws.Request
	Input *UpdateResourceInput
	Copy  func(*UpdateResourceInput) UpdateResourceRequest
}

// Send marshals and sends the UpdateResource API request.
func (r UpdateResourceRequest) Send(ctx context.Context) (*UpdateResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateResourceOutput), nil
}

// UpdateResourceRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about a Resource resource.
//
//    // Example sending a request using the UpdateResourceRequest method.
//    req := client.UpdateResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateResourceRequest(input *UpdateResourceInput) UpdateResourceRequest {
	op := &aws.Operation{
		Name:       opUpdateResource,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/resources/{resource_id}",
	}

	if input == nil {
		input = &UpdateResourceInput{}
	}

	output := &UpdateResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateResourceRequest{Request: req, Input: input, Copy: c.UpdateResourceRequest}
}

const opUpdateRestApi = "UpdateRestApi"

// UpdateRestApiRequest is a API request type for the UpdateRestApi API operation.
type UpdateRestApiRequest struct {
	*aws.Request
	Input *UpdateRestApiInput
	Copy  func(*UpdateRestApiInput) UpdateRestApiRequest
}

// Send marshals and sends the UpdateRestApi API request.
func (r UpdateRestApiRequest) Send(ctx context.Context) (*UpdateRestApiOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateRestApiOutput), nil
}

// UpdateRestApiRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about the specified API.
//
//    // Example sending a request using the UpdateRestApiRequest method.
//    req := client.UpdateRestApiRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateRestApiRequest(input *UpdateRestApiInput) UpdateRestApiRequest {
	op := &aws.Operation{
		Name:       opUpdateRestApi,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}",
	}

	if input == nil {
		input = &UpdateRestApiInput{}
	}

	output := &UpdateRestApiOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateRestApiRequest{Request: req, Input: input, Copy: c.UpdateRestApiRequest}
}

const opUpdateStage = "UpdateStage"

// UpdateStageRequest is a API request type for the UpdateStage API operation.
type UpdateStageRequest struct {
	*aws.Request
	Input *UpdateStageInput
	Copy  func(*UpdateStageInput) UpdateStageRequest
}

// Send marshals and sends the UpdateStage API request.
func (r UpdateStageRequest) Send(ctx context.Context) (*UpdateStageOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateStageOutput), nil
}

// UpdateStageRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Changes information about a Stage resource.
//
//    // Example sending a request using the UpdateStageRequest method.
//    req := client.UpdateStageRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateStageRequest(input *UpdateStageInput) UpdateStageRequest {
	op := &aws.Operation{
		Name:       opUpdateStage,
		HTTPMethod: "PATCH",
		HTTPPath:   "/restapis/{restapi_id}/stages/{stage_name}",
	}

	if input == nil {
		input = &UpdateStageInput{}
	}

	output := &UpdateStageOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateStageRequest{Request: req, Input: input, Copy: c.UpdateStageRequest}
}

const opUpdateUsage = "UpdateUsage"

// UpdateUsageRequest is a API request type for the UpdateUsage API operation.
type UpdateUsageRequest struct {
	*aws.Request
	Input *UpdateUsageInput
	Copy  func(*UpdateUsageInput) UpdateUsageRequest
}

// Send marshals and sends the UpdateUsage API request.
func (r UpdateUsageRequest) Send(ctx context.Context) (*UpdateUsageOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateUsageOutput), nil
}

// UpdateUsageRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Grants a temporary extension to the remaining quota of a usage plan associated
// with a specified API key.
//
//    // Example sending a request using the UpdateUsageRequest method.
//    req := client.UpdateUsageRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateUsageRequest(input *UpdateUsageInput) UpdateUsageRequest {
	op := &aws.Operation{
		Name:       opUpdateUsage,
		HTTPMethod: "PATCH",
		HTTPPath:   "/usageplans/{usageplanId}/keys/{keyId}/usage",
	}

	if input == nil {
		input = &UpdateUsageInput{}
	}

	output := &UpdateUsageOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateUsageRequest{Request: req, Input: input, Copy: c.UpdateUsageRequest}
}

const opUpdateUsagePlan = "UpdateUsagePlan"

// UpdateUsagePlanRequest is a API request type for the UpdateUsagePlan API operation.
type UpdateUsagePlanRequest struct {
	*aws.Request
	Input *UpdateUsagePlanInput
	Copy  func(*UpdateUsagePlanInput) UpdateUsagePlanRequest
}

// Send marshals and sends the UpdateUsagePlan API request.
func (r UpdateUsagePlanRequest) Send(ctx context.Context) (*UpdateUsagePlanOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateUsagePlanOutput), nil
}

// UpdateUsagePlanRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Updates a usage plan of a given plan Id.
//
//    // Example sending a request using the UpdateUsagePlanRequest method.
//    req := client.UpdateUsagePlanRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateUsagePlanRequest(input *UpdateUsagePlanInput) UpdateUsagePlanRequest {
	op := &aws.Operation{
		Name:       opUpdateUsagePlan,
		HTTPMethod: "PATCH",
		HTTPPath:   "/usageplans/{usageplanId}",
	}

	if input == nil {
		input = &UpdateUsagePlanInput{}
	}

	output := &UpdateUsagePlanOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateUsagePlanRequest{Request: req, Input: input, Copy: c.UpdateUsagePlanRequest}
}

const opUpdateVpcLink = "UpdateVpcLink"

// UpdateVpcLinkRequest is a API request type for the UpdateVpcLink API operation.
type UpdateVpcLinkRequest struct {
	*aws.Request
	Input *UpdateVpcLinkInput
	Copy  func(*UpdateVpcLinkInput) UpdateVpcLinkRequest
}

// Send marshals and sends the UpdateVpcLink API request.
func (r UpdateVpcLinkRequest) Send(ctx context.Context) (*UpdateVpcLinkOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateVpcLinkOutput), nil
}

// UpdateVpcLinkRequest returns a request value for making API operation for
// Amazon API Gateway.
//
// Updates an existing VpcLink of a specified identifier.
//
//    // Example sending a request using the UpdateVpcLinkRequest method.
//    req := client.UpdateVpcLinkRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
func (c *APIGateway) UpdateVpcLinkRequest(input *UpdateVpcLinkInput) UpdateVpcLinkRequest {
	op := &aws.Operation{
		Name:       opUpdateVpcLink,
		HTTPMethod: "PATCH",
		HTTPPath:   "/vpclinks/{vpclink_id}",
	}

	if input == nil {
		input = &UpdateVpcLinkInput{}
	}

	output := &UpdateVpcLinkOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateVpcLinkRequest{Request: req, Input: input, Copy: c.UpdateVpcLinkRequest}
}

// Access log settings, including the access log format and access log destination
// ARN.
type AccessLogSettings struct {
	_ struct{} `type:"structure"`

	// The ARN of the CloudWatch Logs log group to receive access logs.
	DestinationArn *string `locationName:"destinationArn" type:"string"`

	// A single line format of the access logs of data, as specified by selected
	// $context variables (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference).
	// The format must include at least $context.requestId.
	Format *string `locationName:"format" type:"string"`
}

// String returns the string representation
func (s AccessLogSettings) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AccessLogSettings) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AccessLogSettings) MarshalFields(e protocol.FieldEncoder) error {
	if s.DestinationArn != nil {
		v := *s.DestinationArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "destinationArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Format != nil {
		v := *s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "format", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// API stage name of the associated API stage in a usage plan.
type ApiStage struct {
	_ struct{} `type:"structure"`

	// API Id of the associated API stage in a usage plan.
	ApiId *string `locationName:"apiId" type:"string"`

	// API stage name of the associated API stage in a usage plan.
	Stage *string `locationName:"stage" type:"string"`

	// Map containing method level throttling information for API stage in a usage
	// plan.
	Throttle map[string]ThrottleSettings `locationName:"throttle" type:"map"`
}

// String returns the string representation
func (s ApiStage) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApiStage) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ApiStage) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApiId != nil {
		v := *s.ApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "apiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Stage != nil {
		v := *s.Stage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Throttle) > 0 {
		v := s.Throttle

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "throttle", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	return nil
}

// Configuration settings of a canary deployment.
type CanarySettings struct {
	_ struct{} `type:"structure"`

	// The ID of the canary deployment.
	DeploymentId *string `locationName:"deploymentId" type:"string"`

	// The percent (0-100) of traffic diverted to a canary deployment.
	PercentTraffic *float64 `locationName:"percentTraffic" type:"double"`

	// Stage variables overridden for a canary release deployment, including new
	// stage variables introduced in the canary. These stage variables are represented
	// as a string-to-string map between stage variable names and their values.
	StageVariableOverrides map[string]string `locationName:"stageVariableOverrides" type:"map"`

	// A Boolean flag to indicate whether the canary deployment uses the stage cache
	// or not.
	UseStageCache *bool `locationName:"useStageCache" type:"boolean"`
}

// String returns the string representation
func (s CanarySettings) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CanarySettings) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CanarySettings) MarshalFields(e protocol.FieldEncoder) error {
	if s.DeploymentId != nil {
		v := *s.DeploymentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deploymentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PercentTraffic != nil {
		v := *s.PercentTraffic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "percentTraffic", protocol.Float64Value(v), metadata)
	}
	if len(s.StageVariableOverrides) > 0 {
		v := s.StageVariableOverrides

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "stageVariableOverrides", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.UseStageCache != nil {
		v := *s.UseStageCache

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "useStageCache", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Request to create an ApiKey resource.
type CreateApiKeyInput struct {
	_ struct{} `type:"structure"`

	// An AWS Marketplace customer identifier , when integrating with the AWS SaaS
	// Marketplace.
	CustomerId *string `locationName:"customerId" type:"string"`

	// The description of the ApiKey.
	Description *string `locationName:"description" type:"string"`

	// Specifies whether the ApiKey can be used by callers.
	Enabled *bool `locationName:"enabled" type:"boolean"`

	// Specifies whether (true) or not (false) the key identifier is distinct from
	// the created API key value.
	GenerateDistinctId *bool `locationName:"generateDistinctId" type:"boolean"`

	// The name of the ApiKey.
	Name *string `locationName:"name" type:"string"`

	// DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.
	StageKeys []StageKey `locationName:"stageKeys" type:"list"`

	// Specifies a value of the API key.
	Value *string `locationName:"value" type:"string"`
}

// String returns the string representation
func (s CreateApiKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateApiKeyInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateApiKeyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CustomerId != nil {
		v := *s.CustomerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "customerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "enabled", protocol.BoolValue(v), metadata)
	}
	if s.GenerateDistinctId != nil {
		v := *s.GenerateDistinctId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "generateDistinctId", protocol.BoolValue(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.StageKeys) > 0 {
		v := s.StageKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "stageKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to add a new Authorizer to an existing RestApi resource.
type CreateAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// Optional customer-defined field, used in OpenAPI imports and exports without
	// functional impact.
	AuthType *string `locationName:"authType" type:"string"`

	// Specifies the required credentials as an IAM role for API Gateway to invoke
	// the authorizer. To specify an IAM role for API Gateway to assume, use the
	// role's Amazon Resource Name (ARN). To use resource-based permissions on the
	// Lambda function, specify null.
	AuthorizerCredentials *string `locationName:"authorizerCredentials" type:"string"`

	// The TTL in seconds of cached authorizer results. If it equals 0, authorization
	// caching is disabled. If it is greater than 0, API Gateway will cache authorizer
	// responses. If this field is not set, the default value is 300. The maximum
	// value is 3600, or 1 hour.
	AuthorizerResultTtlInSeconds *int64 `locationName:"authorizerResultTtlInSeconds" type:"integer"`

	// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or
	// REQUEST authorizers, this must be a well-formed Lambda function URI, for
	// example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations.
	// In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api},
	// where {region} is the same as the region hosting the Lambda function, path
	// indicates that the remaining substring in the URI should be treated as the
	// path to the resource, including the initial /. For Lambda functions, this
	// is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
	AuthorizerUri *string `locationName:"authorizerUri" type:"string"`

	// The identity source for which authorization is requested. For a TOKEN or
	// COGNITO_USER_POOLS authorizer, this is required and specifies the request
	// header mapping expression for the custom header holding the authorization
	// token submitted by the client. For example, if the token header name is Auth,
	// the header mapping expression is method.request.header.Auth.
	// For the REQUEST authorizer, this is required when authorization caching is
	// enabled. The value is a comma-separated string of one or more mapping expressions
	// of the specified request parameters. For example, if an Auth header, a Name
	// query string parameter are defined as identity sources, this value is method.request.header.Auth,
	// method.request.querystring.Name. These parameters will be used to derive
	// the authorization caching key and to perform runtime validation of the REQUEST
	// authorizer by verifying all of the identity-related request parameters are
	// present, not null and non-empty. Only when this is true does the authorizer
	// invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized
	// response without calling the Lambda function. The valid value is a string
	// of comma-separated mapping expressions of the specified request parameters.
	// When the authorization caching is not enabled, this property is optional.
	IdentitySource *string `locationName:"identitySource" type:"string"`

	// A validation expression for the incoming identity token. For TOKEN authorizers,
	// this value is a regular expression. API Gateway will match the aud field
	// of the incoming token from the client against the specified regular expression.
	// It will invoke the authorizer's Lambda function when there is a match. Otherwise,
	// it will return a 401 Unauthorized response without calling the Lambda function.
	// The validation expression does not apply to the REQUEST authorizer.
	IdentityValidationExpression *string `locationName:"identityValidationExpression" type:"string"`

	// [Required] The name of the authorizer.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer.
	// Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}.
	// For a TOKEN or REQUEST authorizer, this is not defined.
	ProviderARNs []string `locationName:"providerARNs" type:"list"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The authorizer type. Valid values are TOKEN for a Lambda function
	// using a single authorization token submitted in a custom header, REQUEST
	// for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS
	// for using an Amazon Cognito user pool.
	//
	// Type is a required field
	Type AuthorizerType `locationName:"type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s CreateAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateAuthorizerInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AuthType != nil {
		v := *s.AuthType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerCredentials != nil {
		v := *s.AuthorizerCredentials

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerCredentials", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerResultTtlInSeconds != nil {
		v := *s.AuthorizerResultTtlInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerResultTtlInSeconds", protocol.Int64Value(v), metadata)
	}
	if s.AuthorizerUri != nil {
		v := *s.AuthorizerUri

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerUri", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdentitySource != nil {
		v := *s.IdentitySource

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "identitySource", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdentityValidationExpression != nil {
		v := *s.IdentityValidationExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "identityValidationExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ProviderARNs) > 0 {
		v := s.ProviderARNs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "providerARNs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to create a new BasePathMapping resource.
type CreateBasePathMappingInput struct {
	_ struct{} `type:"structure"`

	// The base path name that callers of the API must provide as part of the URL
	// after the domain name. This value must be unique for all of the mappings
	// across a single API. Leave this blank if you do not want callers to specify
	// a base path name after the domain name.
	BasePath *string `locationName:"basePath" type:"string"`

	// [Required] The domain name of the BasePathMapping resource to create.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"domain_name" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `locationName:"restApiId" type:"string" required:"true"`

	// The name of the API's stage that you want to use for this mapping. Leave
	// this blank if you do not want callers to explicitly specify the stage name
	// after any base path name.
	Stage *string `locationName:"stage" type:"string"`
}

// String returns the string representation
func (s CreateBasePathMappingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBasePathMappingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBasePathMappingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateBasePathMappingInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateBasePathMappingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.BasePath != nil {
		v := *s.BasePath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "basePath", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "restApiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Stage != nil {
		v := *s.Stage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "domain_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to create a Deployment resource.
type CreateDeploymentInput struct {
	_ struct{} `type:"structure"`

	// Enables a cache cluster for the Stage resource specified in the input.
	CacheClusterEnabled *bool `locationName:"cacheClusterEnabled" type:"boolean"`

	// Specifies the cache cluster size for the Stage resource specified in the
	// input, if a cache cluster is enabled.
	CacheClusterSize CacheClusterSize `locationName:"cacheClusterSize" type:"string" enum:"true"`

	// The input configuration for the canary deployment when the deployment is
	// a canary release deployment.
	CanarySettings *DeploymentCanarySettings `locationName:"canarySettings" type:"structure"`

	// The description for the Deployment resource to create.
	Description *string `locationName:"description" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// The description of the Stage resource for the Deployment resource to create.
	StageDescription *string `locationName:"stageDescription" type:"string"`

	// The name of the Stage resource for the Deployment resource to create.
	StageName *string `locationName:"stageName" type:"string"`

	// Specifies whether active tracing with X-ray is enabled for the Stage.
	TracingEnabled *bool `locationName:"tracingEnabled" type:"boolean"`

	// A map that defines the stage variables for the Stage resource that is associated
	// with the new deployment. Variable names can have alphanumeric and underscore
	// characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
	Variables map[string]string `locationName:"variables" type:"map"`
}

// String returns the string representation
func (s CreateDeploymentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDeploymentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDeploymentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDeploymentInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateDeploymentInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CacheClusterEnabled != nil {
		v := *s.CacheClusterEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheClusterEnabled", protocol.BoolValue(v), metadata)
	}
	if len(s.CacheClusterSize) > 0 {
		v := s.CacheClusterSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheClusterSize", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.CanarySettings != nil {
		v := s.CanarySettings

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "canarySettings", v, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageDescription != nil {
		v := *s.StageDescription

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stageDescription", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stageName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.TracingEnabled != nil {
		v := *s.TracingEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tracingEnabled", protocol.BoolValue(v), metadata)
	}
	if len(s.Variables) > 0 {
		v := s.Variables

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "variables", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Creates a new documentation part of a given API.
type CreateDocumentationPartInput struct {
	_ struct{} `type:"structure"`

	// [Required] The location of the targeted API entity of the to-be-created documentation
	// part.
	//
	// Location is a required field
	Location *DocumentationPartLocation `locationName:"location" type:"structure" required:"true"`

	// [Required] The new documentation content map of the targeted API entity.
	// Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value
	// pairs can be exported and, hence, published.
	//
	// Properties is a required field
	Properties *string `locationName:"properties" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateDocumentationPartInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDocumentationPartInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDocumentationPartInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDocumentationPartInput"}

	if s.Location == nil {
		invalidParams.Add(aws.NewErrParamRequired("Location"))
	}

	if s.Properties == nil {
		invalidParams.Add(aws.NewErrParamRequired("Properties"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}
	if s.Location != nil {
		if err := s.Location.Validate(); err != nil {
			invalidParams.AddNested("Location", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateDocumentationPartInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Location != nil {
		v := s.Location

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "location", v, metadata)
	}
	if s.Properties != nil {
		v := *s.Properties

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "properties", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Creates a new documentation version of a given API.
type CreateDocumentationVersionInput struct {
	_ struct{} `type:"structure"`

	// A description about the new documentation snapshot.
	Description *string `locationName:"description" type:"string"`

	// [Required] The version identifier of the new snapshot.
	//
	// DocumentationVersion is a required field
	DocumentationVersion *string `locationName:"documentationVersion" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// The stage name to be associated with the new documentation snapshot.
	StageName *string `locationName:"stageName" type:"string"`
}

// String returns the string representation
func (s CreateDocumentationVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDocumentationVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDocumentationVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDocumentationVersionInput"}

	if s.DocumentationVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentationVersion"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateDocumentationVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentationVersion != nil {
		v := *s.DocumentationVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "documentationVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stageName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A request to create a new domain name.
type CreateDomainNameInput struct {
	_ struct{} `type:"structure"`

	// The reference to an AWS-managed certificate that will be used by edge-optimized
	// endpoint for this domain name. AWS Certificate Manager is the only supported
	// source.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// [Deprecated] The body of the server certificate that will be used by edge-optimized
	// endpoint for this domain name provided by your certificate authority.
	CertificateBody *string `locationName:"certificateBody" type:"string"`

	// [Deprecated] The intermediate certificates and optionally the root certificate,
	// one after the other without any blank lines, used by an edge-optimized endpoint
	// for this domain name. If you include the root certificate, your certificate
	// chain must start with intermediate certificates and end with the root certificate.
	// Use the intermediate certificates that were provided by your certificate
	// authority. Do not include any intermediaries that are not in the chain of
	// trust path.
	CertificateChain *string `locationName:"certificateChain" type:"string"`

	// The user-friendly name of the certificate that will be used by edge-optimized
	// endpoint for this domain name.
	CertificateName *string `locationName:"certificateName" type:"string"`

	// [Deprecated] Your edge-optimized endpoint's domain name certificate's private
	// key.
	CertificatePrivateKey *string `locationName:"certificatePrivateKey" type:"string"`

	// [Required] The name of the DomainName resource.
	//
	// DomainName is a required field
	DomainName *string `locationName:"domainName" type:"string" required:"true"`

	// The endpoint configuration of this DomainName showing the endpoint types
	// of the domain name.
	EndpointConfiguration *EndpointConfiguration `locationName:"endpointConfiguration" type:"structure"`

	// The reference to an AWS-managed certificate that will be used by regional
	// endpoint for this domain name. AWS Certificate Manager is the only supported
	// source.
	RegionalCertificateArn *string `locationName:"regionalCertificateArn" type:"string"`

	// The user-friendly name of the certificate that will be used by regional endpoint
	// for this domain name.
	RegionalCertificateName *string `locationName:"regionalCertificateName" type:"string"`
}

// String returns the string representation
func (s CreateDomainNameInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateDomainNameInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateDomainNameInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateDomainNameInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateDomainNameInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateBody != nil {
		v := *s.CertificateBody

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateBody", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateChain != nil {
		v := *s.CertificateChain

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateChain", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateName != nil {
		v := *s.CertificateName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificatePrivateKey != nil {
		v := *s.CertificatePrivateKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificatePrivateKey", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "domainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EndpointConfiguration != nil {
		v := s.EndpointConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "endpointConfiguration", v, metadata)
	}
	if s.RegionalCertificateArn != nil {
		v := *s.RegionalCertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "regionalCertificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RegionalCertificateName != nil {
		v := *s.RegionalCertificateName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "regionalCertificateName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to add a new Model to an existing RestApi resource.
type CreateModelInput struct {
	_ struct{} `type:"structure"`

	// [Required] The content-type for the model.
	//
	// ContentType is a required field
	ContentType *string `locationName:"contentType" type:"string" required:"true"`

	// The description of the model.
	Description *string `locationName:"description" type:"string"`

	// [Required] The name of the model. Must be alphanumeric.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// [Required] The RestApi identifier under which the Model will be created.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// The schema for the model. For application/json models, this should be JSON
	// schema draft 4 (https://tools.ietf.org/html/draft-zyp-json-schema-04) model.
	Schema *string `locationName:"schema" type:"string"`
}

// String returns the string representation
func (s CreateModelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateModelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateModelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateModelInput"}

	if s.ContentType == nil {
		invalidParams.Add(aws.NewErrParamRequired("ContentType"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateModelInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "contentType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Schema != nil {
		v := *s.Schema

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "schema", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Creates a RequestValidator of a given RestApi.
type CreateRequestValidatorInput struct {
	_ struct{} `type:"structure"`

	// The name of the to-be-created RequestValidator.
	Name *string `locationName:"name" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// A Boolean flag to indicate whether to validate request body according to
	// the configured model schema for the method (true) or not (false).
	ValidateRequestBody *bool `locationName:"validateRequestBody" type:"boolean"`

	// A Boolean flag to indicate whether to validate request parameters, true,
	// or not false.
	ValidateRequestParameters *bool `locationName:"validateRequestParameters" type:"boolean"`
}

// String returns the string representation
func (s CreateRequestValidatorInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateRequestValidatorInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateRequestValidatorInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateRequestValidatorInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateRequestValidatorInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ValidateRequestBody != nil {
		v := *s.ValidateRequestBody

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "validateRequestBody", protocol.BoolValue(v), metadata)
	}
	if s.ValidateRequestParameters != nil {
		v := *s.ValidateRequestParameters

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "validateRequestParameters", protocol.BoolValue(v), metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to create a Resource resource.
type CreateResourceInput struct {
	_ struct{} `type:"structure"`

	// [Required] The parent resource's identifier.
	//
	// ParentId is a required field
	ParentId *string `location:"uri" locationName:"parent_id" type:"string" required:"true"`

	// The last path segment for this resource.
	//
	// PathPart is a required field
	PathPart *string `locationName:"pathPart" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateResourceInput"}

	if s.ParentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ParentId"))
	}

	if s.PathPart == nil {
		invalidParams.Add(aws.NewErrParamRequired("PathPart"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.PathPart != nil {
		v := *s.PathPart

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "pathPart", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentId != nil {
		v := *s.ParentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "parent_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The POST Request to add a new RestApi resource to your collection.
type CreateRestApiInput struct {
	_ struct{} `type:"structure"`

	// The source of the API key for metering requests according to a usage plan.
	// Valid values are: HEADER to read the API key from the X-API-Key header of
	// a request.
	// AUTHORIZER to read the API key from the UsageIdentifierKey from a custom
	// authorizer.
	ApiKeySource ApiKeySourceType `locationName:"apiKeySource" type:"string" enum:"true"`

	// The list of binary media types supported by the RestApi. By default, the
	// RestApi supports only UTF-8-encoded text payloads.
	BinaryMediaTypes []string `locationName:"binaryMediaTypes" type:"list"`

	// The ID of the RestApi that you want to clone from.
	CloneFrom *string `locationName:"cloneFrom" type:"string"`

	// The description of the RestApi.
	Description *string `locationName:"description" type:"string"`

	// The endpoint configuration of this RestApi showing the endpoint types of
	// the API.
	EndpointConfiguration *EndpointConfiguration `locationName:"endpointConfiguration" type:"structure"`

	// A nullable integer that is used to enable compression (with non-negative
	// between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with
	// a null value) on an API. When compression is enabled, compression or decompression
	// is not applied on the payload if the payload size is smaller than this value.
	// Setting it to zero allows compression for any payload size.
	MinimumCompressionSize *int64 `locationName:"minimumCompressionSize" type:"integer"`

	// [Required] The name of the RestApi.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// A stringified JSON policy document that applies to this RestApi regardless
	// of the caller and Method
	Policy *string `locationName:"policy" type:"string"`

	// A version identifier for the API.
	Version *string `locationName:"version" type:"string"`
}

// String returns the string representation
func (s CreateRestApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateRestApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateRestApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateRestApiInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateRestApiInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ApiKeySource) > 0 {
		v := s.ApiKeySource

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "apiKeySource", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.BinaryMediaTypes) > 0 {
		v := s.BinaryMediaTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "binaryMediaTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.CloneFrom != nil {
		v := *s.CloneFrom

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cloneFrom", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EndpointConfiguration != nil {
		v := s.EndpointConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "endpointConfiguration", v, metadata)
	}
	if s.MinimumCompressionSize != nil {
		v := *s.MinimumCompressionSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "minimumCompressionSize", protocol.Int64Value(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Policy != nil {
		v := *s.Policy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to create a Stage resource.
type CreateStageInput struct {
	_ struct{} `type:"structure"`

	// Whether cache clustering is enabled for the stage.
	CacheClusterEnabled *bool `locationName:"cacheClusterEnabled" type:"boolean"`

	// The stage's cache cluster size.
	CacheClusterSize CacheClusterSize `locationName:"cacheClusterSize" type:"string" enum:"true"`

	// The canary deployment settings of this stage.
	CanarySettings *CanarySettings `locationName:"canarySettings" type:"structure"`

	// [Required] The identifier of the Deployment resource for the Stage resource.
	//
	// DeploymentId is a required field
	DeploymentId *string `locationName:"deploymentId" type:"string" required:"true"`

	// The description of the Stage resource.
	Description *string `locationName:"description" type:"string"`

	// The version of the associated API documentation.
	DocumentationVersion *string `locationName:"documentationVersion" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The name for the Stage resource.
	//
	// StageName is a required field
	StageName *string `locationName:"stageName" type:"string" required:"true"`

	// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/].
	// The tag key can be up to 128 characters and must not start with aws:. The
	// tag value can be up to 256 characters.
	Tags map[string]string `locationName:"tags" type:"map"`

	// Specifies whether active tracing with X-ray is enabled for the Stage.
	TracingEnabled *bool `locationName:"tracingEnabled" type:"boolean"`

	// A map that defines the stage variables for the new Stage resource. Variable
	// names can have alphanumeric and underscore characters, and the values must
	// match [A-Za-z0-9-._~:/?#&=,]+.
	Variables map[string]string `locationName:"variables" type:"map"`
}

// String returns the string representation
func (s CreateStageInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateStageInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateStageInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateStageInput"}

	if s.DeploymentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DeploymentId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StageName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StageName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateStageInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CacheClusterEnabled != nil {
		v := *s.CacheClusterEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheClusterEnabled", protocol.BoolValue(v), metadata)
	}
	if len(s.CacheClusterSize) > 0 {
		v := s.CacheClusterSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheClusterSize", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.CanarySettings != nil {
		v := s.CanarySettings

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "canarySettings", v, metadata)
	}
	if s.DeploymentId != nil {
		v := *s.DeploymentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deploymentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentationVersion != nil {
		v := *s.DocumentationVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "documentationVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stageName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.TracingEnabled != nil {
		v := *s.TracingEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tracingEnabled", protocol.BoolValue(v), metadata)
	}
	if len(s.Variables) > 0 {
		v := s.Variables

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "variables", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The POST request to create a usage plan with the name, description, throttle
// limits and quota limits, as well as the associated API stages, specified
// in the payload.
type CreateUsagePlanInput struct {
	_ struct{} `type:"structure"`

	// The associated API stages of the usage plan.
	ApiStages []ApiStage `locationName:"apiStages" type:"list"`

	// The description of the usage plan.
	Description *string `locationName:"description" type:"string"`

	// [Required] The name of the usage plan.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// The quota of the usage plan.
	Quota *QuotaSettings `locationName:"quota" type:"structure"`

	// The throttling limits of the usage plan.
	Throttle *ThrottleSettings `locationName:"throttle" type:"structure"`
}

// String returns the string representation
func (s CreateUsagePlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateUsagePlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateUsagePlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateUsagePlanInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateUsagePlanInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ApiStages) > 0 {
		v := s.ApiStages

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "apiStages", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Quota != nil {
		v := s.Quota

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "quota", v, metadata)
	}
	if s.Throttle != nil {
		v := s.Throttle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "throttle", v, metadata)
	}
	return nil
}

// The POST request to create a usage plan key for adding an existing API key
// to a usage plan.
type CreateUsagePlanKeyInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of a UsagePlanKey resource for a plan customer.
	//
	// KeyId is a required field
	KeyId *string `locationName:"keyId" type:"string" required:"true"`

	// [Required] The type of a UsagePlanKey resource for a plan customer.
	//
	// KeyType is a required field
	KeyType *string `locationName:"keyType" type:"string" required:"true"`

	// [Required] The Id of the UsagePlan resource representing the usage plan containing
	// the to-be-created UsagePlanKey resource representing a plan customer.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateUsagePlanKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateUsagePlanKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateUsagePlanKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateUsagePlanKeyInput"}

	if s.KeyId == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeyId"))
	}

	if s.KeyType == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeyType"))
	}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateUsagePlanKeyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "keyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KeyType != nil {
		v := *s.KeyType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "keyType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Creates a VPC link, under the caller's account in a selected region, in an
// asynchronous operation that typically takes 2-4 minutes to complete and become
// operational. The caller must have permissions to create and update VPC Endpoint
// services.
type CreateVpcLinkInput struct {
	_ struct{} `type:"structure"`

	// The description of the VPC link.
	Description *string `locationName:"description" type:"string"`

	// [Required] The name used to label and identify the VPC link.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`

	// [Required] The ARNs of network load balancers of the VPC targeted by the
	// VPC link. The network load balancers must be owned by the same AWS account
	// of the API owner.
	//
	// TargetArns is a required field
	TargetArns []string `locationName:"targetArns" type:"list" required:"true"`
}

// String returns the string representation
func (s CreateVpcLinkInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVpcLinkInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateVpcLinkInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateVpcLinkInput"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.TargetArns == nil {
		invalidParams.Add(aws.NewErrParamRequired("TargetArns"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateVpcLinkInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TargetArns) > 0 {
		v := s.TargetArns

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "targetArns", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// A request to delete the ApiKey resource.
type DeleteApiKeyInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the ApiKey resource to be deleted.
	//
	// ApiKey is a required field
	ApiKey *string `location:"uri" locationName:"api_Key" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteApiKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteApiKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteApiKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteApiKeyInput"}

	if s.ApiKey == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiKey"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteApiKeyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ApiKey != nil {
		v := *s.ApiKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "api_Key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteApiKeyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteApiKeyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteApiKeyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteApiKeyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteApiKeyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Request to delete an existing Authorizer resource.
type DeleteAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the Authorizer resource.
	//
	// AuthorizerId is a required field
	AuthorizerId *string `location:"uri" locationName:"authorizer_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteAuthorizerInput"}

	if s.AuthorizerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AuthorizerId != nil {
		v := *s.AuthorizerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizer_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A request to delete the BasePathMapping resource.
type DeleteBasePathMappingInput struct {
	_ struct{} `type:"structure"`

	// [Required] The base path name of the BasePathMapping resource to delete.
	//
	// BasePath is a required field
	BasePath *string `location:"uri" locationName:"base_path" type:"string" required:"true"`

	// [Required] The domain name of the BasePathMapping resource to delete.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"domain_name" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBasePathMappingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBasePathMappingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBasePathMappingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteBasePathMappingInput"}

	if s.BasePath == nil {
		invalidParams.Add(aws.NewErrParamRequired("BasePath"))
	}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBasePathMappingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.BasePath != nil {
		v := *s.BasePath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "base_path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "domain_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteBasePathMappingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteBasePathMappingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBasePathMappingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteBasePathMappingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteBasePathMappingOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A request to delete the ClientCertificate resource.
type DeleteClientCertificateInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the ClientCertificate resource to be deleted.
	//
	// ClientCertificateId is a required field
	ClientCertificateId *string `location:"uri" locationName:"clientcertificate_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteClientCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteClientCertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteClientCertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteClientCertificateInput"}

	if s.ClientCertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ClientCertificateId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteClientCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ClientCertificateId != nil {
		v := *s.ClientCertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "clientcertificate_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteClientCertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteClientCertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteClientCertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteClientCertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteClientCertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Requests API Gateway to delete a Deployment resource.
type DeleteDeploymentInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the Deployment resource to delete.
	//
	// DeploymentId is a required field
	DeploymentId *string `location:"uri" locationName:"deployment_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDeploymentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDeploymentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteDeploymentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteDeploymentInput"}

	if s.DeploymentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DeploymentId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDeploymentInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DeploymentId != nil {
		v := *s.DeploymentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "deployment_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteDeploymentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteDeploymentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDeploymentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteDeploymentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDeploymentOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Deletes an existing documentation part of an API.
type DeleteDocumentationPartInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the to-be-deleted documentation part.
	//
	// DocumentationPartId is a required field
	DocumentationPartId *string `location:"uri" locationName:"part_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDocumentationPartInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDocumentationPartInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteDocumentationPartInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteDocumentationPartInput"}

	if s.DocumentationPartId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentationPartId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDocumentationPartInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DocumentationPartId != nil {
		v := *s.DocumentationPartId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "part_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteDocumentationPartOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteDocumentationPartOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDocumentationPartOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteDocumentationPartOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDocumentationPartOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Deletes an existing documentation version of an API.
type DeleteDocumentationVersionInput struct {
	_ struct{} `type:"structure"`

	// [Required] The version identifier of a to-be-deleted documentation snapshot.
	//
	// DocumentationVersion is a required field
	DocumentationVersion *string `location:"uri" locationName:"doc_version" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDocumentationVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDocumentationVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteDocumentationVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteDocumentationVersionInput"}

	if s.DocumentationVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentationVersion"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDocumentationVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DocumentationVersion != nil {
		v := *s.DocumentationVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "doc_version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteDocumentationVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteDocumentationVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDocumentationVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteDocumentationVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDocumentationVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A request to delete the DomainName resource.
type DeleteDomainNameInput struct {
	_ struct{} `type:"structure"`

	// [Required] The name of the DomainName resource to be deleted.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"domain_name" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteDomainNameInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDomainNameInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteDomainNameInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteDomainNameInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDomainNameInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "domain_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteDomainNameOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteDomainNameOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteDomainNameOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteDomainNameOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteDomainNameOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Clears any customization of a GatewayResponse of a specified response type
// on the given RestApi and resets it with the default settings.
type DeleteGatewayResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] The response type of the associated GatewayResponse. Valid values
	// are ACCESS_DENIED
	// API_CONFIGURATION_ERROR
	// AUTHORIZER_FAILURE
	//  AUTHORIZER_CONFIGURATION_ERROR
	// BAD_REQUEST_PARAMETERS
	// BAD_REQUEST_BODY
	// DEFAULT_4XX
	// DEFAULT_5XX
	// EXPIRED_TOKEN
	// INVALID_SIGNATURE
	// INTEGRATION_FAILURE
	// INTEGRATION_TIMEOUT
	// INVALID_API_KEY
	// MISSING_AUTHENTICATION_TOKEN
	//  QUOTA_EXCEEDED
	// REQUEST_TOO_LARGE
	// RESOURCE_NOT_FOUND
	// THROTTLED
	// UNAUTHORIZED
	// UNSUPPORTED_MEDIA_TYPE
	//
	// ResponseType is a required field
	ResponseType GatewayResponseType `location:"uri" locationName:"response_type" type:"string" required:"true" enum:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteGatewayResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGatewayResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteGatewayResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteGatewayResponseInput"}
	if len(s.ResponseType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResponseType"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteGatewayResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ResponseType) > 0 {
		v := s.ResponseType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "response_type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteGatewayResponseOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteGatewayResponseOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteGatewayResponseOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteGatewayResponseOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteGatewayResponseOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Represents a delete integration request.
type DeleteIntegrationInput struct {
	_ struct{} `type:"structure"`

	// [Required] Specifies a delete integration request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] Specifies a delete integration request's resource identifier.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteIntegrationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteIntegrationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteIntegrationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteIntegrationInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteIntegrationInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteIntegrationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteIntegrationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteIntegrationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteIntegrationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteIntegrationOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Represents a delete integration response request.
type DeleteIntegrationResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] Specifies a delete integration response request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] Specifies a delete integration response request's resource identifier.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] Specifies a delete integration response request's status code.
	//
	// StatusCode is a required field
	StatusCode *string `location:"uri" locationName:"status_code" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteIntegrationResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteIntegrationResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteIntegrationResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteIntegrationResponseInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StatusCode == nil {
		invalidParams.Add(aws.NewErrParamRequired("StatusCode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteIntegrationResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "status_code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteIntegrationResponseOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteIntegrationResponseOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteIntegrationResponseOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteIntegrationResponseOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteIntegrationResponseOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Request to delete an existing Method resource.
type DeleteMethodInput struct {
	_ struct{} `type:"structure"`

	// [Required] The HTTP verb of the Method resource.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] The Resource identifier for the Method resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteMethodInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMethodInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteMethodInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteMethodInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteMethodInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteMethodOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteMethodOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMethodOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteMethodOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteMethodOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A request to delete an existing MethodResponse resource.
type DeleteMethodResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] The HTTP verb of the Method resource.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] The Resource identifier for the MethodResponse resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The status code identifier for the MethodResponse resource.
	//
	// StatusCode is a required field
	StatusCode *string `location:"uri" locationName:"status_code" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteMethodResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMethodResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteMethodResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteMethodResponseInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StatusCode == nil {
		invalidParams.Add(aws.NewErrParamRequired("StatusCode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteMethodResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "status_code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteMethodResponseOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteMethodResponseOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteMethodResponseOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteMethodResponseOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteMethodResponseOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Request to delete an existing model in an existing RestApi resource.
type DeleteModelInput struct {
	_ struct{} `type:"structure"`

	// [Required] The name of the model to delete.
	//
	// ModelName is a required field
	ModelName *string `location:"uri" locationName:"model_name" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteModelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteModelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteModelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteModelInput"}

	if s.ModelName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ModelName"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteModelInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ModelName != nil {
		v := *s.ModelName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "model_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteModelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteModelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteModelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteModelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteModelOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Deletes a specified RequestValidator of a given RestApi.
type DeleteRequestValidatorInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the RequestValidator to be deleted.
	//
	// RequestValidatorId is a required field
	RequestValidatorId *string `location:"uri" locationName:"requestvalidator_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteRequestValidatorInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRequestValidatorInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteRequestValidatorInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteRequestValidatorInput"}

	if s.RequestValidatorId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestValidatorId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRequestValidatorInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RequestValidatorId != nil {
		v := *s.RequestValidatorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "requestvalidator_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteRequestValidatorOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteRequestValidatorOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRequestValidatorOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteRequestValidatorOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRequestValidatorOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Request to delete a Resource.
type DeleteResourceInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the Resource resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteResourceInput"}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Request to delete the specified API from your collection.
type DeleteRestApiInput struct {
	_ struct{} `type:"structure"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteRestApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRestApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteRestApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteRestApiInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRestApiInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteRestApiOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteRestApiOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRestApiOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteRestApiOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteRestApiOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Requests API Gateway to delete a Stage resource.
type DeleteStageInput struct {
	_ struct{} `type:"structure"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The name of the Stage resource to delete.
	//
	// StageName is a required field
	StageName *string `location:"uri" locationName:"stage_name" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteStageInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteStageInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteStageInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteStageInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StageName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StageName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteStageInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "stage_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteStageOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteStageOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteStageOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteStageOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteStageOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The DELETE request to delete a usage plan of a given plan Id.
type DeleteUsagePlanInput struct {
	_ struct{} `type:"structure"`

	// [Required] The Id of the to-be-deleted usage plan.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteUsagePlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUsagePlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteUsagePlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteUsagePlanInput"}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUsagePlanInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The DELETE request to delete a usage plan key and remove the underlying API
// key from the associated usage plan.
type DeleteUsagePlanKeyInput struct {
	_ struct{} `type:"structure"`

	// [Required] The Id of the UsagePlanKey resource to be deleted.
	//
	// KeyId is a required field
	KeyId *string `location:"uri" locationName:"keyId" type:"string" required:"true"`

	// [Required] The Id of the UsagePlan resource representing the usage plan containing
	// the to-be-deleted UsagePlanKey resource representing a plan customer.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteUsagePlanKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUsagePlanKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteUsagePlanKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteUsagePlanKeyInput"}

	if s.KeyId == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeyId"))
	}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUsagePlanKeyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "keyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteUsagePlanKeyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteUsagePlanKeyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUsagePlanKeyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteUsagePlanKeyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUsagePlanKeyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

type DeleteUsagePlanOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteUsagePlanOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteUsagePlanOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteUsagePlanOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteUsagePlanOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Deletes an existing VpcLink of a specified identifier.
type DeleteVpcLinkInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the VpcLink. It is used in an Integration to
	// reference this VpcLink.
	//
	// VpcLinkId is a required field
	VpcLinkId *string `location:"uri" locationName:"vpclink_id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteVpcLinkInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVpcLinkInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteVpcLinkInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteVpcLinkInput"}

	if s.VpcLinkId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VpcLinkId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVpcLinkInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.VpcLinkId != nil {
		v := *s.VpcLinkId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vpclink_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type DeleteVpcLinkOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteVpcLinkOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVpcLinkOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteVpcLinkOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVpcLinkOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// The input configuration for a canary deployment.
type DeploymentCanarySettings struct {
	_ struct{} `type:"structure"`

	// The percentage (0.0-100.0) of traffic routed to the canary deployment.
	PercentTraffic *float64 `locationName:"percentTraffic" type:"double"`

	// A stage variable overrides used for the canary release deployment. They can
	// override existing stage variables or add new stage variables for the canary
	// release deployment. These stage variables are represented as a string-to-string
	// map between stage variable names and their values.
	StageVariableOverrides map[string]string `locationName:"stageVariableOverrides" type:"map"`

	// A Boolean flag to indicate whether the canary release deployment uses the
	// stage cache or not.
	UseStageCache *bool `locationName:"useStageCache" type:"boolean"`
}

// String returns the string representation
func (s DeploymentCanarySettings) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeploymentCanarySettings) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeploymentCanarySettings) MarshalFields(e protocol.FieldEncoder) error {
	if s.PercentTraffic != nil {
		v := *s.PercentTraffic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "percentTraffic", protocol.Float64Value(v), metadata)
	}
	if len(s.StageVariableOverrides) > 0 {
		v := s.StageVariableOverrides

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "stageVariableOverrides", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.UseStageCache != nil {
		v := *s.UseStageCache

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "useStageCache", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Specifies the target API entity to which the documentation applies.
type DocumentationPartLocation struct {
	_ struct{} `type:"structure"`

	// The HTTP verb of a method. It is a valid field for the API entity types of
	// METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE,
	// RESPONSE_HEADER, and RESPONSE_BODY. The default value is * for any method.
	// When an applicable child entity inherits the content of an entity of the
	// same type with more general specifications of the other location attributes,
	// the child entity's method attribute must match that of the parent entity
	// exactly.
	Method *string `locationName:"method" type:"string"`

	// The name of the targeted API entity. It is a valid and required field for
	// the API entity types of AUTHORIZER, MODEL, PATH_PARAMETER, QUERY_PARAMETER,
	// REQUEST_HEADER, REQUEST_BODY and RESPONSE_HEADER. It is an invalid field
	// for any other entity type.
	Name *string `locationName:"name" type:"string"`

	// The URL path of the target. It is a valid field for the API entity types
	// of RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY,
	// RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is / for
	// the root resource. When an applicable child entity inherits the content of
	// another entity of the same type with more general specifications of the other
	// location attributes, the child entity's path attribute must match that of
	// the parent entity as a prefix.
	Path *string `locationName:"path" type:"string"`

	// The HTTP status code of a response. It is a valid field for the API entity
	// types of RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value
	// is * for any status code. When an applicable child entity inherits the content
	// of an entity of the same type with more general specifications of the other
	// location attributes, the child entity's statusCode attribute must match that
	// of the parent entity exactly.
	StatusCode *string `locationName:"statusCode" type:"string"`

	// [Required] The type of API entity to which the documentation content applies.
	// Valid values are API, AUTHORIZER, MODEL, RESOURCE, METHOD, PATH_PARAMETER,
	// QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER,
	// and RESPONSE_BODY. Content inheritance does not apply to any entity of the
	// API, AUTHORIZER, METHOD, MODEL, REQUEST_BODY, or RESOURCE type.
	//
	// Type is a required field
	Type DocumentationPartType `locationName:"type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s DocumentationPartLocation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DocumentationPartLocation) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DocumentationPartLocation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DocumentationPartLocation"}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DocumentationPartLocation) MarshalFields(e protocol.FieldEncoder) error {
	if s.Method != nil {
		v := *s.Method

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The endpoint configuration to indicate the types of endpoints an API (RestApi)
// or its custom domain name (DomainName) has.
type EndpointConfiguration struct {
	_ struct{} `type:"structure"`

	// A list of endpoint types of an API (RestApi) or its custom domain name (DomainName).
	// For an edge-optimized API and its custom domain name, the endpoint type is
	// "EDGE". For a regional API and its custom domain name, the endpoint type
	// is REGIONAL. For a private API, the endpoint type is PRIVATE.
	Types []EndpointType `locationName:"types" type:"list"`
}

// String returns the string representation
func (s EndpointConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EndpointConfiguration) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s EndpointConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Types) > 0 {
		v := s.Types

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "types", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Request to flush authorizer cache entries on a specified stage.
type FlushStageAuthorizersCacheInput struct {
	_ struct{} `type:"structure"`

	// The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// The name of the stage to flush.
	//
	// StageName is a required field
	StageName *string `location:"uri" locationName:"stage_name" type:"string" required:"true"`
}

// String returns the string representation
func (s FlushStageAuthorizersCacheInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FlushStageAuthorizersCacheInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FlushStageAuthorizersCacheInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FlushStageAuthorizersCacheInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StageName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StageName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FlushStageAuthorizersCacheInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "stage_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type FlushStageAuthorizersCacheOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s FlushStageAuthorizersCacheOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FlushStageAuthorizersCacheOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s FlushStageAuthorizersCacheOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FlushStageAuthorizersCacheOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Requests API Gateway to flush a stage's cache.
type FlushStageCacheInput struct {
	_ struct{} `type:"structure"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The name of the stage to flush its cache.
	//
	// StageName is a required field
	StageName *string `location:"uri" locationName:"stage_name" type:"string" required:"true"`
}

// String returns the string representation
func (s FlushStageCacheInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FlushStageCacheInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *FlushStageCacheInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "FlushStageCacheInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StageName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StageName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FlushStageCacheInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "stage_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type FlushStageCacheOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s FlushStageCacheOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FlushStageCacheOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s FlushStageCacheOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s FlushStageCacheOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A request to generate a ClientCertificate resource.
type GenerateClientCertificateInput struct {
	_ struct{} `type:"structure"`

	// The description of the ClientCertificate.
	Description *string `locationName:"description" type:"string"`
}

// String returns the string representation
func (s GenerateClientCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GenerateClientCertificateInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GenerateClientCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to get information about the current Account resource.
type GetAccountInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetAccountInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetAccountInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetAccountInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// A request to get information about the current ApiKey resource.
type GetApiKeyInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the ApiKey resource.
	//
	// ApiKey is a required field
	ApiKey *string `location:"uri" locationName:"api_Key" type:"string" required:"true"`

	// A boolean flag to specify whether (true) or not (false) the result contains
	// the key value.
	IncludeValue *bool `location:"querystring" locationName:"includeValue" type:"boolean"`
}

// String returns the string representation
func (s GetApiKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetApiKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetApiKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetApiKeyInput"}

	if s.ApiKey == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiKey"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetApiKeyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ApiKey != nil {
		v := *s.ApiKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "api_Key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IncludeValue != nil {
		v := *s.IncludeValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "includeValue", protocol.BoolValue(v), metadata)
	}
	return nil
}

// A request to get information about the current ApiKeys resource.
type GetApiKeysInput struct {
	_ struct{} `type:"structure"`

	// The identifier of a customer in AWS Marketplace or an external system, such
	// as a developer portal.
	CustomerId *string `location:"querystring" locationName:"customerId" type:"string"`

	// A boolean flag to specify whether (true) or not (false) the result contains
	// key values.
	IncludeValues *bool `location:"querystring" locationName:"includeValues" type:"boolean"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The name of queried API keys.
	NameQuery *string `location:"querystring" locationName:"name" type:"string"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetApiKeysInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetApiKeysInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetApiKeysInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.CustomerId != nil {
		v := *s.CustomerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "customerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IncludeValues != nil {
		v := *s.IncludeValues

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "includeValues", protocol.BoolValue(v), metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.NameQuery != nil {
		v := *s.NameQuery

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection of API keys as represented by an ApiKeys resource.
//
// Use API Keys (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html)
type GetApiKeysOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateApiKeyOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`

	// A list of warning messages logged during the import of API keys when the
	// failOnWarnings option is set to true.
	Warnings []string `locationName:"warnings" type:"list"`
}

// String returns the string representation
func (s GetApiKeysOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetApiKeysOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetApiKeysOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetApiKeysOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Warnings) > 0 {
		v := s.Warnings

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "warnings", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Request to describe an existing Authorizer resource.
type GetAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the Authorizer resource.
	//
	// AuthorizerId is a required field
	AuthorizerId *string `location:"uri" locationName:"authorizer_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetAuthorizerInput"}

	if s.AuthorizerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.AuthorizerId != nil {
		v := *s.AuthorizerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizer_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to describe an existing Authorizers resource.
type GetAuthorizersInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetAuthorizersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetAuthorizersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetAuthorizersInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetAuthorizersInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetAuthorizersInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection of Authorizer resources.
//
// Enable custom authorization (https://docs.aws.amazon.com/apigateway/latest/developerguide/use-custom-authorizer.html)
type GetAuthorizersOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateAuthorizerOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetAuthorizersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetAuthorizersOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetAuthorizersOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetAuthorizersOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to describe a BasePathMapping resource.
type GetBasePathMappingInput struct {
	_ struct{} `type:"structure"`

	// [Required] The base path name that callers of the API must provide as part
	// of the URL after the domain name. This value must be unique for all of the
	// mappings across a single API. Leave this blank if you do not want callers
	// to specify any base path name after the domain name.
	//
	// BasePath is a required field
	BasePath *string `location:"uri" locationName:"base_path" type:"string" required:"true"`

	// [Required] The domain name of the BasePathMapping resource to be described.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"domain_name" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBasePathMappingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBasePathMappingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBasePathMappingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBasePathMappingInput"}

	if s.BasePath == nil {
		invalidParams.Add(aws.NewErrParamRequired("BasePath"))
	}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBasePathMappingInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.BasePath != nil {
		v := *s.BasePath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "base_path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "domain_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A request to get information about a collection of BasePathMapping resources.
type GetBasePathMappingsInput struct {
	_ struct{} `type:"structure"`

	// [Required] The domain name of a BasePathMapping resource.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"domain_name" type:"string" required:"true"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetBasePathMappingsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBasePathMappingsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBasePathMappingsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetBasePathMappingsInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBasePathMappingsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "domain_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection of BasePathMapping resources.
//
// Use Custom Domain Names (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
type GetBasePathMappingsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateBasePathMappingOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetBasePathMappingsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBasePathMappingsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetBasePathMappingsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetBasePathMappingsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A request to get information about the current ClientCertificate resource.
type GetClientCertificateInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the ClientCertificate resource to be described.
	//
	// ClientCertificateId is a required field
	ClientCertificateId *string `location:"uri" locationName:"clientcertificate_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetClientCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetClientCertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetClientCertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetClientCertificateInput"}

	if s.ClientCertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ClientCertificateId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetClientCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ClientCertificateId != nil {
		v := *s.ClientCertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "clientcertificate_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A request to get information about a collection of ClientCertificate resources.
type GetClientCertificatesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetClientCertificatesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetClientCertificatesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetClientCertificatesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection of ClientCertificate resources.
//
// Use Client-Side Certificate (https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html)
type GetClientCertificatesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateClientCertificateOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetClientCertificatesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetClientCertificatesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetClientCertificatesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetClientCertificatesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to get information about a Deployment resource.
type GetDeploymentInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the Deployment resource to get information about.
	//
	// DeploymentId is a required field
	DeploymentId *string `location:"uri" locationName:"deployment_id" type:"string" required:"true"`

	// A query parameter to retrieve the specified embedded resources of the returned
	// Deployment resource in the response. In a REST API call, this embed parameter
	// value is a list of comma-separated strings, as in GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=var1,var2.
	// The SDK and other platform-dependent libraries might use a different format
	// for the list. Currently, this request supports only retrieval of the embedded
	// API summary this way. Hence, the parameter value must be a single-valued
	// list containing only the "apisummary" string. For example, GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=apisummary.
	Embed []string `location:"querystring" locationName:"embed" type:"list"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDeploymentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDeploymentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDeploymentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDeploymentInput"}

	if s.DeploymentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DeploymentId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDeploymentInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DeploymentId != nil {
		v := *s.DeploymentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "deployment_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Embed) > 0 {
		v := s.Embed

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.QueryTarget, "embed", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Requests API Gateway to get information about a Deployments collection.
type GetDeploymentsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDeploymentsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDeploymentsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDeploymentsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDeploymentsInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDeploymentsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection resource that contains zero or more references to
// your existing deployments, and links that guide you on how to interact with
// your collection. The collection offers a paginated view of the contained
// deployments.
//
// To create a new deployment of a RestApi, make a POST request against this
// resource. To view, update, or delete an existing deployment, make a GET,
// PATCH, or DELETE request, respectively, on a specified Deployment resource.
//
// Deploying an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html),
// AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html),
// AWS SDKs (https://aws.amazon.com/tools/)
type GetDeploymentsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateDeploymentOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetDeploymentsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDeploymentsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDeploymentsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDeploymentsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets a specified documentation part of a given API.
type GetDocumentationPartInput struct {
	_ struct{} `type:"structure"`

	// [Required] The string identifier of the associated RestApi.
	//
	// DocumentationPartId is a required field
	DocumentationPartId *string `location:"uri" locationName:"part_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDocumentationPartInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentationPartInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDocumentationPartInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDocumentationPartInput"}

	if s.DocumentationPartId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentationPartId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentationPartInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DocumentationPartId != nil {
		v := *s.DocumentationPartId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "part_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets the documentation parts of an API. The result may be filtered by the
// type, name, or path of API entities (targets).
type GetDocumentationPartsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The status of the API documentation parts to retrieve. Valid values are DOCUMENTED
	// for retrieving DocumentationPart resources with content and UNDOCUMENTED
	// for DocumentationPart resources without content.
	LocationStatus LocationStatusType `location:"querystring" locationName:"locationStatus" type:"string" enum:"true"`

	// The name of API entities of the to-be-retrieved documentation parts.
	NameQuery *string `location:"querystring" locationName:"name" type:"string"`

	// The path of API entities of the to-be-retrieved documentation parts.
	Path *string `location:"querystring" locationName:"path" type:"string"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// The type of API entities of the to-be-retrieved documentation parts.
	Type DocumentationPartType `location:"querystring" locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s GetDocumentationPartsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentationPartsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDocumentationPartsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDocumentationPartsInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentationPartsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if len(s.LocationStatus) > 0 {
		v := s.LocationStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "locationStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.NameQuery != nil {
		v := *s.NameQuery

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The collection of documentation parts of an API.
//
// Documenting an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), DocumentationPart
type GetDocumentationPartsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateDocumentationPartOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetDocumentationPartsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentationPartsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDocumentationPartsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentationPartsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets a documentation snapshot of an API.
type GetDocumentationVersionInput struct {
	_ struct{} `type:"structure"`

	// [Required] The version identifier of the to-be-retrieved documentation snapshot.
	//
	// DocumentationVersion is a required field
	DocumentationVersion *string `location:"uri" locationName:"doc_version" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDocumentationVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentationVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDocumentationVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDocumentationVersionInput"}

	if s.DocumentationVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentationVersion"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentationVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DocumentationVersion != nil {
		v := *s.DocumentationVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "doc_version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets the documentation versions of an API.
type GetDocumentationVersionsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDocumentationVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentationVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDocumentationVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDocumentationVersionsInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentationVersionsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The collection of documentation snapshots of an API.
//
// Use the DocumentationVersions to manage documentation snapshots associated
// with various API stages.
//
// Documenting an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html),
// DocumentationPart, DocumentationVersion
type GetDocumentationVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateDocumentationVersionOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetDocumentationVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDocumentationVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDocumentationVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDocumentationVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to get the name of a DomainName resource.
type GetDomainNameInput struct {
	_ struct{} `type:"structure"`

	// [Required] The name of the DomainName resource.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"domain_name" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDomainNameInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDomainNameInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDomainNameInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetDomainNameInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDomainNameInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "domain_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to describe a collection of DomainName resources.
type GetDomainNamesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetDomainNamesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDomainNamesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDomainNamesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection of DomainName resources.
//
// Use Client-Side Certificate (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
type GetDomainNamesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateDomainNameOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetDomainNamesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDomainNamesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetDomainNamesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetDomainNamesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request a new export of a RestApi for a particular Stage.
type GetExportInput struct {
	_ struct{} `type:"structure"`

	// The content-type of the export, for example application/json. Currently application/json
	// and application/yaml are supported for exportType ofoas30 and swagger. This
	// should be specified in the Accept header for direct API requests.
	Accepts *string `location:"header" locationName:"Accept" type:"string"`

	// [Required] The type of export. Acceptable values are 'oas30' for OpenAPI
	// 3.0.x and 'swagger' for Swagger/OpenAPI 2.0.
	//
	// ExportType is a required field
	ExportType *string `location:"uri" locationName:"export_type" type:"string" required:"true"`

	// A key-value map of query string parameters that specify properties of the
	// export, depending on the requested exportType. For exportTypeoas30 and swagger,
	// any combination of the following parameters are supported: extensions='integrations'
	// or extensions='apigateway' will export the API with x-amazon-apigateway-integration
	// extensions. extensions='authorizers' will export the API with x-amazon-apigateway-authorizer
	// extensions. postman will export the API with Postman extensions, allowing
	// for import to the Postman tool
	Parameters map[string]string `location:"querystring" locationName:"parameters" type:"map"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The name of the Stage that will be exported.
	//
	// StageName is a required field
	StageName *string `location:"uri" locationName:"stage_name" type:"string" required:"true"`
}

// String returns the string representation
func (s GetExportInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetExportInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetExportInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetExportInput"}

	if s.ExportType == nil {
		invalidParams.Add(aws.NewErrParamRequired("ExportType"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StageName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StageName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetExportInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Accepts != nil {
		v := *s.Accepts

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Accept", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ExportType != nil {
		v := *s.ExportType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "export_type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "stage_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.QueryTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// The binary blob response to GetExport, which contains the generated SDK.
type GetExportOutput struct {
	_ struct{} `type:"structure" payload:"Body"`

	responseMetadata aws.Response

	// The binary blob response to GetExport, which contains the export.
	Body []byte `locationName:"body" type:"blob"`

	// The content-disposition header value in the HTTP response.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// The content-type header value in the HTTP response. This will correspond
	// to a valid 'accept' type in the request.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`
}

// String returns the string representation
func (s GetExportOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetExportOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetExportOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetExportOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContentDisposition != nil {
		v := *s.ContentDisposition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Content-Disposition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Body != nil {
		v := s.Body

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "body", protocol.BytesStream(v), metadata)
	}
	return nil
}

// Gets a GatewayResponse of a specified response type on the given RestApi.
type GetGatewayResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] The response type of the associated GatewayResponse. Valid values
	// are ACCESS_DENIED
	// API_CONFIGURATION_ERROR
	// AUTHORIZER_FAILURE
	//  AUTHORIZER_CONFIGURATION_ERROR
	// BAD_REQUEST_PARAMETERS
	// BAD_REQUEST_BODY
	// DEFAULT_4XX
	// DEFAULT_5XX
	// EXPIRED_TOKEN
	// INVALID_SIGNATURE
	// INTEGRATION_FAILURE
	// INTEGRATION_TIMEOUT
	// INVALID_API_KEY
	// MISSING_AUTHENTICATION_TOKEN
	//  QUOTA_EXCEEDED
	// REQUEST_TOO_LARGE
	// RESOURCE_NOT_FOUND
	// THROTTLED
	// UNAUTHORIZED
	// UNSUPPORTED_MEDIA_TYPE
	//
	// ResponseType is a required field
	ResponseType GatewayResponseType `location:"uri" locationName:"response_type" type:"string" required:"true" enum:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetGatewayResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGatewayResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetGatewayResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetGatewayResponseInput"}
	if len(s.ResponseType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResponseType"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGatewayResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ResponseType) > 0 {
		v := s.ResponseType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "response_type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets the GatewayResponses collection on the given RestApi. If an API developer
// has not added any definitions for gateway responses, the result will be the
// API Gateway-generated default GatewayResponses collection for the supported
// response types.
type GetGatewayResponsesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500. The GatewayResponses collection does not support
	// pagination and the limit does not apply here.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set. The GatewayResponse
	// collection does not support pagination and the position does not apply here.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetGatewayResponsesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGatewayResponsesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetGatewayResponsesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetGatewayResponsesInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGatewayResponsesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The collection of the GatewayResponse instances of a RestApi as a responseType-to-GatewayResponse
// object map of key-value pairs. As such, pagination is not supported for querying
// this collection.
//
// For more information about valid gateway response types, see Gateway Response
// Types Supported by API Gateway (https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html)Example:
// Get the collection of gateway responses of an API
//
// Request
//
// This example request shows how to retrieve the GatewayResponses collection
// from an API.
//
// GET /restapis/o81lxisefl/gatewayresponses HTTP/1.1 Host: beta-apigateway.us-east-1.amazonaws.com
// Content-Type: application/json X-Amz-Date: 20170503T220604Z Authorization:
// AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request,
// SignedHeaders=content-type;host;x-amz-date, Signature=59b42fe54a76a5de8adf2c67baa6d39206f8e9ad49a1d77ccc6a5da3103a398a
// Cache-Control: no-cache Postman-Token: 5637af27-dc29-fc5c-9dfe-0645d52cb515
//
// Response
//
// The successful operation returns the 200 OK status code and a payload similar
// to the following:
//
// { "_links": { "curies": { "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html",
// "name": "gatewayresponse", "templated": true }, "self": { "href": "/restapis/o81lxisefl/gatewayresponses"
// }, "first": { "href": "/restapis/o81lxisefl/gatewayresponses" }, "gatewayresponse:by-type":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "item": [ { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE"
// }, { "href": "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND" },
// { "href": "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE" }, {
// "href": "/restapis/o81lxisefl/gatewayresponses/THROTTLED" }, { "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE"
// }, { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR"
// }, { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX" }, { "href":
// "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX" }, { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS"
// }, { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY" },
// { "href": "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN" }, { "href":
// "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED" }, { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY"
// }, { "href": "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED" }, { "href":
// "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR" }, { "href":
// "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED" }, { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT"
// }, { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
// }, { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE" },
// { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE" } ]
// }, "_embedded": { "item": [ { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "INTEGRATION_FAILURE", "statusCode": "504" }, { "_links": { "self": { "href":
// "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "RESOURCE_NOT_FOUND", "statusCode": "404" }, { "_links": { "self": { "href":
// "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "REQUEST_TOO_LARGE", "statusCode": "413" }, { "_links": { "self": { "href":
// "/restapis/o81lxisefl/gatewayresponses/THROTTLED" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/THROTTLED"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "THROTTLED", "statusCode": "429" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "UNSUPPORTED_MEDIA_TYPE", "statusCode": "415" }, { "_links": { "self": {
// "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "AUTHORIZER_CONFIGURATION_ERROR", "statusCode": "500" }, { "_links": { "self":
// { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "DEFAULT_5XX" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "DEFAULT_4XX" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "BAD_REQUEST_PARAMETERS", "statusCode": "400" }, { "_links": { "self": {
// "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "BAD_REQUEST_BODY", "statusCode": "400" }, { "_links": { "self": { "href":
// "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "EXPIRED_TOKEN", "statusCode": "403" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "ACCESS_DENIED", "statusCode": "403" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "INVALID_API_KEY", "statusCode": "403" }, { "_links": { "self": { "href":
// "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "UNAUTHORIZED", "statusCode": "401" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "API_CONFIGURATION_ERROR", "statusCode": "500" }, { "_links": { "self": {
// "href": "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "QUOTA_EXCEEDED", "statusCode": "429" }, { "_links": { "self": { "href":
// "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "INTEGRATION_TIMEOUT", "statusCode": "504" }, { "_links": { "self": { "href":
// "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "MISSING_AUTHENTICATION_TOKEN", "statusCode": "403" }, { "_links": { "self":
// { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "INVALID_SIGNATURE", "statusCode": "403" }, { "_links": { "self": { "href":
// "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE" }, "gatewayresponse:put":
// { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated":
// true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE"
// } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates":
// { "application/json": "{\"message\":$context.error.messageString}" }, "responseType":
// "AUTHORIZER_FAILURE", "statusCode": "500" } ] } }
//
// Customize Gateway Responses (https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html)
type GetGatewayResponsesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Returns the entire collection, because of no pagination support.
	Items []UpdateGatewayResponseOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetGatewayResponsesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGatewayResponsesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetGatewayResponsesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGatewayResponsesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a request to get the integration configuration.
type GetIntegrationInput struct {
	_ struct{} `type:"structure"`

	// [Required] Specifies a get integration request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] Specifies a get integration request's resource identifier
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetIntegrationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntegrationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetIntegrationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetIntegrationInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntegrationInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a get integration response request.
type GetIntegrationResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] Specifies a get integration response request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] Specifies a get integration response request's resource identifier.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] Specifies a get integration response request's status code.
	//
	// StatusCode is a required field
	StatusCode *string `location:"uri" locationName:"status_code" type:"string" required:"true"`
}

// String returns the string representation
func (s GetIntegrationResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetIntegrationResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetIntegrationResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetIntegrationResponseInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StatusCode == nil {
		invalidParams.Add(aws.NewErrParamRequired("StatusCode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetIntegrationResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "status_code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to describe an existing Method resource.
type GetMethodInput struct {
	_ struct{} `type:"structure"`

	// [Required] Specifies the method request's HTTP method type.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] The Resource identifier for the Method resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetMethodInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMethodInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetMethodInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetMethodInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetMethodInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to describe a MethodResponse resource.
type GetMethodResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] The HTTP verb of the Method resource.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] The Resource identifier for the MethodResponse resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The status code for the MethodResponse resource.
	//
	// StatusCode is a required field
	StatusCode *string `location:"uri" locationName:"status_code" type:"string" required:"true"`
}

// String returns the string representation
func (s GetMethodResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMethodResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetMethodResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetMethodResponseInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StatusCode == nil {
		invalidParams.Add(aws.NewErrParamRequired("StatusCode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetMethodResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "status_code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to list information about a model in an existing RestApi resource.
type GetModelInput struct {
	_ struct{} `type:"structure"`

	// A query parameter of a Boolean value to resolve (true) all external model
	// references and returns a flattened model schema or not (false) The default
	// is false.
	Flatten *bool `location:"querystring" locationName:"flatten" type:"boolean"`

	// [Required] The name of the model as an identifier.
	//
	// ModelName is a required field
	ModelName *string `location:"uri" locationName:"model_name" type:"string" required:"true"`

	// [Required] The RestApi identifier under which the Model exists.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetModelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetModelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetModelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetModelInput"}

	if s.ModelName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ModelName"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetModelInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ModelName != nil {
		v := *s.ModelName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "model_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Flatten != nil {
		v := *s.Flatten

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "flatten", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Request to generate a sample mapping template used to transform the payload.
type GetModelTemplateInput struct {
	_ struct{} `type:"structure"`

	// [Required] The name of the model for which to generate a template.
	//
	// ModelName is a required field
	ModelName *string `location:"uri" locationName:"model_name" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetModelTemplateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetModelTemplateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetModelTemplateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetModelTemplateInput"}

	if s.ModelName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ModelName"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetModelTemplateInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ModelName != nil {
		v := *s.ModelName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "model_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a mapping template used to transform a payload.
//
// Mapping Templates (https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html#models-mappings-mappings)
type GetModelTemplateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Apache Velocity Template Language (VTL) (https://velocity.apache.org/engine/devel/vtl-reference-guide.html)
	// template content used for the template resource.
	Value *string `locationName:"value" type:"string"`
}

// String returns the string representation
func (s GetModelTemplateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetModelTemplateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetModelTemplateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetModelTemplateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to list existing Models defined for a RestApi resource.
type GetModelsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetModelsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetModelsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetModelsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetModelsInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetModelsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection of Model resources.
//
// Method, MethodResponse, Models and Mappings (https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html)
type GetModelsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateModelOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetModelsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetModelsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetModelsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetModelsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets a RequestValidator of a given RestApi.
type GetRequestValidatorInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the RequestValidator to be retrieved.
	//
	// RequestValidatorId is a required field
	RequestValidatorId *string `location:"uri" locationName:"requestvalidator_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetRequestValidatorInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRequestValidatorInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetRequestValidatorInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetRequestValidatorInput"}

	if s.RequestValidatorId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestValidatorId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRequestValidatorInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RequestValidatorId != nil {
		v := *s.RequestValidatorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "requestvalidator_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets the RequestValidators collection of a given RestApi.
type GetRequestValidatorsInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetRequestValidatorsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRequestValidatorsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetRequestValidatorsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetRequestValidatorsInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRequestValidatorsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A collection of RequestValidator resources of a given RestApi.
//
// In OpenAPI, the RequestValidators of an API is defined by the x-amazon-apigateway-request-validators
// (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.html)
// extension.
//
// Enable Basic Request Validation in API Gateway (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html)
type GetRequestValidatorsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateRequestValidatorOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetRequestValidatorsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRequestValidatorsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetRequestValidatorsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRequestValidatorsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to list information about a resource.
type GetResourceInput struct {
	_ struct{} `type:"structure"`

	// A query parameter to retrieve the specified resources embedded in the returned
	// Resource representation in the response. This embed parameter value is a
	// list of comma-separated strings. Currently, the request supports only retrieval
	// of the embedded Method resources this way. The query parameter value must
	// be a single-valued list and contain the "methods" string. For example, GET
	// /restapis/{restapi_id}/resources/{resource_id}?embed=methods.
	Embed []string `location:"querystring" locationName:"embed" type:"list"`

	// [Required] The identifier for the Resource resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetResourceInput"}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Embed) > 0 {
		v := s.Embed

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.QueryTarget, "embed", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Request to list information about a collection of resources.
type GetResourcesInput struct {
	_ struct{} `type:"structure"`

	// A query parameter used to retrieve the specified resources embedded in the
	// returned Resources resource in the response. This embed parameter value is
	// a list of comma-separated strings. Currently, the request supports only retrieval
	// of the embedded Method resources this way. The query parameter value must
	// be a single-valued list and contain the "methods" string. For example, GET
	// /restapis/{restapi_id}/resources?embed=methods.
	Embed []string `location:"querystring" locationName:"embed" type:"list"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetResourcesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetResourcesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetResourcesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetResourcesInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetResourcesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Embed) > 0 {
		v := s.Embed

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.QueryTarget, "embed", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection of Resource resources.
//
// Create an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
type GetResourcesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateResourceOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetResourcesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetResourcesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetResourcesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetResourcesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The GET request to list an existing RestApi defined for your collection.
type GetRestApiInput struct {
	_ struct{} `type:"structure"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetRestApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRestApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetRestApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetRestApiInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRestApiInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The GET request to list existing RestApis defined for your collection.
type GetRestApisInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetRestApisInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRestApisInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRestApisInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Contains references to your APIs and links that guide you in how to interact
// with your collection. A collection offers a paginated view of your APIs.
//
// Create an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
type GetRestApisOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateRestApiOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetRestApisOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRestApisOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetRestApisOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetRestApisOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request a new generated client SDK for a RestApi and Stage.
type GetSdkInput struct {
	_ struct{} `type:"structure"`

	// A string-to-string key-value map of query parameters sdkType-dependent properties
	// of the SDK. For sdkType of objectivec or swift, a parameter named classPrefix
	// is required. For sdkType of android, parameters named groupId, artifactId,
	// artifactVersion, and invokerPackage are required. For sdkType of java, parameters
	// named serviceName and javaPackageName are required.
	Parameters map[string]string `location:"querystring" locationName:"parameters" type:"map"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The language for the generated SDK. Currently java, javascript,
	// android, objectivec (for iOS), swift (for iOS), and ruby are supported.
	//
	// SdkType is a required field
	SdkType *string `location:"uri" locationName:"sdk_type" type:"string" required:"true"`

	// [Required] The name of the Stage that the SDK will use.
	//
	// StageName is a required field
	StageName *string `location:"uri" locationName:"stage_name" type:"string" required:"true"`
}

// String returns the string representation
func (s GetSdkInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSdkInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSdkInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSdkInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.SdkType == nil {
		invalidParams.Add(aws.NewErrParamRequired("SdkType"))
	}

	if s.StageName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StageName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSdkInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.SdkType != nil {
		v := *s.SdkType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "sdk_type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "stage_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.QueryTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// The binary blob response to GetSdk, which contains the generated SDK.
type GetSdkOutput struct {
	_ struct{} `type:"structure" payload:"Body"`

	responseMetadata aws.Response

	// The binary blob response to GetSdk, which contains the generated SDK.
	Body []byte `locationName:"body" type:"blob"`

	// The content-disposition header value in the HTTP response.
	ContentDisposition *string `location:"header" locationName:"Content-Disposition" type:"string"`

	// The content-type header value in the HTTP response.
	ContentType *string `location:"header" locationName:"Content-Type" type:"string"`
}

// String returns the string representation
func (s GetSdkOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSdkOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSdkOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSdkOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContentDisposition != nil {
		v := *s.ContentDisposition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Content-Disposition", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Content-Type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Body != nil {
		v := s.Body

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "body", protocol.BytesStream(v), metadata)
	}
	return nil
}

// Get an SdkType instance.
type GetSdkTypeInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the queried SdkType instance.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"sdktype_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetSdkTypeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSdkTypeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetSdkTypeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetSdkTypeInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSdkTypeInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "sdktype_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A type of SDK that API Gateway can generate.
type GetSdkTypeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of configuration properties of an SdkType.
	ConfigurationProperties []SdkConfigurationProperty `locationName:"configurationProperties" type:"list"`

	// The description of an SdkType.
	Description *string `locationName:"description" type:"string"`

	// The user-friendly name of an SdkType instance.
	FriendlyName *string `locationName:"friendlyName" type:"string"`

	// The identifier of an SdkType instance.
	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s GetSdkTypeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSdkTypeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSdkTypeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSdkTypeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ConfigurationProperties) > 0 {
		v := s.ConfigurationProperties

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "configurationProperties", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FriendlyName != nil {
		v := *s.FriendlyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "friendlyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Get the SdkTypes collection.
type GetSdkTypesInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetSdkTypesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSdkTypesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSdkTypesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The collection of SdkType instances.
type GetSdkTypesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []GetSdkTypeOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetSdkTypesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetSdkTypesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetSdkTypesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetSdkTypesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to get information about a Stage resource.
type GetStageInput struct {
	_ struct{} `type:"structure"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The name of the Stage resource to get information about.
	//
	// StageName is a required field
	StageName *string `location:"uri" locationName:"stage_name" type:"string" required:"true"`
}

// String returns the string representation
func (s GetStageInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetStageInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetStageInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetStageInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StageName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StageName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetStageInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "stage_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to get information about one or more Stage resources.
type GetStagesInput struct {
	_ struct{} `type:"structure"`

	// The stages' deployment identifiers.
	DeploymentId *string `location:"querystring" locationName:"deploymentId" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetStagesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetStagesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetStagesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetStagesInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetStagesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DeploymentId != nil {
		v := *s.DeploymentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "deploymentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A list of Stage resources that are associated with the ApiKey resource.
//
// Deploying API in Stages (https://docs.aws.amazon.com/apigateway/latest/developerguide/stages.html)
type GetStagesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Item []UpdateStageOutput `locationName:"item" type:"list"`
}

// String returns the string representation
func (s GetStagesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetStagesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetStagesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetStagesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Item) > 0 {
		v := s.Item

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Gets the Tags collection for a given resource.
type GetTagsInput struct {
	_ struct{} `type:"structure"`

	// (Not currently supported) The maximum number of returned results per page.
	// The default value is 25 and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// (Not currently supported) The current pagination position in the paged result
	// set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The ARN of a resource that can be tagged. The resource ARN must
	// be URL-encoded. At present, Stage is the only taggable resource.
	//
	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resource_arn" type:"string" required:"true"`
}

// String returns the string representation
func (s GetTagsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTagsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTagsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTagsInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTagsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The collection of tags. Each tag element is associated with a given resource.
type GetTagsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The collection of tags. Each tag element is associated with a given resource.
	Tags map[string]string `locationName:"tags" type:"map"`
}

// String returns the string representation
func (s GetTagsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTagsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTagsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTagsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// The GET request to get the usage data of a usage plan in a specified time
// interval.
type GetUsageInput struct {
	_ struct{} `type:"structure"`

	// [Required] The ending date (e.g., 2016-12-31) of the usage data.
	//
	// EndDate is a required field
	EndDate *string `location:"querystring" locationName:"endDate" type:"string" required:"true"`

	// The Id of the API key associated with the resultant usage data.
	KeyId *string `location:"querystring" locationName:"keyId" type:"string"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The starting date (e.g., 2016-01-01) of the usage data.
	//
	// StartDate is a required field
	StartDate *string `location:"querystring" locationName:"startDate" type:"string" required:"true"`

	// [Required] The Id of the usage plan associated with the usage data.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetUsageInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUsageInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetUsageInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetUsageInput"}

	if s.EndDate == nil {
		invalidParams.Add(aws.NewErrParamRequired("EndDate"))
	}

	if s.StartDate == nil {
		invalidParams.Add(aws.NewErrParamRequired("StartDate"))
	}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUsageInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EndDate != nil {
		v := *s.EndDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "endDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "keyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartDate != nil {
		v := *s.StartDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "startDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The GET request to get a usage plan of a given plan identifier.
type GetUsagePlanInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the UsagePlan resource to be retrieved.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetUsagePlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUsagePlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetUsagePlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetUsagePlanInput"}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUsagePlanInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The GET request to get a usage plan key of a given key identifier.
type GetUsagePlanKeyInput struct {
	_ struct{} `type:"structure"`

	// [Required] The key Id of the to-be-retrieved UsagePlanKey resource representing
	// a plan customer.
	//
	// KeyId is a required field
	KeyId *string `location:"uri" locationName:"keyId" type:"string" required:"true"`

	// [Required] The Id of the UsagePlan resource representing the usage plan containing
	// the to-be-retrieved UsagePlanKey resource representing a plan customer.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetUsagePlanKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUsagePlanKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetUsagePlanKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetUsagePlanKeyInput"}

	if s.KeyId == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeyId"))
	}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUsagePlanKeyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "keyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a usage plan key to identify a plan customer.
//
// To associate an API stage with a selected API key in a usage plan, you must
// create a UsagePlanKey resource to represent the selected ApiKey.
//
// " Create and Use Usage Plans (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
type GetUsagePlanKeyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Id of a usage plan key.
	Id *string `locationName:"id" type:"string"`

	// The name of a usage plan key.
	Name *string `locationName:"name" type:"string"`

	// The type of a usage plan key. Currently, the valid key type is API_KEY.
	Type *string `locationName:"type" type:"string"`

	// The value of a usage plan key.
	Value *string `locationName:"value" type:"string"`
}

// String returns the string representation
func (s GetUsagePlanKeyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUsagePlanKeyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetUsagePlanKeyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUsagePlanKeyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Type != nil {
		v := *s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The GET request to get all the usage plan keys representing the API keys
// added to a specified usage plan.
type GetUsagePlanKeysInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// A query parameter specifying the name of the to-be-returned usage plan keys.
	NameQuery *string `location:"querystring" locationName:"name" type:"string"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`

	// [Required] The Id of the UsagePlan resource representing the usage plan containing
	// the to-be-retrieved UsagePlanKey resource representing a plan customer.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetUsagePlanKeysInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUsagePlanKeysInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetUsagePlanKeysInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetUsagePlanKeysInput"}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUsagePlanKeysInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.NameQuery != nil {
		v := *s.NameQuery

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the collection of usage plan keys added to usage plans for the
// associated API keys and, possibly, other types of keys.
//
// Create and Use Usage Plans (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
type GetUsagePlanKeysOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []GetUsagePlanKeyOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetUsagePlanKeysOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUsagePlanKeysOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetUsagePlanKeysOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUsagePlanKeysOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The GET request to get all the usage plans of the caller's account.
type GetUsagePlansInput struct {
	_ struct{} `type:"structure"`

	// The identifier of the API key associated with the usage plans.
	KeyId *string `location:"querystring" locationName:"keyId" type:"string"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetUsagePlansInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUsagePlansInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUsagePlansInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "keyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a collection of usage plans for an AWS account.
//
// Create and Use Usage Plans (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
type GetUsagePlansOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateUsagePlanOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetUsagePlansOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetUsagePlansOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetUsagePlansOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetUsagePlansOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets a specified VPC link under the caller's account in a region.
type GetVpcLinkInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the VpcLink. It is used in an Integration to
	// reference this VpcLink.
	//
	// VpcLinkId is a required field
	VpcLinkId *string `location:"uri" locationName:"vpclink_id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetVpcLinkInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVpcLinkInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetVpcLinkInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetVpcLinkInput"}

	if s.VpcLinkId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VpcLinkId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVpcLinkInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.VpcLinkId != nil {
		v := *s.VpcLinkId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vpclink_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Gets the VpcLinks collection under the caller's account in a selected region.
type GetVpcLinksInput struct {
	_ struct{} `type:"structure"`

	// The maximum number of returned results per page. The default value is 25
	// and the maximum value is 500.
	Limit *int64 `location:"querystring" locationName:"limit" type:"integer"`

	// The current pagination position in the paged result set.
	Position *string `location:"querystring" locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetVpcLinksInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVpcLinksInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVpcLinksInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The collection of VPC links under the caller's account in a region.
//
// Getting Started with Private Integrations (https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-private-integration.html),
// Set up Private Integrations (https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-private-integration.html)
type GetVpcLinksOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current page of elements from this collection.
	Items []UpdateVpcLinkOutput `locationName:"item" type:"list"`

	Position *string `locationName:"position" type:"string"`
}

// String returns the string representation
func (s GetVpcLinksOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetVpcLinksOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetVpcLinksOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetVpcLinksOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "item", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The POST request to import API keys from an external source, such as a CSV-formatted
// file.
type ImportApiKeysInput struct {
	_ struct{} `type:"structure" payload:"Body"`

	// The payload of the POST request to import API keys. For the payload format,
	// see API Key File Format (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-key-file-format.html).
	//
	// Body is a required field
	Body []byte `locationName:"body" type:"blob" required:"true"`

	// A query parameter to indicate whether to rollback ApiKey importation (true)
	// or not (false) when error is encountered.
	FailOnWarnings *bool `location:"querystring" locationName:"failonwarnings" type:"boolean"`

	// A query parameter to specify the input format to imported API keys. Currently,
	// only the csv format is supported.
	//
	// Format is a required field
	Format ApiKeysFormat `location:"querystring" locationName:"format" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s ImportApiKeysInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ImportApiKeysInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ImportApiKeysInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ImportApiKeysInput"}

	if s.Body == nil {
		invalidParams.Add(aws.NewErrParamRequired("Body"))
	}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ImportApiKeysInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Body != nil {
		v := s.Body

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "body", protocol.BytesStream(v), metadata)
	}
	if s.FailOnWarnings != nil {
		v := *s.FailOnWarnings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "failonwarnings", protocol.BoolValue(v), metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "format", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// The identifier of an ApiKey used in a UsagePlan.
type ImportApiKeysOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of all the ApiKey identifiers.
	Ids []string `locationName:"ids" type:"list"`

	// A list of warning messages.
	Warnings []string `locationName:"warnings" type:"list"`
}

// String returns the string representation
func (s ImportApiKeysOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ImportApiKeysOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ImportApiKeysOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ImportApiKeysOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Ids) > 0 {
		v := s.Ids

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ids", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Warnings) > 0 {
		v := s.Warnings

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "warnings", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Import documentation parts from an external (e.g., OpenAPI) definition file.
type ImportDocumentationPartsInput struct {
	_ struct{} `type:"structure" payload:"Body"`

	// [Required] Raw byte array representing the to-be-imported documentation parts.
	// To import from an OpenAPI file, this is a JSON object.
	//
	// Body is a required field
	Body []byte `locationName:"body" type:"blob" required:"true"`

	// A query parameter to specify whether to rollback the documentation importation
	// (true) or not (false) when a warning is encountered. The default value is
	// false.
	FailOnWarnings *bool `location:"querystring" locationName:"failonwarnings" type:"boolean"`

	// A query parameter to indicate whether to overwrite (OVERWRITE) any existing
	// DocumentationParts definition or to merge (MERGE) the new definition into
	// the existing one. The default value is MERGE.
	Mode PutMode `location:"querystring" locationName:"mode" type:"string" enum:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s ImportDocumentationPartsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ImportDocumentationPartsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ImportDocumentationPartsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ImportDocumentationPartsInput"}

	if s.Body == nil {
		invalidParams.Add(aws.NewErrParamRequired("Body"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ImportDocumentationPartsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Body != nil {
		v := s.Body

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "body", protocol.BytesStream(v), metadata)
	}
	if s.FailOnWarnings != nil {
		v := *s.FailOnWarnings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "failonwarnings", protocol.BoolValue(v), metadata)
	}
	if len(s.Mode) > 0 {
		v := s.Mode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "mode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// A collection of the imported DocumentationPart identifiers.
//
// This is used to return the result when documentation parts in an external
// (e.g., OpenAPI) file are imported into API Gateway
// Documenting an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html),
// documentationpart:import (https://docs.aws.amazon.com/apigateway/api-reference/link-relation/documentationpart-import/),
// DocumentationPart
type ImportDocumentationPartsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of the returned documentation part identifiers.
	Ids []string `locationName:"ids" type:"list"`

	// A list of warning messages reported during import of documentation parts.
	Warnings []string `locationName:"warnings" type:"list"`
}

// String returns the string representation
func (s ImportDocumentationPartsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ImportDocumentationPartsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ImportDocumentationPartsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ImportDocumentationPartsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Ids) > 0 {
		v := s.Ids

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "ids", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Warnings) > 0 {
		v := s.Warnings

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "warnings", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// A POST request to import an API to API Gateway using an input of an API definition
// file.
type ImportRestApiInput struct {
	_ struct{} `type:"structure" payload:"Body"`

	// [Required] The POST request body containing external API definitions. Currently,
	// only OpenAPI definition JSON/YAML files are supported. The maximum size of
	// the API definition file is 2MB.
	//
	// Body is a required field
	Body []byte `locationName:"body" type:"blob" required:"true"`

	// A query parameter to indicate whether to rollback the API creation (true)
	// or not (false) when a warning is encountered. The default value is false.
	FailOnWarnings *bool `location:"querystring" locationName:"failonwarnings" type:"boolean"`

	// A key-value map of context-specific query string parameters specifying the
	// behavior of different API importing operations. The following shows operation-specific
	// parameters and their supported values.
	//
	// To exclude DocumentationParts from the import, set parameters as ignore=documentation.
	//
	// To configure the endpoint type, set parameters as endpointConfigurationTypes=EDGE,
	// endpointConfigurationTypes=REGIONAL, or endpointConfigurationTypes=PRIVATE.
	// The default endpoint type is EDGE.
	//
	// To handle imported basePath, set parameters as basePath=ignore, basePath=prepend
	// or basePath=split.
	//
	// For example, the AWS CLI command to exclude documentation from the imported
	// API is:
	//
	//    aws apigateway import-rest-api --parameters ignore=documentation --body
	//    'file:///path/to/imported-api-body.json'
	// The AWS CLI command to set the regional endpoint on the imported API is:
	//
	//    aws apigateway import-rest-api --parameters endpointConfigurationTypes=REGIONAL
	//    --body 'file:///path/to/imported-api-body.json'
	Parameters map[string]string `location:"querystring" locationName:"parameters" type:"map"`
}

// String returns the string representation
func (s ImportRestApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ImportRestApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ImportRestApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ImportRestApiInput"}

	if s.Body == nil {
		invalidParams.Add(aws.NewErrParamRequired("Body"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ImportRestApiInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Body != nil {
		v := s.Body

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "body", protocol.BytesStream(v), metadata)
	}
	if s.FailOnWarnings != nil {
		v := *s.FailOnWarnings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "failonwarnings", protocol.BoolValue(v), metadata)
	}
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.QueryTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Specifies the method setting properties.
type MethodSetting struct {
	_ struct{} `type:"structure"`

	// Specifies whether the cached responses are encrypted. The PATCH path for
	// this setting is /{method_setting_key}/caching/dataEncrypted, and the value
	// is a Boolean.
	CacheDataEncrypted *bool `locationName:"cacheDataEncrypted" type:"boolean"`

	// Specifies the time to live (TTL), in seconds, for cached responses. The higher
	// the TTL, the longer the response will be cached. The PATCH path for this
	// setting is /{method_setting_key}/caching/ttlInSeconds, and the value is an
	// integer.
	CacheTtlInSeconds *int64 `locationName:"cacheTtlInSeconds" type:"integer"`

	// Specifies whether responses should be cached and returned for requests. A
	// cache cluster must be enabled on the stage for responses to be cached. The
	// PATCH path for this setting is /{method_setting_key}/caching/enabled, and
	// the value is a Boolean.
	CachingEnabled *bool `locationName:"cachingEnabled" type:"boolean"`

	// Specifies whether data trace logging is enabled for this method, which affects
	// the log entries pushed to Amazon CloudWatch Logs. The PATCH path for this
	// setting is /{method_setting_key}/logging/dataTrace, and the value is a Boolean.
	DataTraceEnabled *bool `locationName:"dataTraceEnabled" type:"boolean"`

	// Specifies the logging level for this method, which affects the log entries
	// pushed to Amazon CloudWatch Logs. The PATCH path for this setting is /{method_setting_key}/logging/loglevel,
	// and the available levels are OFF, ERROR, and INFO.
	LoggingLevel *string `locationName:"loggingLevel" type:"string"`

	// Specifies whether Amazon CloudWatch metrics are enabled for this method.
	// The PATCH path for this setting is /{method_setting_key}/metrics/enabled,
	// and the value is a Boolean.
	MetricsEnabled *bool `locationName:"metricsEnabled" type:"boolean"`

	// Specifies whether authorization is required for a cache invalidation request.
	// The PATCH path for this setting is /{method_setting_key}/caching/requireAuthorizationForCacheControl,
	// and the value is a Boolean.
	RequireAuthorizationForCacheControl *bool `locationName:"requireAuthorizationForCacheControl" type:"boolean"`

	// Specifies the throttling burst limit. The PATCH path for this setting is
	// /{method_setting_key}/throttling/burstLimit, and the value is an integer.
	ThrottlingBurstLimit *int64 `locationName:"throttlingBurstLimit" type:"integer"`

	// Specifies the throttling rate limit. The PATCH path for this setting is /{method_setting_key}/throttling/rateLimit,
	// and the value is a double.
	ThrottlingRateLimit *float64 `locationName:"throttlingRateLimit" type:"double"`

	// Specifies how to handle unauthorized requests for cache invalidation. The
	// PATCH path for this setting is /{method_setting_key}/caching/unauthorizedCacheControlHeaderStrategy,
	// and the available values are FAIL_WITH_403, SUCCEED_WITH_RESPONSE_HEADER,
	// SUCCEED_WITHOUT_RESPONSE_HEADER.
	UnauthorizedCacheControlHeaderStrategy UnauthorizedCacheControlHeaderStrategy `locationName:"unauthorizedCacheControlHeaderStrategy" type:"string" enum:"true"`
}

// String returns the string representation
func (s MethodSetting) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MethodSetting) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MethodSetting) MarshalFields(e protocol.FieldEncoder) error {
	if s.CacheDataEncrypted != nil {
		v := *s.CacheDataEncrypted

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheDataEncrypted", protocol.BoolValue(v), metadata)
	}
	if s.CacheTtlInSeconds != nil {
		v := *s.CacheTtlInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheTtlInSeconds", protocol.Int64Value(v), metadata)
	}
	if s.CachingEnabled != nil {
		v := *s.CachingEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cachingEnabled", protocol.BoolValue(v), metadata)
	}
	if s.DataTraceEnabled != nil {
		v := *s.DataTraceEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "dataTraceEnabled", protocol.BoolValue(v), metadata)
	}
	if s.LoggingLevel != nil {
		v := *s.LoggingLevel

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "loggingLevel", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MetricsEnabled != nil {
		v := *s.MetricsEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "metricsEnabled", protocol.BoolValue(v), metadata)
	}
	if s.RequireAuthorizationForCacheControl != nil {
		v := *s.RequireAuthorizationForCacheControl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "requireAuthorizationForCacheControl", protocol.BoolValue(v), metadata)
	}
	if s.ThrottlingBurstLimit != nil {
		v := *s.ThrottlingBurstLimit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "throttlingBurstLimit", protocol.Int64Value(v), metadata)
	}
	if s.ThrottlingRateLimit != nil {
		v := *s.ThrottlingRateLimit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "throttlingRateLimit", protocol.Float64Value(v), metadata)
	}
	if len(s.UnauthorizedCacheControlHeaderStrategy) > 0 {
		v := s.UnauthorizedCacheControlHeaderStrategy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "unauthorizedCacheControlHeaderStrategy", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// Represents a summary of a Method resource, given a particular date and time.
type MethodSnapshot struct {
	_ struct{} `type:"structure"`

	// Specifies whether the method requires a valid ApiKey.
	ApiKeyRequired *bool `locationName:"apiKeyRequired" type:"boolean"`

	// The method's authorization type. Valid values are NONE for open access, AWS_IAM
	// for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS
	// for using a Cognito user pool.
	AuthorizationType *string `locationName:"authorizationType" type:"string"`
}

// String returns the string representation
func (s MethodSnapshot) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MethodSnapshot) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s MethodSnapshot) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApiKeyRequired != nil {
		v := *s.ApiKeyRequired

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "apiKeyRequired", protocol.BoolValue(v), metadata)
	}
	if s.AuthorizationType != nil {
		v := *s.AuthorizationType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizationType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A single patch operation to apply to the specified resource. Please refer
// to http://tools.ietf.org/html/rfc6902#section-4 for an explanation of how
// each operation is used.
type PatchOperation struct {
	_ struct{} `type:"structure"`

	// The copy update operation's source as identified by a JSON-Pointer value
	// referencing the location within the targeted resource to copy the value from.
	// For example, to promote a canary deployment, you copy the canary deployment
	// ID to the affiliated deployment ID by calling a PATCH request on a Stage
	// resource with "op":"copy", "from":"/canarySettings/deploymentId" and "path":"/deploymentId".
	From *string `locationName:"from" type:"string"`

	// An update operation to be performed with this PATCH request. The valid value
	// can be add, remove, replace or copy. Not all valid operations are supported
	// for a given resource. Support of the operations depends on specific operational
	// contexts. Attempts to apply an unsupported operation on a resource will return
	// an error message.
	Op Op `locationName:"op" type:"string" enum:"true"`

	// The op operation's target, as identified by a JSON Pointer (https://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-08)
	// value that references a location within the targeted resource. For example,
	// if the target resource has an updateable property of {"name":"value"}, the
	// path for this property is /name. If the name property value is a JSON object
	// (e.g., {"name": {"child/name": "child-value"}}), the path for the child/name
	// property will be /name/child~1name. Any slash ("/") character appearing in
	// path names must be escaped with "~1", as shown in the example above. Each
	// op operation can have only one path associated with it.
	Path *string `locationName:"path" type:"string"`

	// The new target value of the update operation. It is applicable for the add
	// or replace operation. When using AWS CLI to update a property of a JSON value,
	// enclose the JSON object with a pair of single quotes in a Linux shell, e.g.,
	// '{"a": ...}'. In a Windows shell, see Using JSON for Parameters (https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json).
	Value *string `locationName:"value" type:"string"`
}

// String returns the string representation
func (s PatchOperation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PatchOperation) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PatchOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.From != nil {
		v := *s.From

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "from", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Op) > 0 {
		v := s.Op

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "op", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Creates a customization of a GatewayResponse of a specified response type
// and status code on the given RestApi.
type PutGatewayResponseInput struct {
	_ struct{} `type:"structure"`

	// Response parameters (paths, query strings and headers) of the GatewayResponse
	// as a string-to-string map of key-value pairs.
	ResponseParameters map[string]string `locationName:"responseParameters" type:"map"`

	// Response templates of the GatewayResponse as a string-to-string map of key-value
	// pairs.
	ResponseTemplates map[string]string `locationName:"responseTemplates" type:"map"`

	// [Required] The response type of the associated GatewayResponse. Valid values
	// are ACCESS_DENIED
	// API_CONFIGURATION_ERROR
	// AUTHORIZER_FAILURE
	//  AUTHORIZER_CONFIGURATION_ERROR
	// BAD_REQUEST_PARAMETERS
	// BAD_REQUEST_BODY
	// DEFAULT_4XX
	// DEFAULT_5XX
	// EXPIRED_TOKEN
	// INVALID_SIGNATURE
	// INTEGRATION_FAILURE
	// INTEGRATION_TIMEOUT
	// INVALID_API_KEY
	// MISSING_AUTHENTICATION_TOKEN
	//  QUOTA_EXCEEDED
	// REQUEST_TOO_LARGE
	// RESOURCE_NOT_FOUND
	// THROTTLED
	// UNAUTHORIZED
	// UNSUPPORTED_MEDIA_TYPE
	//
	// ResponseType is a required field
	ResponseType GatewayResponseType `location:"uri" locationName:"response_type" type:"string" required:"true" enum:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// The HTTP status code of the GatewayResponse
	StatusCode *string `locationName:"statusCode" type:"string"`
}

// String returns the string representation
func (s PutGatewayResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutGatewayResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutGatewayResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutGatewayResponseInput"}
	if len(s.ResponseType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResponseType"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutGatewayResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ResponseParameters) > 0 {
		v := s.ResponseParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.ResponseTemplates) > 0 {
		v := s.ResponseTemplates

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseTemplates", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResponseType) > 0 {
		v := s.ResponseType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "response_type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Sets up a method's integration.
type PutIntegrationInput struct {
	_ struct{} `type:"structure"`

	// Specifies a put integration input's cache key parameters.
	CacheKeyParameters []string `locationName:"cacheKeyParameters" type:"list"`

	// Specifies a put integration input's cache namespace.
	CacheNamespace *string `locationName:"cacheNamespace" type:"string"`

	// The (id (https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id))
	// of the VpcLink used for the integration when connectionType=VPC_LINK and
	// undefined, otherwise.
	ConnectionId *string `locationName:"connectionId" type:"string"`

	// The type of the network connection to the integration endpoint. The valid
	// value is INTERNET for connections through the public routable internet or
	// VPC_LINK for private connections between API Gateway and a network load balancer
	// in a VPC. The default value is INTERNET.
	ConnectionType ConnectionType `locationName:"connectionType" type:"string" enum:"true"`

	// Specifies how to handle request payload content type conversions. Supported
	// values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
	//
	//    * CONVERT_TO_BINARY: Converts a request payload from a Base64-encoded
	//    string to the corresponding binary blob.
	//
	//    * CONVERT_TO_TEXT: Converts a request payload from a binary blob to a
	//    Base64-encoded string.
	//
	// If this property is not defined, the request payload will be passed through
	// from the method request to integration request without modification, provided
	// that the passthroughBehaviors is configured to support payload pass-through.
	ContentHandling ContentHandlingStrategy `locationName:"contentHandling" type:"string" enum:"true"`

	// Specifies whether credentials are required for a put integration.
	Credentials *string `locationName:"credentials" type:"string"`

	// [Required] Specifies a put integration request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// Specifies a put integration HTTP method. When the integration type is HTTP
	// or AWS, this field is required.
	IntegrationHttpMethod *string `locationName:"httpMethod" type:"string"`

	// Specifies the pass-through behavior for incoming requests based on the Content-Type
	// header in the request, and the available mapping templates specified as the
	// requestTemplates property on the Integration resource. There are three valid
	// values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.
	//
	//    * WHEN_NO_MATCH passes the request body for unmapped content types through
	//    to the integration back end without transformation.
	//
	//    * NEVER rejects unmapped content types with an HTTP 415 'Unsupported Media
	//    Type' response.
	//
	//    * WHEN_NO_TEMPLATES allows pass-through when the integration has NO content
	//    types mapped to templates. However if there is at least one content type
	//    defined, unmapped content types will be rejected with the same 415 response.
	PassthroughBehavior *string `locationName:"passthroughBehavior" type:"string"`

	// A key-value map specifying request parameters that are passed from the method
	// request to the back end. The key is an integration request parameter name
	// and the associated value is a method request parameter value or static value
	// that must be enclosed within single quotes and pre-encoded as required by
	// the back end. The method request parameter value must match the pattern of
	// method.request.{location}.{name}, where location is querystring, path, or
	// header and name must be a valid and unique method request parameter name.
	RequestParameters map[string]string `locationName:"requestParameters" type:"map"`

	// Represents a map of Velocity templates that are applied on the request payload
	// based on the value of the Content-Type header sent by the client. The content
	// type value is the key in this map, and the template (as a String) is the
	// value.
	RequestTemplates map[string]string `locationName:"requestTemplates" type:"map"`

	// [Required] Specifies a put integration request's resource ID.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000
	// milliseconds or 29 seconds.
	TimeoutInMillis *int64 `locationName:"timeoutInMillis" type:"integer"`

	// [Required] Specifies a put integration input's type.
	//
	// Type is a required field
	Type IntegrationType `locationName:"type" type:"string" required:"true" enum:"true"`

	// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
	//
	//    *  For HTTP or HTTP_PROXY integrations, the URI must be a fully formed,
	//    encoded HTTP(S) URL according to the RFC-3986 specification (_blank),
	//    for either standard integration, where connectionType is not VPC_LINK,
	//    or private integration, where connectionType is VPC_LINK. For a private
	//    HTTP integration, the URI is not used for routing.
	//
	//    *  For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}.
	//    Here, {Region} is the API Gateway region (e.g., us-east-1); {service}
	//    is the name of the integrated AWS service (e.g., s3); and {subdomain}
	//    is a designated subdomain supported by certain AWS service for fast host-name
	//    lookup. action can be used for an AWS service action-based API, using
	//    an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api}
	//    refers to a supported action {name} plus any required input parameters.
	//    Alternatively, path can be used for an AWS service path-based API. The
	//    ensuing service_api refers to the path to an AWS service resource, including
	//    the region of the integrated AWS service, if applicable. For example,
	//    for integration with the S3 API of GetObject (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html),
	//    the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}
	//    or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
	Uri *string `locationName:"uri" type:"string"`
}

// String returns the string representation
func (s PutIntegrationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutIntegrationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutIntegrationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutIntegrationInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutIntegrationInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.CacheKeyParameters) > 0 {
		v := s.CacheKeyParameters

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "cacheKeyParameters", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.CacheNamespace != nil {
		v := *s.CacheNamespace

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheNamespace", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConnectionId != nil {
		v := *s.ConnectionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "connectionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ConnectionType) > 0 {
		v := s.ConnectionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "connectionType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.ContentHandling) > 0 {
		v := s.ContentHandling

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "contentHandling", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Credentials != nil {
		v := *s.Credentials

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "credentials", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IntegrationHttpMethod != nil {
		v := *s.IntegrationHttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "httpMethod", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PassthroughBehavior != nil {
		v := *s.PassthroughBehavior

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "passthroughBehavior", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RequestParameters) > 0 {
		v := s.RequestParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "requestParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.RequestTemplates) > 0 {
		v := s.RequestTemplates

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "requestTemplates", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.TimeoutInMillis != nil {
		v := *s.TimeoutInMillis

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeoutInMillis", protocol.Int64Value(v), metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Uri != nil {
		v := *s.Uri

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "uri", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a put integration response request.
type PutIntegrationResponseInput struct {
	_ struct{} `type:"structure"`

	// Specifies how to handle response payload content type conversions. Supported
	// values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
	//
	//    * CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded
	//    string to the corresponding binary blob.
	//
	//    * CONVERT_TO_TEXT: Converts a response payload from a binary blob to a
	//    Base64-encoded string.
	//
	// If this property is not defined, the response payload will be passed through
	// from the integration response to the method response without modification.
	ContentHandling ContentHandlingStrategy `locationName:"contentHandling" type:"string" enum:"true"`

	// [Required] Specifies a put integration response request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] Specifies a put integration response request's resource identifier.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// A key-value map specifying response parameters that are passed to the method
	// response from the back end. The key is a method response header parameter
	// name and the mapped value is an integration response header value, a static
	// value enclosed within a pair of single quotes, or a JSON expression from
	// the integration response body. The mapping key must match the pattern of
	// method.response.header.{name}, where name is a valid and unique header name.
	// The mapped non-static value must match the pattern of integration.response.header.{name}
	// or integration.response.body.{JSON-expression}, where name must be a valid
	// and unique response header name and JSON-expression a valid JSON expression
	// without the $ prefix.
	ResponseParameters map[string]string `locationName:"responseParameters" type:"map"`

	// Specifies a put integration response's templates.
	ResponseTemplates map[string]string `locationName:"responseTemplates" type:"map"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// Specifies the selection pattern of a put integration response.
	SelectionPattern *string `locationName:"selectionPattern" type:"string"`

	// [Required] Specifies the status code that is used to map the integration
	// response to an existing MethodResponse.
	//
	// StatusCode is a required field
	StatusCode *string `location:"uri" locationName:"status_code" type:"string" required:"true"`
}

// String returns the string representation
func (s PutIntegrationResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutIntegrationResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutIntegrationResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutIntegrationResponseInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StatusCode == nil {
		invalidParams.Add(aws.NewErrParamRequired("StatusCode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutIntegrationResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ContentHandling) > 0 {
		v := s.ContentHandling

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "contentHandling", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.ResponseParameters) > 0 {
		v := s.ResponseParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.ResponseTemplates) > 0 {
		v := s.ResponseTemplates

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseTemplates", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.SelectionPattern != nil {
		v := *s.SelectionPattern

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "selectionPattern", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "status_code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to add a method to an existing Resource resource.
type PutMethodInput struct {
	_ struct{} `type:"structure"`

	// Specifies whether the method required a valid ApiKey.
	ApiKeyRequired *bool `locationName:"apiKeyRequired" type:"boolean"`

	// A list of authorization scopes configured on the method. The scopes are used
	// with a COGNITO_USER_POOLS authorizer to authorize the method invocation.
	// The authorization works by matching the method scopes against the scopes
	// parsed from the access token in the incoming request. The method invocation
	// is authorized if any method scopes matches a claimed scope in the access
	// token. Otherwise, the invocation is not authorized. When the method scope
	// is configured, the client must provide an access token instead of an identity
	// token for authorization purposes.
	AuthorizationScopes []string `locationName:"authorizationScopes" type:"list"`

	// [Required] The method's authorization type. Valid values are NONE for open
	// access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom
	// authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
	//
	// AuthorizationType is a required field
	AuthorizationType *string `locationName:"authorizationType" type:"string" required:"true"`

	// Specifies the identifier of an Authorizer to use on this Method, if the type
	// is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by
	// API Gateway when you created the authorizer.
	AuthorizerId *string `locationName:"authorizerId" type:"string"`

	// [Required] Specifies the method request's HTTP method type.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// A human-friendly operation identifier for the method. For example, you can
	// assign the operationName of ListPets for the GET /pets method in PetStore
	// (https://petstore-demo-endpoint.execute-api.com/petstore/pets) example.
	OperationName *string `locationName:"operationName" type:"string"`

	// Specifies the Model resources used for the request's content type. Request
	// models are represented as a key/value map, with a content type as the key
	// and a Model name as the value.
	RequestModels map[string]string `locationName:"requestModels" type:"map"`

	// A key-value map defining required or optional method request parameters that
	// can be accepted by API Gateway. A key defines a method request parameter
	// name matching the pattern of method.request.{location}.{name}, where location
	// is querystring, path, or header and name is a valid and unique parameter
	// name. The value associated with the key is a Boolean flag indicating whether
	// the parameter is required (true) or optional (false). The method request
	// parameter names defined here are available in Integration to be mapped to
	// integration request parameters or body-mapping templates.
	RequestParameters map[string]bool `locationName:"requestParameters" type:"map"`

	// The identifier of a RequestValidator for validating the method request.
	RequestValidatorId *string `locationName:"requestValidatorId" type:"string"`

	// [Required] The Resource identifier for the new Method resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s PutMethodInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutMethodInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutMethodInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutMethodInput"}

	if s.AuthorizationType == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizationType"))
	}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutMethodInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ApiKeyRequired != nil {
		v := *s.ApiKeyRequired

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "apiKeyRequired", protocol.BoolValue(v), metadata)
	}
	if len(s.AuthorizationScopes) > 0 {
		v := s.AuthorizationScopes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "authorizationScopes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.AuthorizationType != nil {
		v := *s.AuthorizationType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizationType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerId != nil {
		v := *s.AuthorizerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.OperationName != nil {
		v := *s.OperationName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "operationName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RequestModels) > 0 {
		v := s.RequestModels

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "requestModels", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.RequestParameters) > 0 {
		v := s.RequestParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "requestParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.BoolValue(v1))
		}
		ms0.End()

	}
	if s.RequestValidatorId != nil {
		v := *s.RequestValidatorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "requestValidatorId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to add a MethodResponse to an existing Method resource.
type PutMethodResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] The HTTP verb of the Method resource.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// [Required] The Resource identifier for the Method resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// Specifies the Model resources used for the response's content type. Response
	// models are represented as a key/value map, with a content type as the key
	// and a Model name as the value.
	ResponseModels map[string]string `locationName:"responseModels" type:"map"`

	// A key-value map specifying required or optional response parameters that
	// API Gateway can send back to the caller. A key defines a method response
	// header name and the associated value is a Boolean flag indicating whether
	// the method response parameter is required or not. The method response header
	// names must match the pattern of method.response.header.{name}, where name
	// is a valid and unique header name. The response parameter names defined here
	// are available in the integration response to be mapped from an integration
	// response header expressed in integration.response.header.{name}, a static
	// value enclosed within a pair of single quotes (e.g., 'application/json'),
	// or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression},
	// where JSON-expression is a valid JSON expression without the $ prefix.)
	ResponseParameters map[string]bool `locationName:"responseParameters" type:"map"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The method response's status code.
	//
	// StatusCode is a required field
	StatusCode *string `location:"uri" locationName:"status_code" type:"string" required:"true"`
}

// String returns the string representation
func (s PutMethodResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutMethodResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutMethodResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutMethodResponseInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StatusCode == nil {
		invalidParams.Add(aws.NewErrParamRequired("StatusCode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutMethodResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.ResponseModels) > 0 {
		v := s.ResponseModels

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseModels", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.ResponseParameters) > 0 {
		v := s.ResponseParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.BoolValue(v1))
		}
		ms0.End()

	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "status_code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A PUT request to update an existing API, with external API definitions specified
// as the request body.
type PutRestApiInput struct {
	_ struct{} `type:"structure" payload:"Body"`

	// [Required] The PUT request body containing external API definitions. Currently,
	// only OpenAPI definition JSON/YAML files are supported. The maximum size of
	// the API definition file is 2MB.
	//
	// Body is a required field
	Body []byte `locationName:"body" type:"blob" required:"true"`

	// A query parameter to indicate whether to rollback the API update (true) or
	// not (false) when a warning is encountered. The default value is false.
	FailOnWarnings *bool `location:"querystring" locationName:"failonwarnings" type:"boolean"`

	// The mode query parameter to specify the update mode. Valid values are "merge"
	// and "overwrite". By default, the update mode is "merge".
	Mode PutMode `location:"querystring" locationName:"mode" type:"string" enum:"true"`

	// Custom header parameters as part of the request. For example, to exclude
	// DocumentationParts from an imported API, set ignore=documentation as a parameters
	// value, as in the AWS CLI command of aws apigateway import-rest-api --parameters
	// ignore=documentation --body 'file:///path/to/imported-api-body.json'.
	Parameters map[string]string `location:"querystring" locationName:"parameters" type:"map"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s PutRestApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutRestApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutRestApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "PutRestApiInput"}

	if s.Body == nil {
		invalidParams.Add(aws.NewErrParamRequired("Body"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PutRestApiInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Body != nil {
		v := s.Body

		metadata := protocol.Metadata{}
		e.SetStream(protocol.PayloadTarget, "body", protocol.BytesStream(v), metadata)
	}
	if s.FailOnWarnings != nil {
		v := *s.FailOnWarnings

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "failonwarnings", protocol.BoolValue(v), metadata)
	}
	if len(s.Mode) > 0 {
		v := s.Mode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "mode", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.Parameters) > 0 {
		v := s.Parameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.QueryTarget, "parameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	return nil
}

// Quotas configured for a usage plan.
type QuotaSettings struct {
	_ struct{} `type:"structure"`

	// The maximum number of requests that can be made in a given time period.
	Limit *int64 `locationName:"limit" type:"integer"`

	// The number of requests subtracted from the given limit in the initial time
	// period.
	Offset *int64 `locationName:"offset" type:"integer"`

	// The time period in which the limit applies. Valid values are "DAY", "WEEK"
	// or "MONTH".
	Period QuotaPeriodType `locationName:"period" type:"string" enum:"true"`
}

// String returns the string representation
func (s QuotaSettings) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s QuotaSettings) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s QuotaSettings) MarshalFields(e protocol.FieldEncoder) error {
	if s.Limit != nil {
		v := *s.Limit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "limit", protocol.Int64Value(v), metadata)
	}
	if s.Offset != nil {
		v := *s.Offset

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "offset", protocol.Int64Value(v), metadata)
	}
	if len(s.Period) > 0 {
		v := s.Period

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "period", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// A configuration property of an SDK type.
type SdkConfigurationProperty struct {
	_ struct{} `type:"structure"`

	// The default value of an SdkType configuration property.
	DefaultValue *string `locationName:"defaultValue" type:"string"`

	// The description of an SdkType configuration property.
	Description *string `locationName:"description" type:"string"`

	// The user-friendly name of an SdkType configuration property.
	FriendlyName *string `locationName:"friendlyName" type:"string"`

	// The name of a an SdkType configuration property.
	Name *string `locationName:"name" type:"string"`

	// A boolean flag of an SdkType configuration property to indicate if the associated
	// SDK configuration property is required (true) or not (false).
	Required *bool `locationName:"required" type:"boolean"`
}

// String returns the string representation
func (s SdkConfigurationProperty) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SdkConfigurationProperty) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s SdkConfigurationProperty) MarshalFields(e protocol.FieldEncoder) error {
	if s.DefaultValue != nil {
		v := *s.DefaultValue

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultValue", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.FriendlyName != nil {
		v := *s.FriendlyName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "friendlyName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Required != nil {
		v := *s.Required

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "required", protocol.BoolValue(v), metadata)
	}
	return nil
}

// A reference to a unique stage identified in the format {restApiId}/{stage}.
type StageKey struct {
	_ struct{} `type:"structure"`

	// The string identifier of the associated RestApi.
	RestApiId *string `locationName:"restApiId" type:"string"`

	// The stage name associated with the stage key.
	StageName *string `locationName:"stageName" type:"string"`
}

// String returns the string representation
func (s StageKey) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StageKey) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StageKey) MarshalFields(e protocol.FieldEncoder) error {
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "restApiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stageName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Adds or updates a tag on a given resource.
type TagResourceInput struct {
	_ struct{} `type:"structure"`

	// [Required] The ARN of a resource that can be tagged. The resource ARN must
	// be URL-encoded. At present, Stage is the only taggable resource.
	//
	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resource_arn" type:"string" required:"true"`

	// [Required] The key-value map of strings. The valid character set is [a-zA-Z+-=._:/].
	// The tag key can be up to 128 characters and must not start with aws:. The
	// tag value can be up to 256 characters.
	//
	// Tags is a required field
	Tags map[string]string `locationName:"tags" type:"map" required:"true"`
}

// String returns the string representation
func (s TagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TagResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TagResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if s.Tags == nil {
		invalidParams.Add(aws.NewErrParamRequired("Tags"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TagResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

type TagResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s TagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TagResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TagResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Make a request to simulate the execution of an Authorizer.
type TestInvokeAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// [Optional] A key-value map of additional context variables.
	AdditionalContext map[string]string `locationName:"additionalContext" type:"map"`

	// [Required] Specifies a test invoke authorizer request's Authorizer ID.
	//
	// AuthorizerId is a required field
	AuthorizerId *string `location:"uri" locationName:"authorizer_id" type:"string" required:"true"`

	// [Optional] The simulated request body of an incoming invocation request.
	Body *string `locationName:"body" type:"string"`

	// [Required] A key-value map of headers to simulate an incoming invocation
	// request. This is where the incoming authorization token, or identity source,
	// should be specified.
	Headers map[string]string `locationName:"headers" type:"map"`

	// [Optional] The headers as a map from string to list of values to simulate
	// an incoming invocation request. This is where the incoming authorization
	// token, or identity source, may be specified.
	MultiValueHeaders map[string][]string `locationName:"multiValueHeaders" type:"map"`

	// [Optional] The URI path, including query string, of the simulated invocation
	// request. Use this to specify path parameters and query string parameters.
	PathWithQueryString *string `locationName:"pathWithQueryString" type:"string"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// A key-value map of stage variables to simulate an invocation on a deployed
	// Stage.
	StageVariables map[string]string `locationName:"stageVariables" type:"map"`
}

// String returns the string representation
func (s TestInvokeAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestInvokeAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TestInvokeAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TestInvokeAuthorizerInput"}

	if s.AuthorizerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestInvokeAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.AdditionalContext) > 0 {
		v := s.AdditionalContext

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "additionalContext", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Body != nil {
		v := *s.Body

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "body", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Headers) > 0 {
		v := s.Headers

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "headers", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.MultiValueHeaders) > 0 {
		v := s.MultiValueHeaders

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "multiValueHeaders", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ls1 := ms0.List(k1)
			ls1.Start()
			for _, v2 := range v1 {
				ls1.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v2)})
			}
			ls1.End()
		}
		ms0.End()

	}
	if s.PathWithQueryString != nil {
		v := *s.PathWithQueryString

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "pathWithQueryString", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.StageVariables) > 0 {
		v := s.StageVariables

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "stageVariables", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.AuthorizerId != nil {
		v := *s.AuthorizerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizer_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the response of the test invoke request for a custom Authorizer
type TestInvokeAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	Authorization map[string][]string `locationName:"authorization" type:"map"`

	// The open identity claims (https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims),
	// with any supported custom attributes, returned from the Cognito Your User
	// Pool configured for the API.
	Claims map[string]string `locationName:"claims" type:"map"`

	// The HTTP status code that the client would have received. Value is 0 if the
	// authorizer succeeded.
	ClientStatus *int64 `locationName:"clientStatus" type:"integer"`

	// The execution latency of the test authorizer request.
	Latency *int64 `locationName:"latency" type:"long"`

	// The API Gateway execution log for the test authorizer request.
	Log *string `locationName:"log" type:"string"`

	// The JSON policy document returned by the Authorizer
	Policy *string `locationName:"policy" type:"string"`

	// The principal identity returned by the Authorizer
	PrincipalId *string `locationName:"principalId" type:"string"`
}

// String returns the string representation
func (s TestInvokeAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestInvokeAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TestInvokeAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestInvokeAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Authorization) > 0 {
		v := s.Authorization

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "authorization", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ls1 := ms0.List(k1)
			ls1.Start()
			for _, v2 := range v1 {
				ls1.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v2)})
			}
			ls1.End()
		}
		ms0.End()

	}
	if len(s.Claims) > 0 {
		v := s.Claims

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "claims", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.ClientStatus != nil {
		v := *s.ClientStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "clientStatus", protocol.Int64Value(v), metadata)
	}
	if s.Latency != nil {
		v := *s.Latency

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "latency", protocol.Int64Value(v), metadata)
	}
	if s.Log != nil {
		v := *s.Log

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "log", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Policy != nil {
		v := *s.Policy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PrincipalId != nil {
		v := *s.PrincipalId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "principalId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Make a request to simulate the execution of a Method.
type TestInvokeMethodInput struct {
	_ struct{} `type:"structure"`

	// The simulated request body of an incoming invocation request.
	Body *string `locationName:"body" type:"string"`

	// A ClientCertificate identifier to use in the test invocation. API Gateway
	// will use the certificate when making the HTTPS request to the defined back-end
	// endpoint.
	ClientCertificateId *string `locationName:"clientCertificateId" type:"string"`

	// A key-value map of headers to simulate an incoming invocation request.
	Headers map[string]string `locationName:"headers" type:"map"`

	// [Required] Specifies a test invoke method request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// The headers as a map from string to list of values to simulate an incoming
	// invocation request.
	MultiValueHeaders map[string][]string `locationName:"multiValueHeaders" type:"map"`

	// The URI path, including query string, of the simulated invocation request.
	// Use this to specify path parameters and query string parameters.
	PathWithQueryString *string `locationName:"pathWithQueryString" type:"string"`

	// [Required] Specifies a test invoke method request's resource ID.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// A key-value map of stage variables to simulate an invocation on a deployed
	// Stage.
	StageVariables map[string]string `locationName:"stageVariables" type:"map"`
}

// String returns the string representation
func (s TestInvokeMethodInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestInvokeMethodInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TestInvokeMethodInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TestInvokeMethodInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestInvokeMethodInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Body != nil {
		v := *s.Body

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "body", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ClientCertificateId != nil {
		v := *s.ClientCertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "clientCertificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Headers) > 0 {
		v := s.Headers

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "headers", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.MultiValueHeaders) > 0 {
		v := s.MultiValueHeaders

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "multiValueHeaders", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ls1 := ms0.List(k1)
			ls1.Start()
			for _, v2 := range v1 {
				ls1.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v2)})
			}
			ls1.End()
		}
		ms0.End()

	}
	if s.PathWithQueryString != nil {
		v := *s.PathWithQueryString

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "pathWithQueryString", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.StageVariables) > 0 {
		v := s.StageVariables

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "stageVariables", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the response of the test invoke request in the HTTP method.
//
// Test API using the API Gateway console (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-test-method.html#how-to-test-method-console)
type TestInvokeMethodOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The body of the HTTP response.
	Body *string `locationName:"body" type:"string"`

	// The headers of the HTTP response.
	Headers map[string]string `locationName:"headers" type:"map"`

	// The execution latency of the test invoke request.
	Latency *int64 `locationName:"latency" type:"long"`

	// The API Gateway execution log for the test invoke request.
	Log *string `locationName:"log" type:"string"`

	// The headers of the HTTP response as a map from string to list of values.
	MultiValueHeaders map[string][]string `locationName:"multiValueHeaders" type:"map"`

	// The HTTP status code.
	Status *int64 `locationName:"status" type:"integer"`
}

// String returns the string representation
func (s TestInvokeMethodOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestInvokeMethodOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TestInvokeMethodOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestInvokeMethodOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Body != nil {
		v := *s.Body

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "body", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Headers) > 0 {
		v := s.Headers

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "headers", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.Latency != nil {
		v := *s.Latency

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "latency", protocol.Int64Value(v), metadata)
	}
	if s.Log != nil {
		v := *s.Log

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "log", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.MultiValueHeaders) > 0 {
		v := s.MultiValueHeaders

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "multiValueHeaders", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ls1 := ms0.List(k1)
			ls1.Start()
			for _, v2 := range v1 {
				ls1.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v2)})
			}
			ls1.End()
		}
		ms0.End()

	}
	if s.Status != nil {
		v := *s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.Int64Value(v), metadata)
	}
	return nil
}

// The API request rate limits.
type ThrottleSettings struct {
	_ struct{} `type:"structure"`

	// The API request burst limit, the maximum rate limit over a time ranging from
	// one to a few seconds, depending upon whether the underlying token bucket
	// is at its full capacity.
	BurstLimit *int64 `locationName:"burstLimit" type:"integer"`

	// The API request steady-state rate limit.
	RateLimit *float64 `locationName:"rateLimit" type:"double"`
}

// String returns the string representation
func (s ThrottleSettings) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ThrottleSettings) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ThrottleSettings) MarshalFields(e protocol.FieldEncoder) error {
	if s.BurstLimit != nil {
		v := *s.BurstLimit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "burstLimit", protocol.Int64Value(v), metadata)
	}
	if s.RateLimit != nil {
		v := *s.RateLimit

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "rateLimit", protocol.Float64Value(v), metadata)
	}
	return nil
}

// Removes a tag from a given resource.
type UntagResourceInput struct {
	_ struct{} `type:"structure"`

	// [Required] The ARN of a resource that can be tagged. The resource ARN must
	// be URL-encoded. At present, Stage is the only taggable resource.
	//
	// ResourceArn is a required field
	ResourceArn *string `location:"uri" locationName:"resource_arn" type:"string" required:"true"`

	// [Required] The Tag keys to delete.
	//
	// TagKeys is a required field
	TagKeys []string `location:"querystring" locationName:"tagKeys" type:"list" required:"true"`
}

// String returns the string representation
func (s UntagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UntagResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UntagResourceInput"}

	if s.ResourceArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceArn"))
	}

	if s.TagKeys == nil {
		invalidParams.Add(aws.NewErrParamRequired("TagKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UntagResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ResourceArn != nil {
		v := *s.ResourceArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_arn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TagKeys) > 0 {
		v := s.TagKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.QueryTarget, "tagKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type UntagResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s UntagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UntagResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UntagResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// Requests API Gateway to change information about the current Account resource.
type UpdateAccountInput struct {
	_ struct{} `type:"structure"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`
}

// String returns the string representation
func (s UpdateAccountInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateAccountInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateAccountInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Represents an AWS account that is associated with API Gateway.
//
// To view the account info, call GET on this resource.
//
// Error Codes
//
// The following exception may be thrown when the request fails.
//
// UnauthorizedException
// NotFoundException
// TooManyRequestsException
// For detailed error code information, including the corresponding HTTP Status
// Codes, see API Gateway Error Codes (https://docs.aws.amazon.com/apigateway/api-reference/handling-errors/#api-error-codes)
//
// Example: Get the information about an account.
//
// Request
//
// GET /account HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com
// X-Amz-Date: 20160531T184618Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/us-east-1/apigateway/aws4_request,
// SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
// Response
//
// The successful response returns a 200 OK status code and a payload similar
// to the following:
//
// { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/account-apigateway-{rel}.html",
// "name": "account", "templated": true }, "self": { "href": "/account" }, "account:update":
// { "href": "/account" } }, "cloudwatchRoleArn": "arn:aws:iam::123456789012:role/apigAwsProxyRole",
// "throttleSettings": { "rateLimit": 500, "burstLimit": 1000 } }
// In addition to making the REST API call directly, you can use the AWS CLI
// and an AWS SDK to access this resource.
//
// API Gateway Limits (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-limits.html)Developer
// Guide (https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html),
// AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-account.html)
type UpdateAccountOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The version of the API keys used for the account.
	ApiKeyVersion *string `locationName:"apiKeyVersion" type:"string"`

	// The ARN of an Amazon CloudWatch role for the current Account.
	CloudwatchRoleArn *string `locationName:"cloudwatchRoleArn" type:"string"`

	// A list of features supported for the account. When usage plans are enabled,
	// the features list will include an entry of "UsagePlans".
	Features []string `locationName:"features" type:"list"`

	// Specifies the API request limits configured for the current Account.
	ThrottleSettings *ThrottleSettings `locationName:"throttleSettings" type:"structure"`
}

// String returns the string representation
func (s UpdateAccountOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateAccountOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateAccountOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateAccountOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApiKeyVersion != nil {
		v := *s.ApiKeyVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "apiKeyVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CloudwatchRoleArn != nil {
		v := *s.CloudwatchRoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cloudwatchRoleArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Features) > 0 {
		v := s.Features

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "features", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.ThrottleSettings != nil {
		v := s.ThrottleSettings

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "throttleSettings", v, metadata)
	}
	return nil
}

// A request to change information about an ApiKey resource.
type UpdateApiKeyInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the ApiKey resource to be updated.
	//
	// ApiKey is a required field
	ApiKey *string `location:"uri" locationName:"api_Key" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`
}

// String returns the string representation
func (s UpdateApiKeyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApiKeyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateApiKeyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateApiKeyInput"}

	if s.ApiKey == nil {
		invalidParams.Add(aws.NewErrParamRequired("ApiKey"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateApiKeyInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ApiKey != nil {
		v := *s.ApiKey

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "api_Key", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A resource that can be distributed to callers for executing Method resources
// that require an API key. API keys can be mapped to any Stage on any RestApi,
// which indicates that the callers with the API key can make requests to that
// stage.
//
// Use API Keys (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html)
type UpdateApiKeyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The timestamp when the API Key was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// An AWS Marketplace customer identifier , when integrating with the AWS SaaS
	// Marketplace.
	CustomerId *string `locationName:"customerId" type:"string"`

	// The description of the API Key.
	Description *string `locationName:"description" type:"string"`

	// Specifies whether the API Key can be used by callers.
	Enabled *bool `locationName:"enabled" type:"boolean"`

	// The identifier of the API Key.
	Id *string `locationName:"id" type:"string"`

	// The timestamp when the API Key was last updated.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// The name of the API Key.
	Name *string `locationName:"name" type:"string"`

	// A list of Stage resources that are associated with the ApiKey resource.
	StageKeys []string `locationName:"stageKeys" type:"list"`

	// The value of the API Key.
	Value *string `locationName:"value" type:"string"`
}

// String returns the string representation
func (s UpdateApiKeyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApiKeyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateApiKeyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateApiKeyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.CustomerId != nil {
		v := *s.CustomerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "customerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "enabled", protocol.BoolValue(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.StageKeys) > 0 {
		v := s.StageKeys

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "stageKeys", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "value", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to update an existing Authorizer resource.
type UpdateAuthorizerInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the Authorizer resource.
	//
	// AuthorizerId is a required field
	AuthorizerId *string `location:"uri" locationName:"authorizer_id" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateAuthorizerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateAuthorizerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateAuthorizerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateAuthorizerInput"}

	if s.AuthorizerId == nil {
		invalidParams.Add(aws.NewErrParamRequired("AuthorizerId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateAuthorizerInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.AuthorizerId != nil {
		v := *s.AuthorizerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "authorizer_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents an authorization layer for methods. If enabled on a method, API
// Gateway will activate the authorizer when a client calls the method.
//
// Enable custom authorization (https://docs.aws.amazon.com/apigateway/latest/developerguide/use-custom-authorizer.html)
type UpdateAuthorizerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Optional customer-defined field, used in OpenAPI imports and exports without
	// functional impact.
	AuthType *string `locationName:"authType" type:"string"`

	// Specifies the required credentials as an IAM role for API Gateway to invoke
	// the authorizer. To specify an IAM role for API Gateway to assume, use the
	// role's Amazon Resource Name (ARN). To use resource-based permissions on the
	// Lambda function, specify null.
	AuthorizerCredentials *string `locationName:"authorizerCredentials" type:"string"`

	// The TTL in seconds of cached authorizer results. If it equals 0, authorization
	// caching is disabled. If it is greater than 0, API Gateway will cache authorizer
	// responses. If this field is not set, the default value is 300. The maximum
	// value is 3600, or 1 hour.
	AuthorizerResultTtlInSeconds *int64 `locationName:"authorizerResultTtlInSeconds" type:"integer"`

	// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or
	// REQUEST authorizers, this must be a well-formed Lambda function URI, for
	// example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations.
	// In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api},
	// where {region} is the same as the region hosting the Lambda function, path
	// indicates that the remaining substring in the URI should be treated as the
	// path to the resource, including the initial /. For Lambda functions, this
	// is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
	AuthorizerUri *string `locationName:"authorizerUri" type:"string"`

	// The identifier for the authorizer resource.
	Id *string `locationName:"id" type:"string"`

	// The identity source for which authorization is requested. For a TOKEN or
	// COGNITO_USER_POOLS authorizer, this is required and specifies the request
	// header mapping expression for the custom header holding the authorization
	// token submitted by the client. For example, if the token header name is Auth,
	// the header mapping expression is method.request.header.Auth.
	// For the REQUEST authorizer, this is required when authorization caching is
	// enabled. The value is a comma-separated string of one or more mapping expressions
	// of the specified request parameters. For example, if an Auth header, a Name
	// query string parameter are defined as identity sources, this value is method.request.header.Auth,
	// method.request.querystring.Name. These parameters will be used to derive
	// the authorization caching key and to perform runtime validation of the REQUEST
	// authorizer by verifying all of the identity-related request parameters are
	// present, not null and non-empty. Only when this is true does the authorizer
	// invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized
	// response without calling the Lambda function. The valid value is a string
	// of comma-separated mapping expressions of the specified request parameters.
	// When the authorization caching is not enabled, this property is optional.
	IdentitySource *string `locationName:"identitySource" type:"string"`

	// A validation expression for the incoming identity token. For TOKEN authorizers,
	// this value is a regular expression. API Gateway will match the aud field
	// of the incoming token from the client against the specified regular expression.
	// It will invoke the authorizer's Lambda function when there is a match. Otherwise,
	// it will return a 401 Unauthorized response without calling the Lambda function.
	// The validation expression does not apply to the REQUEST authorizer.
	IdentityValidationExpression *string `locationName:"identityValidationExpression" type:"string"`

	// [Required] The name of the authorizer.
	Name *string `locationName:"name" type:"string"`

	// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer.
	// Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}.
	// For a TOKEN or REQUEST authorizer, this is not defined.
	ProviderARNs []string `locationName:"providerARNs" type:"list"`

	// The authorizer type. Valid values are TOKEN for a Lambda function using a
	// single authorization token submitted in a custom header, REQUEST for a Lambda
	// function using incoming request parameters, and COGNITO_USER_POOLS for using
	// an Amazon Cognito user pool.
	Type AuthorizerType `locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s UpdateAuthorizerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateAuthorizerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateAuthorizerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateAuthorizerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AuthType != nil {
		v := *s.AuthType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerCredentials != nil {
		v := *s.AuthorizerCredentials

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerCredentials", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerResultTtlInSeconds != nil {
		v := *s.AuthorizerResultTtlInSeconds

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerResultTtlInSeconds", protocol.Int64Value(v), metadata)
	}
	if s.AuthorizerUri != nil {
		v := *s.AuthorizerUri

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerUri", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdentitySource != nil {
		v := *s.IdentitySource

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "identitySource", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.IdentityValidationExpression != nil {
		v := *s.IdentityValidationExpression

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "identityValidationExpression", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ProviderARNs) > 0 {
		v := s.ProviderARNs

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "providerARNs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	return nil
}

// A request to change information about the BasePathMapping resource.
type UpdateBasePathMappingInput struct {
	_ struct{} `type:"structure"`

	// [Required] The base path of the BasePathMapping resource to change.
	//
	// BasePath is a required field
	BasePath *string `location:"uri" locationName:"base_path" type:"string" required:"true"`

	// [Required] The domain name of the BasePathMapping resource to change.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"domain_name" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`
}

// String returns the string representation
func (s UpdateBasePathMappingInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBasePathMappingInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateBasePathMappingInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateBasePathMappingInput"}

	if s.BasePath == nil {
		invalidParams.Add(aws.NewErrParamRequired("BasePath"))
	}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateBasePathMappingInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.BasePath != nil {
		v := *s.BasePath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "base_path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "domain_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the base path that callers of the API must provide as part of
// the URL after the domain name.
//
// A custom domain name plus a BasePathMapping specification identifies a deployed
// RestApi in a given stage of the owner Account.
// Use Custom Domain Names (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
type UpdateBasePathMappingOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The base path name that callers of the API must provide as part of the URL
	// after the domain name.
	BasePath *string `locationName:"basePath" type:"string"`

	// The string identifier of the associated RestApi.
	RestApiId *string `locationName:"restApiId" type:"string"`

	// The name of the associated stage.
	Stage *string `locationName:"stage" type:"string"`
}

// String returns the string representation
func (s UpdateBasePathMappingOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBasePathMappingOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateBasePathMappingOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateBasePathMappingOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.BasePath != nil {
		v := *s.BasePath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "basePath", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "restApiId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Stage != nil {
		v := *s.Stage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A request to change information about an ClientCertificate resource.
type UpdateClientCertificateInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the ClientCertificate resource to be updated.
	//
	// ClientCertificateId is a required field
	ClientCertificateId *string `location:"uri" locationName:"clientcertificate_id" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`
}

// String returns the string representation
func (s UpdateClientCertificateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateClientCertificateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateClientCertificateInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateClientCertificateInput"}

	if s.ClientCertificateId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ClientCertificateId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateClientCertificateInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ClientCertificateId != nil {
		v := *s.ClientCertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "clientcertificate_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a client certificate used to configure client-side SSL authentication
// while sending requests to the integration endpoint.
//
// Client certificates are used to authenticate an API by the backend server.
// To authenticate an API client (or user), use IAM roles and policies, a custom
// Authorizer or an Amazon Cognito user pool.
// Use Client-Side Certificate (https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html)
type UpdateClientCertificateOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The identifier of the client certificate.
	ClientCertificateId *string `locationName:"clientCertificateId" type:"string"`

	// The timestamp when the client certificate was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// The description of the client certificate.
	Description *string `locationName:"description" type:"string"`

	// The timestamp when the client certificate will expire.
	ExpirationDate *time.Time `locationName:"expirationDate" type:"timestamp" timestampFormat:"unix"`

	// The PEM-encoded public key of the client certificate, which can be used to
	// configure certificate authentication in the integration endpoint .
	PemEncodedCertificate *string `locationName:"pemEncodedCertificate" type:"string"`
}

// String returns the string representation
func (s UpdateClientCertificateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateClientCertificateOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateClientCertificateOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateClientCertificateOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ClientCertificateId != nil {
		v := *s.ClientCertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "clientCertificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ExpirationDate != nil {
		v := *s.ExpirationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "expirationDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.PemEncodedCertificate != nil {
		v := *s.PemEncodedCertificate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "pemEncodedCertificate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Requests API Gateway to change information about a Deployment resource.
type UpdateDeploymentInput struct {
	_ struct{} `type:"structure"`

	// The replacement identifier for the Deployment resource to change information
	// about.
	//
	// DeploymentId is a required field
	DeploymentId *string `location:"uri" locationName:"deployment_id" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateDeploymentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDeploymentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDeploymentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateDeploymentInput"}

	if s.DeploymentId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DeploymentId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDeploymentInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.DeploymentId != nil {
		v := *s.DeploymentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "deployment_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// An immutable representation of a RestApi resource that can be called by users
// using Stages. A deployment must be associated with a Stage for it to be callable
// over the Internet.
//
// To create a deployment, call POST on the Deployments resource of a RestApi.
// To view, update, or delete a deployment, call GET, PATCH, or DELETE on the
// specified deployment resource (/restapis/{restapi_id}/deployments/{deployment_id}).
//
// RestApi, Deployments, Stage, AWS CLI (https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html),
// AWS SDKs (https://aws.amazon.com/tools/)
type UpdateDeploymentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A summary of the RestApi at the date and time that the deployment resource
	// was created.
	ApiSummary map[string]map[string]MethodSnapshot `locationName:"apiSummary" type:"map"`

	// The date and time that the deployment resource was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// The description for the deployment resource.
	Description *string `locationName:"description" type:"string"`

	// The identifier for the deployment resource.
	Id *string `locationName:"id" type:"string"`
}

// String returns the string representation
func (s UpdateDeploymentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDeploymentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateDeploymentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDeploymentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ApiSummary) > 0 {
		v := s.ApiSummary

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "apiSummary", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms1 := ms0.Map(k1)
			ms1.Start()
			for k2, v2 := range v1 {
				ms1.MapSetFields(k2, v2)
			}
			ms1.End()
		}
		ms0.End()

	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Updates an existing documentation part of a given API.
type UpdateDocumentationPartInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the to-be-updated documentation part.
	//
	// DocumentationPartId is a required field
	DocumentationPartId *string `location:"uri" locationName:"part_id" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateDocumentationPartInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDocumentationPartInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDocumentationPartInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateDocumentationPartInput"}

	if s.DocumentationPartId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentationPartId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDocumentationPartInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.DocumentationPartId != nil {
		v := *s.DocumentationPartId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "part_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A documentation part for a targeted API entity.
//
// A documentation part consists of a content map (properties) and a target
// (location). The target specifies an API entity to which the documentation
// content applies. The supported API entity types are API, AUTHORIZER, MODEL,
// RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY,
// RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. Valid location fields depend
// on the API entity type. All valid fields are not required.
//
// The content map is a JSON string of API-specific key-value pairs. Although
// an API can use any shape for the content map, only the OpenAPI-compliant
// documentation fields will be injected into the associated API entity definition
// in the exported OpenAPI definition file.
//
// Documenting an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html),
// DocumentationParts
type UpdateDocumentationPartOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The DocumentationPart identifier, generated by API Gateway when the DocumentationPart
	// is created.
	Id *string `locationName:"id" type:"string"`

	// The location of the API entity to which the documentation applies. Valid
	// fields depend on the targeted API entity type. All the valid location fields
	// are not required. If not explicitly specified, a valid location field is
	// treated as a wildcard and associated documentation content may be inherited
	// by matching entities, unless overridden.
	Location *DocumentationPartLocation `locationName:"location" type:"structure"`

	// A content map of API-specific key-value pairs describing the targeted API
	// entity. The map must be encoded as a JSON string, e.g., "{ \"description\":
	// \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields
	// from the properties map are exported and, hence, published as part of the
	// API entity definitions, while the original documentation parts are exported
	// in a OpenAPI extension of x-amazon-apigateway-documentation.
	Properties *string `locationName:"properties" type:"string"`
}

// String returns the string representation
func (s UpdateDocumentationPartOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDocumentationPartOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateDocumentationPartOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDocumentationPartOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Location != nil {
		v := s.Location

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "location", v, metadata)
	}
	if s.Properties != nil {
		v := *s.Properties

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "properties", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Updates an existing documentation version of an API.
type UpdateDocumentationVersionInput struct {
	_ struct{} `type:"structure"`

	// [Required] The version identifier of the to-be-updated documentation version.
	//
	// DocumentationVersion is a required field
	DocumentationVersion *string `location:"uri" locationName:"doc_version" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The string identifier of the associated RestApi..
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateDocumentationVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDocumentationVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDocumentationVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateDocumentationVersionInput"}

	if s.DocumentationVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("DocumentationVersion"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDocumentationVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.DocumentationVersion != nil {
		v := *s.DocumentationVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "doc_version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A snapshot of the documentation of an API.
//
// Publishing API documentation involves creating a documentation version associated
// with an API stage and exporting the versioned documentation to an external
// (e.g., OpenAPI) file.
//
// Documenting an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html),
// DocumentationPart, DocumentationVersions
type UpdateDocumentationVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The date when the API documentation snapshot is created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// The description of the API documentation snapshot.
	Description *string `locationName:"description" type:"string"`

	// The version identifier of the API documentation snapshot.
	Version *string `locationName:"version" type:"string"`
}

// String returns the string representation
func (s UpdateDocumentationVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDocumentationVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateDocumentationVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDocumentationVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A request to change information about the DomainName resource.
type UpdateDomainNameInput struct {
	_ struct{} `type:"structure"`

	// [Required] The name of the DomainName resource to be changed.
	//
	// DomainName is a required field
	DomainName *string `location:"uri" locationName:"domain_name" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`
}

// String returns the string representation
func (s UpdateDomainNameInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDomainNameInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDomainNameInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateDomainNameInput"}

	if s.DomainName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DomainName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDomainNameInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "domain_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a custom domain name as a user-friendly host name of an API (RestApi).
//
// When you deploy an API, API Gateway creates a default host name for the API.
// This default API host name is of the {restapi-id}.execute-api.{region}.amazonaws.com
// format. With the default host name, you can access the API's root resource
// with the URL of https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/.
// When you set up a custom domain name of apis.example.com for this API, you
// can then access the same resource using the URL of the https://apis.examples.com/myApi,
// where myApi is the base path mapping (BasePathMapping) of your API under
// the custom domain name.
//
// Set a Custom Host Name for an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
type UpdateDomainNameOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The reference to an AWS-managed certificate that will be used by edge-optimized
	// endpoint for this domain name. AWS Certificate Manager is the only supported
	// source.
	CertificateArn *string `locationName:"certificateArn" type:"string"`

	// The name of the certificate that will be used by edge-optimized endpoint
	// for this domain name.
	CertificateName *string `locationName:"certificateName" type:"string"`

	// The timestamp when the certificate that was used by edge-optimized endpoint
	// for this domain name was uploaded.
	CertificateUploadDate *time.Time `locationName:"certificateUploadDate" type:"timestamp" timestampFormat:"unix"`

	// The domain name of the Amazon CloudFront distribution associated with this
	// custom domain name for an edge-optimized endpoint. You set up this association
	// when adding a DNS record pointing the custom domain name to this distribution
	// name. For more information about CloudFront distributions, see the Amazon
	// CloudFront documentation (https://aws.amazon.com/documentation/cloudfront/).
	DistributionDomainName *string `locationName:"distributionDomainName" type:"string"`

	// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized
	// endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more
	// information, see Set up a Regional Custom Domain Name (https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html)
	// and AWS Regions and Endpoints for API Gateway (https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
	DistributionHostedZoneId *string `locationName:"distributionHostedZoneId" type:"string"`

	// The custom domain name as an API host name, for example, my-api.example.com.
	DomainName *string `locationName:"domainName" type:"string"`

	// The endpoint configuration of this DomainName showing the endpoint types
	// of the domain name.
	EndpointConfiguration *EndpointConfiguration `locationName:"endpointConfiguration" type:"structure"`

	// The reference to an AWS-managed certificate that will be used for validating
	// the regional domain name. AWS Certificate Manager is the only supported source.
	RegionalCertificateArn *string `locationName:"regionalCertificateArn" type:"string"`

	// The name of the certificate that will be used for validating the regional
	// domain name.
	RegionalCertificateName *string `locationName:"regionalCertificateName" type:"string"`

	// The domain name associated with the regional endpoint for this custom domain
	// name. You set up this association by adding a DNS record that points the
	// custom domain name to this regional domain name. The regional domain name
	// is returned by API Gateway when you create a regional endpoint.
	RegionalDomainName *string `locationName:"regionalDomainName" type:"string"`

	// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint.
	// For more information, see Set up a Regional Custom Domain Name (https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html)
	// and AWS Regions and Endpoints for API Gateway (https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
	RegionalHostedZoneId *string `locationName:"regionalHostedZoneId" type:"string"`
}

// String returns the string representation
func (s UpdateDomainNameOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDomainNameOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateDomainNameOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateDomainNameOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.CertificateArn != nil {
		v := *s.CertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateName != nil {
		v := *s.CertificateName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CertificateUploadDate != nil {
		v := *s.CertificateUploadDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "certificateUploadDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.DistributionDomainName != nil {
		v := *s.DistributionDomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "distributionDomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DistributionHostedZoneId != nil {
		v := *s.DistributionHostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "distributionHostedZoneId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DomainName != nil {
		v := *s.DomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "domainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EndpointConfiguration != nil {
		v := s.EndpointConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "endpointConfiguration", v, metadata)
	}
	if s.RegionalCertificateArn != nil {
		v := *s.RegionalCertificateArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "regionalCertificateArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RegionalCertificateName != nil {
		v := *s.RegionalCertificateName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "regionalCertificateName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RegionalDomainName != nil {
		v := *s.RegionalDomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "regionalDomainName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RegionalHostedZoneId != nil {
		v := *s.RegionalHostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "regionalHostedZoneId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Updates a GatewayResponse of a specified response type on the given RestApi.
type UpdateGatewayResponseInput struct {
	_ struct{} `type:"structure"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The response type of the associated GatewayResponse. Valid values
	// are ACCESS_DENIED
	// API_CONFIGURATION_ERROR
	// AUTHORIZER_FAILURE
	//  AUTHORIZER_CONFIGURATION_ERROR
	// BAD_REQUEST_PARAMETERS
	// BAD_REQUEST_BODY
	// DEFAULT_4XX
	// DEFAULT_5XX
	// EXPIRED_TOKEN
	// INVALID_SIGNATURE
	// INTEGRATION_FAILURE
	// INTEGRATION_TIMEOUT
	// INVALID_API_KEY
	// MISSING_AUTHENTICATION_TOKEN
	//  QUOTA_EXCEEDED
	// REQUEST_TOO_LARGE
	// RESOURCE_NOT_FOUND
	// THROTTLED
	// UNAUTHORIZED
	// UNSUPPORTED_MEDIA_TYPE
	//
	// ResponseType is a required field
	ResponseType GatewayResponseType `location:"uri" locationName:"response_type" type:"string" required:"true" enum:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateGatewayResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGatewayResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateGatewayResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateGatewayResponseInput"}
	if len(s.ResponseType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResponseType"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateGatewayResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.ResponseType) > 0 {
		v := s.ResponseType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "response_type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A gateway response of a given response type and status code, with optional
// response parameters and mapping templates.
//
// For more information about valid gateway response types, see Gateway Response
// Types Supported by API Gateway (https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html)Example:
// Get a Gateway Response of a given response type
//
// Request
//
// This example shows how to get a gateway response of the MISSING_AUTHENTICATION_TOKEN
// type.
//
// GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1
// Host: beta-apigateway.us-east-1.amazonaws.com Content-Type: application/json
// X-Amz-Date: 20170503T202516Z Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request,
// SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a
// Cache-Control: no-cache Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45
//
// The response type is specified as a URL path.
//
// Response
//
// The successful operation returns the 200 OK status code and a payload similar
// to the following:
//
// { "_links": { "curies": { "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html",
// "name": "gatewayresponse", "templated": true }, "self": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
// }, "gatewayresponse:delete": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
// }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}",
// "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN"
// } }, "defaultResponse": false, "responseParameters": { "gatewayresponse.header.x-request-path":
// "method.request.path.petId", "gatewayresponse.header.Access-Control-Allow-Origin":
// "'a.b.c'", "gatewayresponse.header.x-request-query": "method.request.querystring.q",
// "gatewayresponse.header.x-request-header": "method.request.header.Accept"
// }, "responseTemplates": { "application/json": "{\n \"message\": $context.error.messageString,\n
// \"type\": \"$context.error.responseType\",\n \"stage\": \"$context.stage\",\n
// \"resourcePath\": \"$context.resourcePath\",\n \"stageVariables.a\": \"$stageVariables.a\",\n
// \"statusCode\": \"'404'\"\n}" }, "responseType": "MISSING_AUTHENTICATION_TOKEN",
// "statusCode": "404" }
//
// Customize Gateway Responses (https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html)
type UpdateGatewayResponseOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A Boolean flag to indicate whether this GatewayResponse is the default gateway
	// response (true) or not (false). A default gateway response is one generated
	// by API Gateway without any customization by an API developer.
	DefaultResponse *bool `locationName:"defaultResponse" type:"boolean"`

	// Response parameters (paths, query strings and headers) of the GatewayResponse
	// as a string-to-string map of key-value pairs.
	ResponseParameters map[string]string `locationName:"responseParameters" type:"map"`

	// Response templates of the GatewayResponse as a string-to-string map of key-value
	// pairs.
	ResponseTemplates map[string]string `locationName:"responseTemplates" type:"map"`

	// The response type of the associated GatewayResponse. Valid values are ACCESS_DENIED
	//
	// API_CONFIGURATION_ERROR
	// AUTHORIZER_FAILURE
	//  AUTHORIZER_CONFIGURATION_ERROR
	// BAD_REQUEST_PARAMETERS
	// BAD_REQUEST_BODY
	// DEFAULT_4XX
	// DEFAULT_5XX
	// EXPIRED_TOKEN
	// INVALID_SIGNATURE
	// INTEGRATION_FAILURE
	// INTEGRATION_TIMEOUT
	// INVALID_API_KEY
	// MISSING_AUTHENTICATION_TOKEN
	//  QUOTA_EXCEEDED
	// REQUEST_TOO_LARGE
	// RESOURCE_NOT_FOUND
	// THROTTLED
	// UNAUTHORIZED
	// UNSUPPORTED_MEDIA_TYPE
	ResponseType GatewayResponseType `locationName:"responseType" type:"string" enum:"true"`

	// The HTTP status code for this GatewayResponse.
	StatusCode *string `locationName:"statusCode" type:"string"`
}

// String returns the string representation
func (s UpdateGatewayResponseOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateGatewayResponseOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateGatewayResponseOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateGatewayResponseOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DefaultResponse != nil {
		v := *s.DefaultResponse

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "defaultResponse", protocol.BoolValue(v), metadata)
	}
	if len(s.ResponseParameters) > 0 {
		v := s.ResponseParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.ResponseTemplates) > 0 {
		v := s.ResponseTemplates

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseTemplates", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.ResponseType) > 0 {
		v := s.ResponseType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "responseType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents an update integration request.
type UpdateIntegrationInput struct {
	_ struct{} `type:"structure"`

	// [Required] Represents an update integration request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] Represents an update integration request's resource identifier.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateIntegrationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateIntegrationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateIntegrationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateIntegrationInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateIntegrationInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration.
//
// In the API Gateway console, the built-in Lambda integration is an AWS integration.
//
// Creating an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
type UpdateIntegrationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Specifies the integration's cache key parameters.
	CacheKeyParameters []string `locationName:"cacheKeyParameters" type:"list"`

	// Specifies the integration's cache namespace.
	CacheNamespace *string `locationName:"cacheNamespace" type:"string"`

	// The (id (https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id))
	// of the VpcLink used for the integration when connectionType=VPC_LINK and
	// undefined, otherwise.
	ConnectionId *string `locationName:"connectionId" type:"string"`

	// The type of the network connection to the integration endpoint. The valid
	// value is INTERNET for connections through the public routable internet or
	// VPC_LINK for private connections between API Gateway and a network load balancer
	// in a VPC. The default value is INTERNET.
	ConnectionType ConnectionType `locationName:"connectionType" type:"string" enum:"true"`

	// Specifies how to handle request payload content type conversions. Supported
	// values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
	//
	//    * CONVERT_TO_BINARY: Converts a request payload from a Base64-encoded
	//    string to the corresponding binary blob.
	//
	//    * CONVERT_TO_TEXT: Converts a request payload from a binary blob to a
	//    Base64-encoded string.
	//
	// If this property is not defined, the request payload will be passed through
	// from the method request to integration request without modification, provided
	// that the passthroughBehaviors is configured to support payload pass-through.
	ContentHandling ContentHandlingStrategy `locationName:"contentHandling" type:"string" enum:"true"`

	// Specifies the credentials required for the integration, if any. For AWS integrations,
	// three options are available. To specify an IAM Role for API Gateway to assume,
	// use the role's Amazon Resource Name (ARN). To require that the caller's identity
	// be passed through from the request, specify the string arn:aws:iam::\*:user/\*.
	// To use resource-based permissions on supported AWS services, specify null.
	Credentials *string `locationName:"credentials" type:"string"`

	// Specifies the integration's HTTP method type.
	HttpMethod *string `locationName:"httpMethod" type:"string"`

	// Specifies the integration's responses.
	//
	// Example: Get integration responses of a method
	//
	// Request
	//
	// GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200
	// HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com
	// X-Amz-Date: 20160607T191449Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request,
	// SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
	// Response
	//
	// The successful response returns 200 OKstatus and a payload as follows:
	//
	// { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
	// "name": "integrationresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
	// "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
	// }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
	// } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'"
	// }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream
	// in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
	// }, "statusCode": "200" }
	IntegrationResponses map[string]UpdateIntegrationResponseOutput `locationName:"integrationResponses" type:"map"`

	// Specifies how the method request body of an unmapped content type will be
	// passed through the integration request to the back end without transformation.
	// A content type is unmapped if no mapping template is defined in the integration
	// or the content type does not match any of the mapped content types, as specified
	// in requestTemplates. The valid value is one of the following:
	//
	// WHEN_NO_MATCH: passes the method request body through the integration request
	// to the back end without transformation when the method request content type
	// does not match any content type associated with the mapping templates defined
	// in the integration request.
	// WHEN_NO_TEMPLATES: passes the method request body through the integration
	// request to the back end without transformation when no mapping template is
	// defined in the integration request. If a template is defined when this option
	// is selected, the method request of an unmapped content-type will be rejected
	// with an HTTP 415 Unsupported Media Type response.
	// NEVER: rejects the method request with an HTTP 415 Unsupported Media Type
	// response when either the method request content type does not match any content
	// type associated with the mapping templates defined in the integration request
	// or no mapping template is defined in the integration request.
	PassthroughBehavior *string `locationName:"passthroughBehavior" type:"string"`

	// A key-value map specifying request parameters that are passed from the method
	// request to the back end. The key is an integration request parameter name
	// and the associated value is a method request parameter value or static value
	// that must be enclosed within single quotes and pre-encoded as required by
	// the back end. The method request parameter value must match the pattern of
	// method.request.{location}.{name}, where location is querystring, path, or
	// header and name must be a valid and unique method request parameter name.
	RequestParameters map[string]string `locationName:"requestParameters" type:"map"`

	// Represents a map of Velocity templates that are applied on the request payload
	// based on the value of the Content-Type header sent by the client. The content
	// type value is the key in this map, and the template (as a String) is the
	// value.
	RequestTemplates map[string]string `locationName:"requestTemplates" type:"map"`

	// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000
	// milliseconds or 29 seconds.
	TimeoutInMillis *int64 `locationName:"timeoutInMillis" type:"integer"`

	// Specifies an API method integration type. The valid value is one of the following:
	//
	//    * AWS: for integrating the API method request with an AWS service action,
	//    including the Lambda function-invoking action. With the Lambda function-invoking
	//    action, this is referred to as the Lambda custom integration. With any
	//    other AWS service action, this is known as AWS integration.
	//    * AWS_PROXY: for integrating the API method request with the Lambda function-invoking
	//    action with the client request passed through as-is. This integration
	//    is also referred to as the Lambda proxy integration.
	//    * HTTP: for integrating the API method request with an HTTP endpoint,
	//    including a private HTTP endpoint within a VPC. This integration is also
	//    referred to as the HTTP custom integration.
	//    * HTTP_PROXY: for integrating the API method request with an HTTP endpoint,
	//    including a private HTTP endpoint within a VPC, with the client request
	//    passed through as-is. This is also referred to as the HTTP proxy integration.
	//
	//    * MOCK: for integrating the API method request with API Gateway as a "loop-back"
	//    endpoint without invoking any backend.
	// For the HTTP and HTTP proxy integrations, each integration can specify a
	// protocol (http/https), port and path. Standard 80 and 443 ports are supported
	// as well as custom ports above 1024. An HTTP or HTTP proxy integration with
	// a connectionType of VPC_LINK is referred to as a private integration and
	// uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
	Type IntegrationType `locationName:"type" type:"string" enum:"true"`

	// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
	//
	//    *  For HTTP or HTTP_PROXY integrations, the URI must be a fully formed,
	//    encoded HTTP(S) URL according to the RFC-3986 specification (_blank),
	//    for either standard integration, where connectionType is not VPC_LINK,
	//    or private integration, where connectionType is VPC_LINK. For a private
	//    HTTP integration, the URI is not used for routing.
	//
	//    *  For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}.
	//    Here, {Region} is the API Gateway region (e.g., us-east-1); {service}
	//    is the name of the integrated AWS service (e.g., s3); and {subdomain}
	//    is a designated subdomain supported by certain AWS service for fast host-name
	//    lookup. action can be used for an AWS service action-based API, using
	//    an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api}
	//    refers to a supported action {name} plus any required input parameters.
	//    Alternatively, path can be used for an AWS service path-based API. The
	//    ensuing service_api refers to the path to an AWS service resource, including
	//    the region of the integrated AWS service, if applicable. For example,
	//    for integration with the S3 API of GetObject (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html),
	//    the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}
	//    or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
	Uri *string `locationName:"uri" type:"string"`
}

// String returns the string representation
func (s UpdateIntegrationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateIntegrationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateIntegrationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateIntegrationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.CacheKeyParameters) > 0 {
		v := s.CacheKeyParameters

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "cacheKeyParameters", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.CacheNamespace != nil {
		v := *s.CacheNamespace

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheNamespace", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ConnectionId != nil {
		v := *s.ConnectionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "connectionId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ConnectionType) > 0 {
		v := s.ConnectionType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "connectionType", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.ContentHandling) > 0 {
		v := s.ContentHandling

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "contentHandling", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Credentials != nil {
		v := *s.Credentials

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "credentials", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "httpMethod", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.IntegrationResponses) > 0 {
		v := s.IntegrationResponses

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "integrationResponses", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if s.PassthroughBehavior != nil {
		v := *s.PassthroughBehavior

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "passthroughBehavior", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RequestParameters) > 0 {
		v := s.RequestParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "requestParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.RequestTemplates) > 0 {
		v := s.RequestTemplates

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "requestTemplates", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.TimeoutInMillis != nil {
		v := *s.TimeoutInMillis

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "timeoutInMillis", protocol.Int64Value(v), metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "type", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.Uri != nil {
		v := *s.Uri

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "uri", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents an update integration response request.
type UpdateIntegrationResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] Specifies an update integration response request's HTTP method.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] Specifies an update integration response request's resource identifier.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] Specifies an update integration response request's status code.
	//
	// StatusCode is a required field
	StatusCode *string `location:"uri" locationName:"status_code" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateIntegrationResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateIntegrationResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateIntegrationResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateIntegrationResponseInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StatusCode == nil {
		invalidParams.Add(aws.NewErrParamRequired("StatusCode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateIntegrationResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "status_code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents an integration response. The status code must map to an existing
// MethodResponse, and parameters and templates can be used to transform the
// back-end response.
//
// Creating an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
type UpdateIntegrationResponseOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Specifies how to handle response payload content type conversions. Supported
	// values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
	//
	//    * CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded
	//    string to the corresponding binary blob.
	//
	//    * CONVERT_TO_TEXT: Converts a response payload from a binary blob to a
	//    Base64-encoded string.
	//
	// If this property is not defined, the response payload will be passed through
	// from the integration response to the method response without modification.
	ContentHandling ContentHandlingStrategy `locationName:"contentHandling" type:"string" enum:"true"`

	// A key-value map specifying response parameters that are passed to the method
	// response from the back end. The key is a method response header parameter
	// name and the mapped value is an integration response header value, a static
	// value enclosed within a pair of single quotes, or a JSON expression from
	// the integration response body. The mapping key must match the pattern of
	// method.response.header.{name}, where name is a valid and unique header name.
	// The mapped non-static value must match the pattern of integration.response.header.{name}
	// or integration.response.body.{JSON-expression}, where name is a valid and
	// unique response header name and JSON-expression is a valid JSON expression
	// without the $ prefix.
	ResponseParameters map[string]string `locationName:"responseParameters" type:"map"`

	// Specifies the templates used to transform the integration response body.
	// Response templates are represented as a key/value map, with a content-type
	// as the key and a template as the value.
	ResponseTemplates map[string]string `locationName:"responseTemplates" type:"map"`

	// Specifies the regular expression (regex) pattern used to choose an integration
	// response based on the response from the back end. For example, if the success
	// response returns nothing and the error response returns some string, you
	// could use the .+ regex to match error response. However, make sure that the
	// error response does not contain any newline (\n) character in such cases.
	// If the back end is an AWS Lambda function, the AWS Lambda function error
	// header is matched. For all other HTTP and AWS back ends, the HTTP status
	// code is matched.
	SelectionPattern *string `locationName:"selectionPattern" type:"string"`

	// Specifies the status code that is used to map the integration response to
	// an existing MethodResponse.
	StatusCode *string `locationName:"statusCode" type:"string"`
}

// String returns the string representation
func (s UpdateIntegrationResponseOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateIntegrationResponseOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateIntegrationResponseOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateIntegrationResponseOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ContentHandling) > 0 {
		v := s.ContentHandling

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "contentHandling", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.ResponseParameters) > 0 {
		v := s.ResponseParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.ResponseTemplates) > 0 {
		v := s.ResponseTemplates

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseTemplates", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.SelectionPattern != nil {
		v := *s.SelectionPattern

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "selectionPattern", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to update an existing Method resource.
type UpdateMethodInput struct {
	_ struct{} `type:"structure"`

	// [Required] The HTTP verb of the Method resource.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The Resource identifier for the Method resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateMethodInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateMethodInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateMethodInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateMethodInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateMethodInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a client-facing interface by which the client calls the API to
// access back-end resources. A Method resource is integrated with an Integration
// resource. Both consist of a request and one or more responses. The method
// request takes the client input that is passed to the back end through the
// integration request. A method response returns the output from the back end
// to the client through an integration response. A method request is embodied
// in a Method resource, whereas an integration request is embodied in an Integration
// resource. On the other hand, a method response is represented by a MethodResponse
// resource, whereas an integration response is represented by an IntegrationResponse
// resource.
//
// Example: Retrive the GET method on a specified resource
//
// Request
//
// The following example request retrieves the information about the GET method
// on an API resource (3kzxbg5sa2) of an API (fugvjdxtri).
//
//    GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type:
//    application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date:
//    20160603T210259Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request,
//    SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
// Response
//
// The successful response returns a 200 OK status code and a payload similar
// to the following:
//
//    { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
//    "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
//    "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
//    "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
//    "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
//    "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
//    }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
//    }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
//    }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
//    "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
//    }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
//    "templated": true } }, "apiKeyRequired": true, "authorizationType": "NONE",
//    "httpMethod": "GET", "_embedded": { "method:integration": { "_links":
//    { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
//    }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
//    }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
//    "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
//    }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
//    "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2",
//    "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod":
//    "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": {
//    "integration.request.header.Content-Type": "'application/x-amz-json-1.1'"
//    }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS",
//    "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded":
//    { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
//    "name": "200", "title": "200" }, "integrationresponse:delete": { "href":
//    "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
//    }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
//    } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'"
//    }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")"
//    }, "statusCode": "200" } } }, "method:responses": { "_links": { "self":
//    { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
//    "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
//    }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
//    } }, "responseModels": { "application/json": "Empty" }, "responseParameters":
//    { "method.response.header.Content-Type": false }, "statusCode": "200"
//    } } }
// In the example above, the response template for the 200 OK response maps
// the JSON output from the ListStreams action in the back end to an XML output.
// The mapping template is URL-encoded as %3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E
// and the output is decoded using the $util.urlDecode() (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference)
// helper function.
//
// MethodResponse, Integration, IntegrationResponse, Resource, Set up an API's method (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html)
type UpdateMethodOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A boolean flag specifying whether a valid ApiKey is required to invoke this
	// method.
	ApiKeyRequired *bool `locationName:"apiKeyRequired" type:"boolean"`

	// A list of authorization scopes configured on the method. The scopes are used
	// with a COGNITO_USER_POOLS authorizer to authorize the method invocation.
	// The authorization works by matching the method scopes against the scopes
	// parsed from the access token in the incoming request. The method invocation
	// is authorized if any method scopes matches a claimed scope in the access
	// token. Otherwise, the invocation is not authorized. When the method scope
	// is configured, the client must provide an access token instead of an identity
	// token for authorization purposes.
	AuthorizationScopes []string `locationName:"authorizationScopes" type:"list"`

	// The method's authorization type. Valid values are NONE for open access, AWS_IAM
	// for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS
	// for using a Cognito user pool.
	AuthorizationType *string `locationName:"authorizationType" type:"string"`

	// The identifier of an Authorizer to use on this method. The authorizationType
	// must be CUSTOM.
	AuthorizerId *string `locationName:"authorizerId" type:"string"`

	// The method's HTTP verb.
	HttpMethod *string `locationName:"httpMethod" type:"string"`

	// Gets the method's integration responsible for passing the client-submitted
	// request to the back end and performing necessary transformations to make
	// the request compliant with the back end.
	//
	// Example:
	//
	// Request
	//
	// GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1
	// Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length:
	// 117 X-Amz-Date: 20160613T213210Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request,
	// SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
	// Response
	//
	// The successful response returns a 200 OKstatus code and a payload similar to the following:
	//
	// { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
	// "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
	// "name": "integrationresponse", "templated": true } ], "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
	// }, "integration:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
	// }, "integration:responses": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
	// "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration"
	// }, "integrationresponse:put": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}",
	// "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "0cjtch",
	// "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod":
	// "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestTemplates": { "application/json":
	// "{\n \"a\": \"$input.params('operand1')\",\n \"b\": \"$input.params('operand2')\",
	// \n \"op\": \"$input.params('operator')\" \n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations",
	// "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200",
	// "name": "200", "title": "200" }, "integrationresponse:delete": { "href":
	// "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
	// }, "integrationresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200"
	// } }, "responseParameters": { "method.response.header.operator": "integration.response.body.op",
	// "method.response.header.operand_2": "integration.response.body.b", "method.response.header.operand_1":
	// "integration.response.body.a" }, "responseTemplates": { "application/json":
	// "#set($res = $input.path('$'))\n{\n \"result\": \"$res.a, $res.b, $res.op
	// => $res.c\",\n \"a\" : \"$res.a\",\n \"b\" : \"$res.b\",\n \"op\" : \"$res.op\",\n
	// \"c\" : \"$res.c\"\n}" }, "selectionPattern": "", "statusCode": "200" } }
	// }
	MethodIntegration *UpdateIntegrationOutput `locationName:"methodIntegration" type:"structure"`

	// Gets a method response associated with a given HTTP status code.
	//
	// The collection of method responses are encapsulated in a key-value map, where
	// the key is a response's HTTP status code and the value is a MethodResponse
	// resource that specifies the response returned to the caller from the back
	// end through the integration response.
	//
	// Example: Get a 200 OK response of a GET method
	//
	// Request
	//
	//    GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1
	//    Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com
	//    Content-Length: 117 X-Amz-Date: 20160613T215008Z Authorization: AWS4-HMAC-SHA256
	//    Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request,
	//    SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
	// Response
	//
	// The successful response returns a 200 OK status code and a payload similar
	// to the following:
	//
	//    { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
	//    "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200",
	//    "title": "200" }, "methodresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
	//    }, "methodresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200"
	//    } }, "responseModels": { "application/json": "Empty" }, "responseParameters":
	//    { "method.response.header.operator": false, "method.response.header.operand_2":
	//    false, "method.response.header.operand_1": false }, "statusCode": "200"
	//    }
	MethodResponses map[string]UpdateMethodResponseOutput `locationName:"methodResponses" type:"map"`

	// A human-friendly operation identifier for the method. For example, you can
	// assign the operationName of ListPets for the GET /pets method in PetStore
	// (https://petstore-demo-endpoint.execute-api.com/petstore/pets) example.
	OperationName *string `locationName:"operationName" type:"string"`

	// A key-value map specifying data schemas, represented by Model resources,
	// (as the mapped value) of the request payloads of given content types (as
	// the mapping key).
	RequestModels map[string]string `locationName:"requestModels" type:"map"`

	// A key-value map defining required or optional method request parameters that
	// can be accepted by API Gateway. A key is a method request parameter name
	// matching the pattern of method.request.{location}.{name}, where location
	// is querystring, path, or header and name is a valid and unique parameter
	// name. The value associated with the key is a Boolean flag indicating whether
	// the parameter is required (true) or optional (false). The method request
	// parameter names defined here are available in Integration to be mapped to
	// integration request parameters or templates.
	RequestParameters map[string]bool `locationName:"requestParameters" type:"map"`

	// The identifier of a RequestValidator for request validation.
	RequestValidatorId *string `locationName:"requestValidatorId" type:"string"`
}

// String returns the string representation
func (s UpdateMethodOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateMethodOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateMethodOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateMethodOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ApiKeyRequired != nil {
		v := *s.ApiKeyRequired

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "apiKeyRequired", protocol.BoolValue(v), metadata)
	}
	if len(s.AuthorizationScopes) > 0 {
		v := s.AuthorizationScopes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "authorizationScopes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.AuthorizationType != nil {
		v := *s.AuthorizationType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizationType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.AuthorizerId != nil {
		v := *s.AuthorizerId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "authorizerId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "httpMethod", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MethodIntegration != nil {
		v := s.MethodIntegration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "methodIntegration", v, metadata)
	}
	if len(s.MethodResponses) > 0 {
		v := s.MethodResponses

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "methodResponses", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if s.OperationName != nil {
		v := *s.OperationName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "operationName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.RequestModels) > 0 {
		v := s.RequestModels

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "requestModels", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.RequestParameters) > 0 {
		v := s.RequestParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "requestParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.BoolValue(v1))
		}
		ms0.End()

	}
	if s.RequestValidatorId != nil {
		v := *s.RequestValidatorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "requestValidatorId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A request to update an existing MethodResponse resource.
type UpdateMethodResponseInput struct {
	_ struct{} `type:"structure"`

	// [Required] The HTTP verb of the Method resource.
	//
	// HttpMethod is a required field
	HttpMethod *string `location:"uri" locationName:"http_method" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The Resource identifier for the MethodResponse resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The status code for the MethodResponse resource.
	//
	// StatusCode is a required field
	StatusCode *string `location:"uri" locationName:"status_code" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateMethodResponseInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateMethodResponseInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateMethodResponseInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateMethodResponseInput"}

	if s.HttpMethod == nil {
		invalidParams.Add(aws.NewErrParamRequired("HttpMethod"))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StatusCode == nil {
		invalidParams.Add(aws.NewErrParamRequired("StatusCode"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateMethodResponseInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.HttpMethod != nil {
		v := *s.HttpMethod

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "http_method", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "status_code", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a method response of a given HTTP status code returned to the
// client. The method response is passed from the back end through the associated
// integration response that can be transformed using a mapping template.
//
// Example: A MethodResponse instance of an API
//
// Request
//
// The example request retrieves a MethodResponse of the 200 status code.
//
//    GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200
//    HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com
//    X-Amz-Date: 20160603T222952Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request,
//    SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
// Response
//
// The successful response returns 200 OK status and a payload as follows:
//
//    { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
//    "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
//    "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
//    }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
//    } }, "responseModels": { "application/json": "Empty" }, "responseParameters":
//    { "method.response.header.Content-Type": false }, "statusCode": "200"
//    }
type UpdateMethodResponseOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Specifies the Model resources used for the response's content-type. Response
	// models are represented as a key/value map, with a content-type as the key
	// and a Model name as the value.
	ResponseModels map[string]string `locationName:"responseModels" type:"map"`

	// A key-value map specifying required or optional response parameters that
	// API Gateway can send back to the caller. A key defines a method response
	// header and the value specifies whether the associated method response header
	// is required or not. The expression of the key must match the pattern method.response.header.{name},
	// where name is a valid and unique header name. API Gateway passes certain
	// integration response data to the method response headers specified here according
	// to the mapping you prescribe in the API's IntegrationResponse. The integration
	// response data that can be mapped include an integration response header expressed
	// in integration.response.header.{name}, a static value enclosed within a pair
	// of single quotes (e.g., 'application/json'), or a JSON expression from the
	// back-end response payload in the form of integration.response.body.{JSON-expression},
	// where JSON-expression is a valid JSON expression without the $ prefix.)
	ResponseParameters map[string]bool `locationName:"responseParameters" type:"map"`

	// The method response's status code.
	StatusCode *string `locationName:"statusCode" type:"string"`
}

// String returns the string representation
func (s UpdateMethodResponseOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateMethodResponseOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateMethodResponseOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateMethodResponseOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ResponseModels) > 0 {
		v := s.ResponseModels

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseModels", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if len(s.ResponseParameters) > 0 {
		v := s.ResponseParameters

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "responseParameters", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.BoolValue(v1))
		}
		ms0.End()

	}
	if s.StatusCode != nil {
		v := *s.StatusCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Request to update an existing model in an existing RestApi resource.
type UpdateModelInput struct {
	_ struct{} `type:"structure"`

	// [Required] The name of the model to update.
	//
	// ModelName is a required field
	ModelName *string `location:"uri" locationName:"model_name" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateModelInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateModelInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateModelInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateModelInput"}

	if s.ModelName == nil {
		invalidParams.Add(aws.NewErrParamRequired("ModelName"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateModelInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ModelName != nil {
		v := *s.ModelName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "model_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the data structure of a method's request or response payload.
//
// A request model defines the data structure of the client-supplied request
// payload. A response model defines the data structure of the response payload
// returned by the back end. Although not required, models are useful for mapping
// payloads between the front end and back end.
//
// A model is used for generating an API's SDK, validating the input request
// body, and creating a skeletal mapping template.
//
// Method, MethodResponse, Models and Mappings (https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html)
type UpdateModelOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The content-type for the model.
	ContentType *string `locationName:"contentType" type:"string"`

	// The description of the model.
	Description *string `locationName:"description" type:"string"`

	// The identifier for the model resource.
	Id *string `locationName:"id" type:"string"`

	// The name of the model. Must be an alphanumeric string.
	Name *string `locationName:"name" type:"string"`

	// The schema for the model. For application/json models, this should be JSON
	// schema draft 4 (https://tools.ietf.org/html/draft-zyp-json-schema-04) model.
	// Do not include "\*/" characters in the description of any properties because
	// such "\*/" characters may be interpreted as the closing marker for comments
	// in some languages, such as Java or JavaScript, causing the installation of
	// your API's SDK generated by API Gateway to fail.
	Schema *string `locationName:"schema" type:"string"`
}

// String returns the string representation
func (s UpdateModelOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateModelOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateModelOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateModelOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "contentType", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Schema != nil {
		v := *s.Schema

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "schema", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Updates a RequestValidator of a given RestApi.
type UpdateRequestValidatorInput struct {
	_ struct{} `type:"structure"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The identifier of RequestValidator to be updated.
	//
	// RequestValidatorId is a required field
	RequestValidatorId *string `location:"uri" locationName:"requestvalidator_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateRequestValidatorInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRequestValidatorInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateRequestValidatorInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateRequestValidatorInput"}

	if s.RequestValidatorId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RequestValidatorId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateRequestValidatorInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RequestValidatorId != nil {
		v := *s.RequestValidatorId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "requestvalidator_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A set of validation rules for incoming Method requests.
//
// In OpenAPI, a RequestValidator of an API is defined by the x-amazon-apigateway-request-validators.requestValidator
// (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html)
// object. It the referenced using the x-amazon-apigateway-request-validator
// (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator)
// property.
//
// Enable Basic Request Validation in API Gateway (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html)
type UpdateRequestValidatorOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The identifier of this RequestValidator.
	Id *string `locationName:"id" type:"string"`

	// The name of this RequestValidator
	Name *string `locationName:"name" type:"string"`

	// A Boolean flag to indicate whether to validate a request body according to
	// the configured Model schema.
	ValidateRequestBody *bool `locationName:"validateRequestBody" type:"boolean"`

	// A Boolean flag to indicate whether to validate request parameters (true)
	// or not (false).
	ValidateRequestParameters *bool `locationName:"validateRequestParameters" type:"boolean"`
}

// String returns the string representation
func (s UpdateRequestValidatorOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRequestValidatorOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateRequestValidatorOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateRequestValidatorOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ValidateRequestBody != nil {
		v := *s.ValidateRequestBody

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "validateRequestBody", protocol.BoolValue(v), metadata)
	}
	if s.ValidateRequestParameters != nil {
		v := *s.ValidateRequestParameters

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "validateRequestParameters", protocol.BoolValue(v), metadata)
	}
	return nil
}

// Request to change information about a Resource resource.
type UpdateResourceInput struct {
	_ struct{} `type:"structure"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The identifier of the Resource resource.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"resource_id" type:"string" required:"true"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateResourceInput"}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "resource_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents an API resource.
//
// Create an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
type UpdateResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The resource's identifier.
	Id *string `locationName:"id" type:"string"`

	// The parent resource's identifier.
	ParentId *string `locationName:"parentId" type:"string"`

	// The full path for this resource.
	Path *string `locationName:"path" type:"string"`

	// The last path segment for this resource.
	PathPart *string `locationName:"pathPart" type:"string"`

	// Gets an API resource's method of a given HTTP verb.
	//
	// The resource methods are a map of methods indexed by methods' HTTP verbs
	// enabled on the resource. This method map is included in the 200 OK response
	// of the GET /restapis/{restapi_id}/resources/{resource_id} or GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods
	// request.
	//
	// Example: Get the GET method of an API resource
	//
	// Request
	//
	// GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type:
	// application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20170223T031827Z
	// Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request,
	// SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
	// Response
	//
	// { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html",
	// "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html",
	// "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html",
	// "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html",
	// "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET",
	// "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
	// }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
	// }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
	// }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
	// "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET"
	// }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}",
	// "templated": true } }, "apiKeyRequired": false, "authorizationType": "NONE",
	// "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self":
	// { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
	// }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
	// }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
	// "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration"
	// }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}",
	// "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2",
	// "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod":
	// "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type":
	// "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json":
	// "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams",
	// "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200",
	// "name": "200", "title": "200" }, "integrationresponse:delete": { "href":
	// "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
	// }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200"
	// } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'"
	// }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream
	// in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n"
	// }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": {
	// "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200",
	// "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
	// }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200"
	// } }, "responseModels": { "application/json": "Empty" }, "responseParameters":
	// { "method.response.header.Content-Type": false }, "statusCode": "200" } }
	// }
	// If the OPTIONS is enabled on the resource, you can follow the example here
	// to get that method. Just replace the GET of the last path segment in the
	// request URL with OPTIONS.
	ResourceMethods map[string]UpdateMethodOutput `locationName:"resourceMethods" type:"map"`
}

// String returns the string representation
func (s UpdateResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ParentId != nil {
		v := *s.ParentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "parentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Path != nil {
		v := *s.Path

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "path", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.PathPart != nil {
		v := *s.PathPart

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "pathPart", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.ResourceMethods) > 0 {
		v := s.ResourceMethods

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "resourceMethods", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	return nil
}

// Request to update an existing RestApi resource in your collection.
type UpdateRestApiInput struct {
	_ struct{} `type:"structure"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateRestApiInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRestApiInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateRestApiInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateRestApiInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateRestApiInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a REST API.
//
// Create an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
type UpdateRestApiOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The source of the API key for metering requests according to a usage plan.
	// Valid values are: HEADER to read the API key from the X-API-Key header of
	// a request.
	// AUTHORIZER to read the API key from the UsageIdentifierKey from a custom
	// authorizer.
	ApiKeySource ApiKeySourceType `locationName:"apiKeySource" type:"string" enum:"true"`

	// The list of binary media types supported by the RestApi. By default, the
	// RestApi supports only UTF-8-encoded text payloads.
	BinaryMediaTypes []string `locationName:"binaryMediaTypes" type:"list"`

	// The timestamp when the API was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// The API's description.
	Description *string `locationName:"description" type:"string"`

	// The endpoint configuration of this RestApi showing the endpoint types of
	// the API.
	EndpointConfiguration *EndpointConfiguration `locationName:"endpointConfiguration" type:"structure"`

	// The API's identifier. This identifier is unique across all of your APIs in
	// API Gateway.
	Id *string `locationName:"id" type:"string"`

	// A nullable integer that is used to enable compression (with non-negative
	// between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with
	// a null value) on an API. When compression is enabled, compression or decompression
	// is not applied on the payload if the payload size is smaller than this value.
	// Setting it to zero allows compression for any payload size.
	MinimumCompressionSize *int64 `locationName:"minimumCompressionSize" type:"integer"`

	// The API's name.
	Name *string `locationName:"name" type:"string"`

	// A stringified JSON policy document that applies to this RestApi regardless
	// of the caller and Method
	Policy *string `locationName:"policy" type:"string"`

	// A version identifier for the API.
	Version *string `locationName:"version" type:"string"`

	// The warning messages reported when failonwarnings is turned on during API
	// import.
	Warnings []string `locationName:"warnings" type:"list"`
}

// String returns the string representation
func (s UpdateRestApiOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRestApiOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateRestApiOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateRestApiOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ApiKeySource) > 0 {
		v := s.ApiKeySource

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "apiKeySource", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.BinaryMediaTypes) > 0 {
		v := s.BinaryMediaTypes

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "binaryMediaTypes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.EndpointConfiguration != nil {
		v := s.EndpointConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "endpointConfiguration", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.MinimumCompressionSize != nil {
		v := *s.MinimumCompressionSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "minimumCompressionSize", protocol.Int64Value(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Policy != nil {
		v := *s.Policy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "policy", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "version", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Warnings) > 0 {
		v := s.Warnings

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "warnings", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

// Requests API Gateway to change information about a Stage resource.
type UpdateStageInput struct {
	_ struct{} `type:"structure"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The string identifier of the associated RestApi.
	//
	// RestApiId is a required field
	RestApiId *string `location:"uri" locationName:"restapi_id" type:"string" required:"true"`

	// [Required] The name of the Stage resource to change information about.
	//
	// StageName is a required field
	StageName *string `location:"uri" locationName:"stage_name" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateStageInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateStageInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateStageInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateStageInput"}

	if s.RestApiId == nil {
		invalidParams.Add(aws.NewErrParamRequired("RestApiId"))
	}

	if s.StageName == nil {
		invalidParams.Add(aws.NewErrParamRequired("StageName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateStageInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.RestApiId != nil {
		v := *s.RestApiId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "restapi_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "stage_name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a unique identifier for a version of a deployed RestApi that is
// callable by users.
//
// Deploy an API (https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html)
type UpdateStageOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// Settings for logging access in this stage.
	AccessLogSettings *AccessLogSettings `locationName:"accessLogSettings" type:"structure"`

	// Specifies whether a cache cluster is enabled for the stage.
	CacheClusterEnabled *bool `locationName:"cacheClusterEnabled" type:"boolean"`

	// The size of the cache cluster for the stage, if enabled.
	CacheClusterSize CacheClusterSize `locationName:"cacheClusterSize" type:"string" enum:"true"`

	// The status of the cache cluster for the stage, if enabled.
	CacheClusterStatus CacheClusterStatus `locationName:"cacheClusterStatus" type:"string" enum:"true"`

	// Settings for the canary deployment in this stage.
	CanarySettings *CanarySettings `locationName:"canarySettings" type:"structure"`

	// The identifier of a client certificate for an API stage.
	ClientCertificateId *string `locationName:"clientCertificateId" type:"string"`

	// The timestamp when the stage was created.
	CreatedDate *time.Time `locationName:"createdDate" type:"timestamp" timestampFormat:"unix"`

	// The identifier of the Deployment that the stage points to.
	DeploymentId *string `locationName:"deploymentId" type:"string"`

	// The stage's description.
	Description *string `locationName:"description" type:"string"`

	// The version of the associated API documentation.
	DocumentationVersion *string `locationName:"documentationVersion" type:"string"`

	// The timestamp when the stage last updated.
	LastUpdatedDate *time.Time `locationName:"lastUpdatedDate" type:"timestamp" timestampFormat:"unix"`

	// A map that defines the method settings for a Stage resource. Keys (designated
	// as /{method_setting_key below) are method paths defined as {resource_path}/{http_method}
	// for an individual method override, or /\*/\* for overriding all methods in
	// the stage.
	MethodSettings map[string]MethodSetting `locationName:"methodSettings" type:"map"`

	// The name of the stage is the first path segment in the Uniform Resource Identifier
	// (URI) of a call to API Gateway.
	StageName *string `locationName:"stageName" type:"string"`

	// The collection of tags. Each tag element is associated with a given resource.
	Tags map[string]string `locationName:"tags" type:"map"`

	// Specifies whether active tracing with X-ray is enabled for the Stage.
	TracingEnabled *bool `locationName:"tracingEnabled" type:"boolean"`

	// A map that defines the stage variables for a Stage resource. Variable names
	// can have alphanumeric and underscore characters, and the values must match
	// [A-Za-z0-9-._~:/?#&=,]+.
	Variables map[string]string `locationName:"variables" type:"map"`

	// The ARN of the WebAcl associated with the Stage.
	WebAclArn *string `locationName:"webAclArn" type:"string"`
}

// String returns the string representation
func (s UpdateStageOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateStageOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateStageOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateStageOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccessLogSettings != nil {
		v := s.AccessLogSettings

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "accessLogSettings", v, metadata)
	}
	if s.CacheClusterEnabled != nil {
		v := *s.CacheClusterEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheClusterEnabled", protocol.BoolValue(v), metadata)
	}
	if len(s.CacheClusterSize) > 0 {
		v := s.CacheClusterSize

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheClusterSize", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if len(s.CacheClusterStatus) > 0 {
		v := s.CacheClusterStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "cacheClusterStatus", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.CanarySettings != nil {
		v := s.CanarySettings

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "canarySettings", v, metadata)
	}
	if s.ClientCertificateId != nil {
		v := *s.ClientCertificateId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "clientCertificateId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.CreatedDate != nil {
		v := *s.CreatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "createdDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if s.DeploymentId != nil {
		v := *s.DeploymentId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "deploymentId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.DocumentationVersion != nil {
		v := *s.DocumentationVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "documentationVersion", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.LastUpdatedDate != nil {
		v := *s.LastUpdatedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "lastUpdatedDate", protocol.TimeValue{V: v, Format: protocol.UnixTimeFormat}, metadata)
	}
	if len(s.MethodSettings) > 0 {
		v := s.MethodSettings

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "methodSettings", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetFields(k1, v1)
		}
		ms0.End()

	}
	if s.StageName != nil {
		v := *s.StageName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "stageName", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "tags", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.TracingEnabled != nil {
		v := *s.TracingEnabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "tracingEnabled", protocol.BoolValue(v), metadata)
	}
	if len(s.Variables) > 0 {
		v := s.Variables

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "variables", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ms0.End()

	}
	if s.WebAclArn != nil {
		v := *s.WebAclArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "webAclArn", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The PATCH request to grant a temporary extension to the remaining quota of
// a usage plan associated with a specified API key.
type UpdateUsageInput struct {
	_ struct{} `type:"structure"`

	// [Required] The identifier of the API key associated with the usage plan in
	// which a temporary extension is granted to the remaining quota.
	//
	// KeyId is a required field
	KeyId *string `location:"uri" locationName:"keyId" type:"string" required:"true"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The Id of the usage plan associated with the usage data.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateUsageInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateUsageInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateUsageInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateUsageInput"}

	if s.KeyId == nil {
		invalidParams.Add(aws.NewErrParamRequired("KeyId"))
	}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateUsageInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.KeyId != nil {
		v := *s.KeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "keyId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents the usage data of a usage plan.
//
// Create and Use Usage Plans (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html), Manage Usage in a Usage Plan (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-console.html#api-gateway-usage-plan-manage-usage)
type UpdateUsageOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ending date of the usage data.
	EndDate *string `locationName:"endDate" type:"string"`

	// The usage data, as daily logs of used and remaining quotas, over the specified
	// time interval indexed over the API keys in a usage plan. For example, {...,
	// "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}, where {api_key}
	// stands for an API key value and the daily log entry is of the format [used
	// quota, remaining quota].
	Items map[string][][]int64 `locationName:"values" type:"map"`

	Position *string `locationName:"position" type:"string"`

	// The starting date of the usage data.
	StartDate *string `locationName:"startDate" type:"string"`

	// The plan Id associated with this usage data.
	UsagePlanId *string `locationName:"usagePlanId" type:"string"`
}

// String returns the string representation
func (s UpdateUsageOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateUsageOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateUsageOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateUsageOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.EndDate != nil {
		v := *s.EndDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "endDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Items) > 0 {
		v := s.Items

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "values", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ls1 := ms0.List(k1)
			ls1.Start()
			for _, v2 := range v1 {
				ls2 := ls1.List()
				ls2.Start()
				for _, v3 := range v2 {
					ls2.ListAddValue(protocol.Int64Value(v3))
				}
				ls2.End()
			}
			ls1.End()
		}
		ms0.End()

	}
	if s.Position != nil {
		v := *s.Position

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "position", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.StartDate != nil {
		v := *s.StartDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "startDate", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "usagePlanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// The PATCH request to update a usage plan of a given plan Id.
type UpdateUsagePlanInput struct {
	_ struct{} `type:"structure"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The Id of the to-be-updated usage plan.
	//
	// UsagePlanId is a required field
	UsagePlanId *string `location:"uri" locationName:"usageplanId" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateUsagePlanInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateUsagePlanInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateUsagePlanInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateUsagePlanInput"}

	if s.UsagePlanId == nil {
		invalidParams.Add(aws.NewErrParamRequired("UsagePlanId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateUsagePlanInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.UsagePlanId != nil {
		v := *s.UsagePlanId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "usageplanId", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// Represents a usage plan than can specify who can assess associated API stages
// with specified request limits and quotas.
//
// In a usage plan, you associate an API by specifying the API's Id and a stage
// name of the specified API. You add plan customers by adding API keys to the
// plan.
//
// Create and Use Usage Plans (https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
type UpdateUsagePlanOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The associated API stages of a usage plan.
	ApiStages []ApiStage `locationName:"apiStages" type:"list"`

	// The description of a usage plan.
	Description *string `locationName:"description" type:"string"`

	// The identifier of a UsagePlan resource.
	Id *string `locationName:"id" type:"string"`

	// The name of a usage plan.
	Name *string `locationName:"name" type:"string"`

	// The AWS Markeplace product identifier to associate with the usage plan as
	// a SaaS product on AWS Marketplace.
	ProductCode *string `locationName:"productCode" type:"string"`

	// The maximum number of permitted requests per a given unit time interval.
	Quota *QuotaSettings `locationName:"quota" type:"structure"`

	// The request throttle limits of a usage plan.
	Throttle *ThrottleSettings `locationName:"throttle" type:"structure"`
}

// String returns the string representation
func (s UpdateUsagePlanOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateUsagePlanOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateUsagePlanOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateUsagePlanOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ApiStages) > 0 {
		v := s.ApiStages

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "apiStages", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.ProductCode != nil {
		v := *s.ProductCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "productCode", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Quota != nil {
		v := s.Quota

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "quota", v, metadata)
	}
	if s.Throttle != nil {
		v := s.Throttle

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "throttle", v, metadata)
	}
	return nil
}

// Updates an existing VpcLink of a specified identifier.
type UpdateVpcLinkInput struct {
	_ struct{} `type:"structure"`

	// A list of update operations to be applied to the specified resource and in
	// the order specified in this list.
	PatchOperations []PatchOperation `locationName:"patchOperations" type:"list"`

	// [Required] The identifier of the VpcLink. It is used in an Integration to
	// reference this VpcLink.
	//
	// VpcLinkId is a required field
	VpcLinkId *string `location:"uri" locationName:"vpclink_id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateVpcLinkInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateVpcLinkInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateVpcLinkInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateVpcLinkInput"}

	if s.VpcLinkId == nil {
		invalidParams.Add(aws.NewErrParamRequired("VpcLinkId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateVpcLinkInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.PatchOperations) > 0 {
		v := s.PatchOperations

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "patchOperations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.VpcLinkId != nil {
		v := *s.VpcLinkId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "vpclink_id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	return nil
}

// A API Gateway VPC link for a RestApi to access resources in an Amazon Virtual
// Private Cloud (VPC).
//
// To enable access to a resource in an Amazon Virtual Private Cloud through
// Amazon API Gateway, you, as an API developer, create a VpcLink resource targeted
// for one or more network load balancers of the VPC and then integrate an API
// method with a private integration that uses the VpcLink. The private integration
// has an integration type of HTTP or HTTP_PROXY and has a connection type of
// VPC_LINK. The integration uses the connectionId property to identify the
// VpcLink used.
type UpdateVpcLinkOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The description of the VPC link.
	Description *string `locationName:"description" type:"string"`

	// The identifier of the VpcLink. It is used in an Integration to reference
	// this VpcLink.
	Id *string `locationName:"id" type:"string"`

	// The name used to label and identify the VPC link.
	Name *string `locationName:"name" type:"string"`

	// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING,
	// or FAILED. Deploying an API will wait if the status is PENDING and will fail
	// if the status is DELETING.
	Status VpcLinkStatus `locationName:"status" type:"string" enum:"true"`

	// A description about the VPC link status.
	StatusMessage *string `locationName:"statusMessage" type:"string"`

	// The ARNs of network load balancers of the VPC targeted by the VPC link. The
	// network load balancers must be owned by the same AWS account of the API owner.
	TargetArns []string `locationName:"targetArns" type:"list"`
}

// String returns the string representation
func (s UpdateVpcLinkOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateVpcLinkOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateVpcLinkOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateVpcLinkOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "description", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "id", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "name", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "status", protocol.QuotedValue{ValueMarshaler: v}, metadata)
	}
	if s.StatusMessage != nil {
		v := *s.StatusMessage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "statusMessage", protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v)}, metadata)
	}
	if len(s.TargetArns) > 0 {
		v := s.TargetArns

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "targetArns", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.QuotedValue{ValueMarshaler: protocol.StringValue(v1)})
		}
		ls0.End()

	}
	return nil
}

type ApiKeySourceType string

// Enum values for ApiKeySourceType
const (
	ApiKeySourceTypeHeader     ApiKeySourceType = "HEADER"
	ApiKeySourceTypeAuthorizer ApiKeySourceType = "AUTHORIZER"
)

func (enum ApiKeySourceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ApiKeySourceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ApiKeysFormat string

// Enum values for ApiKeysFormat
const (
	ApiKeysFormatCsv ApiKeysFormat = "csv"
)

func (enum ApiKeysFormat) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ApiKeysFormat) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The authorizer type. Valid values are TOKEN for a Lambda function using a
// single authorization token submitted in a custom header, REQUEST for a Lambda
// function using incoming request parameters, and COGNITO_USER_POOLS for using
// an Amazon Cognito user pool.
type AuthorizerType string

// Enum values for AuthorizerType
const (
	AuthorizerTypeToken            AuthorizerType = "TOKEN"
	AuthorizerTypeRequest          AuthorizerType = "REQUEST"
	AuthorizerTypeCognitoUserPools AuthorizerType = "COGNITO_USER_POOLS"
)

func (enum AuthorizerType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AuthorizerType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// Returns the size of the CacheCluster.
type CacheClusterSize string

// Enum values for CacheClusterSize
const (
	CacheClusterSize05  CacheClusterSize = "0.5"
	CacheClusterSize16  CacheClusterSize = "1.6"
	CacheClusterSize61  CacheClusterSize = "6.1"
	CacheClusterSize135 CacheClusterSize = "13.5"
	CacheClusterSize284 CacheClusterSize = "28.4"
	CacheClusterSize582 CacheClusterSize = "58.2"
	CacheClusterSize118 CacheClusterSize = "118"
	CacheClusterSize237 CacheClusterSize = "237"
)

func (enum CacheClusterSize) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CacheClusterSize) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// Returns the status of the CacheCluster.
type CacheClusterStatus string

// Enum values for CacheClusterStatus
const (
	CacheClusterStatusCreateInProgress CacheClusterStatus = "CREATE_IN_PROGRESS"
	CacheClusterStatusAvailable        CacheClusterStatus = "AVAILABLE"
	CacheClusterStatusDeleteInProgress CacheClusterStatus = "DELETE_IN_PROGRESS"
	CacheClusterStatusNotAvailable     CacheClusterStatus = "NOT_AVAILABLE"
	CacheClusterStatusFlushInProgress  CacheClusterStatus = "FLUSH_IN_PROGRESS"
)

func (enum CacheClusterStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CacheClusterStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ConnectionType string

// Enum values for ConnectionType
const (
	ConnectionTypeInternet ConnectionType = "INTERNET"
	ConnectionTypeVpcLink  ConnectionType = "VPC_LINK"
)

func (enum ConnectionType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ConnectionType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ContentHandlingStrategy string

// Enum values for ContentHandlingStrategy
const (
	ContentHandlingStrategyConvertToBinary ContentHandlingStrategy = "CONVERT_TO_BINARY"
	ContentHandlingStrategyConvertToText   ContentHandlingStrategy = "CONVERT_TO_TEXT"
)

func (enum ContentHandlingStrategy) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ContentHandlingStrategy) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type DocumentationPartType string

// Enum values for DocumentationPartType
const (
	DocumentationPartTypeApi            DocumentationPartType = "API"
	DocumentationPartTypeAuthorizer     DocumentationPartType = "AUTHORIZER"
	DocumentationPartTypeModel          DocumentationPartType = "MODEL"
	DocumentationPartTypeResource       DocumentationPartType = "RESOURCE"
	DocumentationPartTypeMethod         DocumentationPartType = "METHOD"
	DocumentationPartTypePathParameter  DocumentationPartType = "PATH_PARAMETER"
	DocumentationPartTypeQueryParameter DocumentationPartType = "QUERY_PARAMETER"
	DocumentationPartTypeRequestHeader  DocumentationPartType = "REQUEST_HEADER"
	DocumentationPartTypeRequestBody    DocumentationPartType = "REQUEST_BODY"
	DocumentationPartTypeResponse       DocumentationPartType = "RESPONSE"
	DocumentationPartTypeResponseHeader DocumentationPartType = "RESPONSE_HEADER"
	DocumentationPartTypeResponseBody   DocumentationPartType = "RESPONSE_BODY"
)

func (enum DocumentationPartType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum DocumentationPartType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The endpoint type. The valid values are EDGE for edge-optimized API setup,
// most suitable for mobile applications; REGIONAL for regional API endpoint
// setup, most suitable for calling from AWS Region; and PRIVATE for private
// APIs.
type EndpointType string

// Enum values for EndpointType
const (
	EndpointTypeRegional EndpointType = "REGIONAL"
	EndpointTypeEdge     EndpointType = "EDGE"
	EndpointTypePrivate  EndpointType = "PRIVATE"
)

func (enum EndpointType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum EndpointType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type GatewayResponseType string

// Enum values for GatewayResponseType
const (
	GatewayResponseTypeDefault4xx                   GatewayResponseType = "DEFAULT_4XX"
	GatewayResponseTypeDefault5xx                   GatewayResponseType = "DEFAULT_5XX"
	GatewayResponseTypeResourceNotFound             GatewayResponseType = "RESOURCE_NOT_FOUND"
	GatewayResponseTypeUnauthorized                 GatewayResponseType = "UNAUTHORIZED"
	GatewayResponseTypeInvalidApiKey                GatewayResponseType = "INVALID_API_KEY"
	GatewayResponseTypeAccessDenied                 GatewayResponseType = "ACCESS_DENIED"
	GatewayResponseTypeAuthorizerFailure            GatewayResponseType = "AUTHORIZER_FAILURE"
	GatewayResponseTypeAuthorizerConfigurationError GatewayResponseType = "AUTHORIZER_CONFIGURATION_ERROR"
	GatewayResponseTypeInvalidSignature             GatewayResponseType = "INVALID_SIGNATURE"
	GatewayResponseTypeExpiredToken                 GatewayResponseType = "EXPIRED_TOKEN"
	GatewayResponseTypeMissingAuthenticationToken   GatewayResponseType = "MISSING_AUTHENTICATION_TOKEN"
	GatewayResponseTypeIntegrationFailure           GatewayResponseType = "INTEGRATION_FAILURE"
	GatewayResponseTypeIntegrationTimeout           GatewayResponseType = "INTEGRATION_TIMEOUT"
	GatewayResponseTypeApiConfigurationError        GatewayResponseType = "API_CONFIGURATION_ERROR"
	GatewayResponseTypeUnsupportedMediaType         GatewayResponseType = "UNSUPPORTED_MEDIA_TYPE"
	GatewayResponseTypeBadRequestParameters         GatewayResponseType = "BAD_REQUEST_PARAMETERS"
	GatewayResponseTypeBadRequestBody               GatewayResponseType = "BAD_REQUEST_BODY"
	GatewayResponseTypeRequestTooLarge              GatewayResponseType = "REQUEST_TOO_LARGE"
	GatewayResponseTypeThrottled                    GatewayResponseType = "THROTTLED"
	GatewayResponseTypeQuotaExceeded                GatewayResponseType = "QUOTA_EXCEEDED"
)

func (enum GatewayResponseType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum GatewayResponseType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

// The integration type. The valid value is HTTP for integrating an API method
// with an HTTP backend; AWS with any AWS service endpoints; MOCK for testing
// without actually invoking the backend; HTTP_PROXY for integrating with the
// HTTP proxy integration; AWS_PROXY for integrating with the Lambda proxy integration.
type IntegrationType string

// Enum values for IntegrationType
const (
	IntegrationTypeHttp      IntegrationType = "HTTP"
	IntegrationTypeAws       IntegrationType = "AWS"
	IntegrationTypeMock      IntegrationType = "MOCK"
	IntegrationTypeHttpProxy IntegrationType = "HTTP_PROXY"
	IntegrationTypeAwsProxy  IntegrationType = "AWS_PROXY"
)

func (enum IntegrationType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum IntegrationType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type LocationStatusType string

// Enum values for LocationStatusType
const (
	LocationStatusTypeDocumented   LocationStatusType = "DOCUMENTED"
	LocationStatusTypeUndocumented LocationStatusType = "UNDOCUMENTED"
)

func (enum LocationStatusType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum LocationStatusType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Op string

// Enum values for Op
const (
	OpAdd     Op = "add"
	OpRemove  Op = "remove"
	OpReplace Op = "replace"
	OpMove    Op = "move"
	OpCopy    Op = "copy"
	OpTest    Op = "test"
)

func (enum Op) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Op) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type PutMode string

// Enum values for PutMode
const (
	PutModeMerge     PutMode = "merge"
	PutModeOverwrite PutMode = "overwrite"
)

func (enum PutMode) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum PutMode) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type QuotaPeriodType string

// Enum values for QuotaPeriodType
const (
	QuotaPeriodTypeDay   QuotaPeriodType = "DAY"
	QuotaPeriodTypeWeek  QuotaPeriodType = "WEEK"
	QuotaPeriodTypeMonth QuotaPeriodType = "MONTH"
)

func (enum QuotaPeriodType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum QuotaPeriodType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type UnauthorizedCacheControlHeaderStrategy string

// Enum values for UnauthorizedCacheControlHeaderStrategy
const (
	UnauthorizedCacheControlHeaderStrategyFailWith403                  UnauthorizedCacheControlHeaderStrategy = "FAIL_WITH_403"
	UnauthorizedCacheControlHeaderStrategySucceedWithResponseHeader    UnauthorizedCacheControlHeaderStrategy = "SUCCEED_WITH_RESPONSE_HEADER"
	UnauthorizedCacheControlHeaderStrategySucceedWithoutResponseHeader UnauthorizedCacheControlHeaderStrategy = "SUCCEED_WITHOUT_RESPONSE_HEADER"
)

func (enum UnauthorizedCacheControlHeaderStrategy) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum UnauthorizedCacheControlHeaderStrategy) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type VpcLinkStatus string

// Enum values for VpcLinkStatus
const (
	VpcLinkStatusAvailable VpcLinkStatus = "AVAILABLE"
	VpcLinkStatusPending   VpcLinkStatus = "PENDING"
	VpcLinkStatusDeleting  VpcLinkStatus = "DELETING"
	VpcLinkStatusFailed    VpcLinkStatus = "FAILED"
)

func (enum VpcLinkStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum VpcLinkStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
