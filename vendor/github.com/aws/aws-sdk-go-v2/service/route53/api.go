// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package route53

import (
	"context"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

const opAssociateVPCWithHostedZone = "AssociateVPCWithHostedZone"

// AssociateVPCWithHostedZoneRequest is a API request type for the AssociateVPCWithHostedZone API operation.
type AssociateVPCWithHostedZoneRequest struct {
	*aws.Request
	Input *AssociateVPCWithHostedZoneInput
	Copy  func(*AssociateVPCWithHostedZoneInput) AssociateVPCWithHostedZoneRequest
}

// Send marshals and sends the AssociateVPCWithHostedZone API request.
func (r AssociateVPCWithHostedZoneRequest) Send(ctx context.Context) (*AssociateVPCWithHostedZoneOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*AssociateVPCWithHostedZoneOutput), nil
}

// AssociateVPCWithHostedZoneRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Associates an Amazon VPC with a private hosted zone.
//
// To perform the association, the VPC and the private hosted zone must already
// exist. You can't convert a public hosted zone into a private hosted zone.
//
// If you want to associate a VPC that was created by using one AWS account
// with a private hosted zone that was created by using a different account,
// the AWS account that created the private hosted zone must first submit a
// CreateVPCAssociationAuthorization request. Then the account that created
// the VPC must submit an AssociateVPCWithHostedZone request.
//
//    // Example sending a request using the AssociateVPCWithHostedZoneRequest method.
//    req := client.AssociateVPCWithHostedZoneRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/AssociateVPCWithHostedZone
func (c *Route53) AssociateVPCWithHostedZoneRequest(input *AssociateVPCWithHostedZoneInput) AssociateVPCWithHostedZoneRequest {
	op := &aws.Operation{
		Name:       opAssociateVPCWithHostedZone,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}/associatevpc",
	}

	if input == nil {
		input = &AssociateVPCWithHostedZoneInput{}
	}

	output := &AssociateVPCWithHostedZoneOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return AssociateVPCWithHostedZoneRequest{Request: req, Input: input, Copy: c.AssociateVPCWithHostedZoneRequest}
}

const opChangeResourceRecordSets = "ChangeResourceRecordSets"

// ChangeResourceRecordSetsRequest is a API request type for the ChangeResourceRecordSets API operation.
type ChangeResourceRecordSetsRequest struct {
	*aws.Request
	Input *ChangeResourceRecordSetsInput
	Copy  func(*ChangeResourceRecordSetsInput) ChangeResourceRecordSetsRequest
}

// Send marshals and sends the ChangeResourceRecordSets API request.
func (r ChangeResourceRecordSetsRequest) Send(ctx context.Context) (*ChangeResourceRecordSetsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ChangeResourceRecordSetsOutput), nil
}

// ChangeResourceRecordSetsRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Creates, changes, or deletes a resource record set, which contains authoritative
// DNS information for a specified domain name or subdomain name. For example,
// you can use ChangeResourceRecordSets to create a resource record set that
// routes traffic for test.example.com to a web server that has an IP address
// of 192.0.2.44.
//
// Change Batches and Transactional Changes
//
// The request body must include a document with a ChangeResourceRecordSetsRequest
// element. The request body contains a list of change items, known as a change
// batch. Change batches are considered transactional changes. When using the
// Amazon Route 53 API to change resource record sets, Route 53 either makes
// all or none of the changes in a change batch request. This ensures that Route
// 53 never partially implements the intended changes to the resource record
// sets in a hosted zone.
//
// For example, a change batch request that deletes the CNAME record for www.example.com
// and creates an alias resource record set for www.example.com. Route 53 deletes
// the first resource record set and creates the second resource record set
// in a single operation. If either the DELETE or the CREATE action fails, then
// both changes (plus any other changes in the batch) fail, and the original
// CNAME record continues to exist.
//
// Due to the nature of transactional changes, you can't delete the same resource
// record set more than once in a single change batch. If you attempt to delete
// the same change batch more than once, Route 53 returns an InvalidChangeBatch
// error.
//
// Traffic Flow
//
// To create resource record sets for complex routing configurations, use either
// the traffic flow visual editor in the Route 53 console or the API actions
// for traffic policies and traffic policy instances. Save the configuration
// as a traffic policy, then associate the traffic policy with one or more domain
// names (such as example.com) or subdomain names (such as www.example.com),
// in the same hosted zone or in multiple hosted zones. You can roll back the
// updates if the new configuration isn't performing as expected. For more information,
// see Using Traffic Flow to Route DNS Traffic (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/traffic-flow.html)
// in the Amazon Route 53 Developer Guide.
//
// Create, Delete, and Upsert
//
// Use ChangeResourceRecordsSetsRequest to perform the following actions:
//
//    * CREATE: Creates a resource record set that has the specified values.
//
//    * DELETE: Deletes an existing resource record set that has the specified
//    values.
//
//    * UPSERT: If a resource record set does not already exist, AWS creates
//    it. If a resource set does exist, Route 53 updates it with the values
//    in the request.
//
// Syntaxes for Creating, Updating, and Deleting Resource Record Sets
//
// The syntax for a request depends on the type of resource record set that
// you want to create, delete, or update, such as weighted, alias, or failover.
// The XML elements in your request must appear in the order listed in the syntax.
//
// For an example for each type of resource record set, see "Examples."
//
// Don't refer to the syntax in the "Parameter Syntax" section, which includes
// all of the elements for every kind of resource record set that you can create,
// delete, or update by using ChangeResourceRecordSets.
//
// Change Propagation to Route 53 DNS Servers
//
// When you submit a ChangeResourceRecordSets request, Route 53 propagates your
// changes to all of the Route 53 authoritative DNS servers. While your changes
// are propagating, GetChange returns a status of PENDING. When propagation
// is complete, GetChange returns a status of INSYNC. Changes generally propagate
// to all Route 53 name servers within 60 seconds. For more information, see
// GetChange.
//
// Limits on ChangeResourceRecordSets Requests
//
// For information about the limits on a ChangeResourceRecordSets request, see
// Limits (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html)
// in the Amazon Route 53 Developer Guide.
//
//    // Example sending a request using the ChangeResourceRecordSetsRequest method.
//    req := client.ChangeResourceRecordSetsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ChangeResourceRecordSets
func (c *Route53) ChangeResourceRecordSetsRequest(input *ChangeResourceRecordSetsInput) ChangeResourceRecordSetsRequest {
	op := &aws.Operation{
		Name:       opChangeResourceRecordSets,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}/rrset/",
	}

	if input == nil {
		input = &ChangeResourceRecordSetsInput{}
	}

	output := &ChangeResourceRecordSetsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ChangeResourceRecordSetsRequest{Request: req, Input: input, Copy: c.ChangeResourceRecordSetsRequest}
}

const opChangeTagsForResource = "ChangeTagsForResource"

// ChangeTagsForResourceRequest is a API request type for the ChangeTagsForResource API operation.
type ChangeTagsForResourceRequest struct {
	*aws.Request
	Input *ChangeTagsForResourceInput
	Copy  func(*ChangeTagsForResourceInput) ChangeTagsForResourceRequest
}

// Send marshals and sends the ChangeTagsForResource API request.
func (r ChangeTagsForResourceRequest) Send(ctx context.Context) (*ChangeTagsForResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ChangeTagsForResourceOutput), nil
}

// ChangeTagsForResourceRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Adds, edits, or deletes tags for a health check or a hosted zone.
//
// For information about using tags for cost allocation, see Using Cost Allocation
// Tags (http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html)
// in the AWS Billing and Cost Management User Guide.
//
//    // Example sending a request using the ChangeTagsForResourceRequest method.
//    req := client.ChangeTagsForResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ChangeTagsForResource
func (c *Route53) ChangeTagsForResourceRequest(input *ChangeTagsForResourceInput) ChangeTagsForResourceRequest {
	op := &aws.Operation{
		Name:       opChangeTagsForResource,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/tags/{ResourceType}/{ResourceId}",
	}

	if input == nil {
		input = &ChangeTagsForResourceInput{}
	}

	output := &ChangeTagsForResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ChangeTagsForResourceRequest{Request: req, Input: input, Copy: c.ChangeTagsForResourceRequest}
}

const opCreateHealthCheck = "CreateHealthCheck"

// CreateHealthCheckRequest is a API request type for the CreateHealthCheck API operation.
type CreateHealthCheckRequest struct {
	*aws.Request
	Input *CreateHealthCheckInput
	Copy  func(*CreateHealthCheckInput) CreateHealthCheckRequest
}

// Send marshals and sends the CreateHealthCheck API request.
func (r CreateHealthCheckRequest) Send(ctx context.Context) (*CreateHealthCheckOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateHealthCheckOutput), nil
}

// CreateHealthCheckRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Creates a new health check.
//
// For information about adding health checks to resource record sets, see ResourceRecordSet$HealthCheckId
// in ChangeResourceRecordSets.
//
// ELB Load Balancers
//
// If you're registering EC2 instances with an Elastic Load Balancing (ELB)
// load balancer, do not create Amazon Route 53 health checks for the EC2 instances.
// When you register an EC2 instance with a load balancer, you configure settings
// for an ELB health check, which performs a similar function to a Route 53
// health check.
//
// Private Hosted Zones
//
// You can associate health checks with failover resource record sets in a private
// hosted zone. Note the following:
//
//    * Route 53 health checkers are outside the VPC. To check the health of
//    an endpoint within a VPC by IP address, you must assign a public IP address
//    to the instance in the VPC.
//
//    * You can configure a health checker to check the health of an external
//    resource that the instance relies on, such as a database server.
//
//    * You can create a CloudWatch metric, associate an alarm with the metric,
//    and then create a health check that is based on the state of the alarm.
//    For example, you might create a CloudWatch metric that checks the status
//    of the Amazon EC2 StatusCheckFailed metric, add an alarm to the metric,
//    and then create a health check that is based on the state of the alarm.
//    For information about creating CloudWatch metrics and alarms by using
//    the CloudWatch console, see the Amazon CloudWatch User Guide (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/WhatIsCloudWatch.html).
//
//    // Example sending a request using the CreateHealthCheckRequest method.
//    req := client.CreateHealthCheckRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateHealthCheck
func (c *Route53) CreateHealthCheckRequest(input *CreateHealthCheckInput) CreateHealthCheckRequest {
	op := &aws.Operation{
		Name:       opCreateHealthCheck,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/healthcheck",
	}

	if input == nil {
		input = &CreateHealthCheckInput{}
	}

	output := &CreateHealthCheckOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateHealthCheckRequest{Request: req, Input: input, Copy: c.CreateHealthCheckRequest}
}

const opCreateHostedZone = "CreateHostedZone"

// CreateHostedZoneRequest is a API request type for the CreateHostedZone API operation.
type CreateHostedZoneRequest struct {
	*aws.Request
	Input *CreateHostedZoneInput
	Copy  func(*CreateHostedZoneInput) CreateHostedZoneRequest
}

// Send marshals and sends the CreateHostedZone API request.
func (r CreateHostedZoneRequest) Send(ctx context.Context) (*CreateHostedZoneOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateHostedZoneOutput), nil
}

// CreateHostedZoneRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Creates a new public or private hosted zone. You create records in a public
// hosted zone to define how you want to route traffic on the internet for a
// domain, such as example.com, and its subdomains (apex.example.com, acme.example.com).
// You create records in a private hosted zone to define how you want to route
// traffic for a domain and its subdomains within one or more Amazon Virtual
// Private Clouds (Amazon VPCs).
//
// You can't convert a public hosted zone to a private hosted zone or vice versa.
// Instead, you must create a new hosted zone with the same name and create
// new resource record sets.
//
// For more information about charges for hosted zones, see Amazon Route 53
// Pricing (http://aws.amazon.com/route53/pricing/).
//
// Note the following:
//
//    * You can't create a hosted zone for a top-level domain (TLD) such as
//    .com.
//
//    * For public hosted zones, Amazon Route 53 automatically creates a default
//    SOA record and four NS records for the zone. For more information about
//    SOA and NS records, see NS and SOA Records that Route 53 Creates for a
//    Hosted Zone (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/SOA-NSrecords.html)
//    in the Amazon Route 53 Developer Guide.
//
// If you want to use the same name servers for multiple public hosted zones,
//    you can optionally associate a reusable delegation set with the hosted
//    zone. See the DelegationSetId element.
//
//    * If your domain is registered with a registrar other than Route 53, you
//    must update the name servers with your registrar to make Route 53 the
//    DNS service for the domain. For more information, see Migrating DNS Service
//    for an Existing Domain to Amazon Route 53 (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/MigratingDNS.html)
//    in the Amazon Route 53 Developer Guide.
//
// When you submit a CreateHostedZone request, the initial status of the hosted
// zone is PENDING. For public hosted zones, this means that the NS and SOA
// records are not yet available on all Route 53 DNS servers. When the NS and
// SOA records are available, the status of the zone changes to INSYNC.
//
//    // Example sending a request using the CreateHostedZoneRequest method.
//    req := client.CreateHostedZoneRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateHostedZone
func (c *Route53) CreateHostedZoneRequest(input *CreateHostedZoneInput) CreateHostedZoneRequest {
	op := &aws.Operation{
		Name:       opCreateHostedZone,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/hostedzone",
	}

	if input == nil {
		input = &CreateHostedZoneInput{}
	}

	output := &CreateHostedZoneOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateHostedZoneRequest{Request: req, Input: input, Copy: c.CreateHostedZoneRequest}
}

const opCreateQueryLoggingConfig = "CreateQueryLoggingConfig"

// CreateQueryLoggingConfigRequest is a API request type for the CreateQueryLoggingConfig API operation.
type CreateQueryLoggingConfigRequest struct {
	*aws.Request
	Input *CreateQueryLoggingConfigInput
	Copy  func(*CreateQueryLoggingConfigInput) CreateQueryLoggingConfigRequest
}

// Send marshals and sends the CreateQueryLoggingConfig API request.
func (r CreateQueryLoggingConfigRequest) Send(ctx context.Context) (*CreateQueryLoggingConfigOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateQueryLoggingConfigOutput), nil
}

// CreateQueryLoggingConfigRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Creates a configuration for DNS query logging. After you create a query logging
// configuration, Amazon Route 53 begins to publish log data to an Amazon CloudWatch
// Logs log group.
//
// DNS query logs contain information about the queries that Route 53 receives
// for a specified public hosted zone, such as the following:
//
//    * Route 53 edge location that responded to the DNS query
//
//    * Domain or subdomain that was requested
//
//    * DNS record type, such as A or AAAA
//
//    * DNS response code, such as NoError or ServFail
//
// Log Group and Resource PolicyBefore you create a query logging configuration,
// perform the following operations.
//
// If you create a query logging configuration using the Route 53 console, Route
// 53 performs these operations automatically.
//
// Create a CloudWatch Logs log group, and make note of the ARN, which you specify
// when you create a query logging configuration. Note the following:
//
// You must create the log group in the us-east-1 region.
//
// You must use the same AWS account to create the log group and the hosted
// zone that you want to configure query logging for.
//
// When you create log groups for query logging, we recommend that you use a
// consistent prefix, for example:
//
// /aws/route53/hosted zone name
//
// In the next step, you'll create a resource policy, which controls access
// to one or more log groups and the associated AWS resources, such as Route
// 53 hosted zones. There's a limit on the number of resource policies that
// you can create, so we recommend that you use a consistent prefix so you can
// use the same resource policy for all the log groups that you create for query
// logging.
//
// Create a CloudWatch Logs resource policy, and give it the permissions that
// Route 53 needs to create log streams and to send query logs to log streams.
// For the value of Resource, specify the ARN for the log group that you created
// in the previous step. To use the same resource policy for all the CloudWatch
// Logs log groups that you created for query logging configurations, replace
// the hosted zone name with *, for example:
//
// arn:aws:logs:us-east-1:123412341234:log-group:/aws/route53/*
//
// You can't use the CloudWatch console to create or edit a resource policy.
// You must use the CloudWatch API, one of the AWS SDKs, or the AWS CLI.
//
// Log Streams and Edge LocationsWhen Route 53 finishes creating the configuration
// for DNS query logging, it does the following:
//
// Creates a log stream for an edge location the first time that the edge location
// responds to DNS queries for the specified hosted zone. That log stream is
// used to log all queries that Route 53 responds to for that edge location.
//
// Begins to send query logs to the applicable log stream.
//
// The name of each log stream is in the following format:
//
// hosted zone ID/edge location code
//
// The edge location code is a three-letter code and an arbitrarily assigned
// number, for example, DFW3. The three-letter code typically corresponds with
// the International Air Transport Association airport code for an airport near
// the edge location. (These abbreviations might change in the future.) For
// a list of edge locations, see "The Route 53 Global Network" on the Route
// 53 Product Details (http://aws.amazon.com/route53/details/) page.
//
// Queries That Are LoggedQuery logs contain only the queries that DNS resolvers
// forward to Route 53. If a DNS resolver has already cached the response to
// a query (such as the IP address for a load balancer for example.com), the
// resolver will continue to return the cached response. It doesn't forward
// another query to Route 53 until the TTL for the corresponding resource record
// set expires. Depending on how many DNS queries are submitted for a resource
// record set, and depending on the TTL for that resource record set, query
// logs might contain information about only one query out of every several
// thousand queries that are submitted to DNS. For more information about how
// DNS works, see Routing Internet Traffic to Your Website or Web Application
// (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/welcome-dns-service.html)
// in the Amazon Route 53 Developer Guide.
//
// Log File FormatFor a list of the values in each query log and the format
// of each value, see Logging DNS Queries (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html)
// in the Amazon Route 53 Developer Guide.
//
// PricingFor information about charges for query logs, see Amazon CloudWatch
// Pricing (http://aws.amazon.com/cloudwatch/pricing/).
//
// How to Stop LoggingIf you want Route 53 to stop sending query logs to CloudWatch
// Logs, delete the query logging configuration. For more information, see DeleteQueryLoggingConfig.
//
//    // Example sending a request using the CreateQueryLoggingConfigRequest method.
//    req := client.CreateQueryLoggingConfigRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateQueryLoggingConfig
func (c *Route53) CreateQueryLoggingConfigRequest(input *CreateQueryLoggingConfigInput) CreateQueryLoggingConfigRequest {
	op := &aws.Operation{
		Name:       opCreateQueryLoggingConfig,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/queryloggingconfig",
	}

	if input == nil {
		input = &CreateQueryLoggingConfigInput{}
	}

	output := &CreateQueryLoggingConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateQueryLoggingConfigRequest{Request: req, Input: input, Copy: c.CreateQueryLoggingConfigRequest}
}

const opCreateReusableDelegationSet = "CreateReusableDelegationSet"

// CreateReusableDelegationSetRequest is a API request type for the CreateReusableDelegationSet API operation.
type CreateReusableDelegationSetRequest struct {
	*aws.Request
	Input *CreateReusableDelegationSetInput
	Copy  func(*CreateReusableDelegationSetInput) CreateReusableDelegationSetRequest
}

// Send marshals and sends the CreateReusableDelegationSet API request.
func (r CreateReusableDelegationSetRequest) Send(ctx context.Context) (*CreateReusableDelegationSetOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateReusableDelegationSetOutput), nil
}

// CreateReusableDelegationSetRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Creates a delegation set (a group of four name servers) that can be reused
// by multiple hosted zones. If a hosted zoned ID is specified, CreateReusableDelegationSet
// marks the delegation set associated with that zone as reusable.
//
// You can't associate a reusable delegation set with a private hosted zone.
//
// For information about using a reusable delegation set to configure white
// label name servers, see Configuring White Label Name Servers (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/white-label-name-servers.html).
//
// The process for migrating existing hosted zones to use a reusable delegation
// set is comparable to the process for configuring white label name servers.
// You need to perform the following steps:
//
// Create a reusable delegation set.
//
// Recreate hosted zones, and reduce the TTL to 60 seconds or less.
//
// Recreate resource record sets in the new hosted zones.
//
// Change the registrar's name servers to use the name servers for the new hosted
// zones.
//
// Monitor traffic for the website or application.
//
// Change TTLs back to their original values.
//
// If you want to migrate existing hosted zones to use a reusable delegation
// set, the existing hosted zones can't use any of the name servers that are
// assigned to the reusable delegation set. If one or more hosted zones do use
// one or more name servers that are assigned to the reusable delegation set,
// you can do one of the following:
//
//    * For small numbers of hosted zones—up to a few hundred—it's relatively
//    easy to create reusable delegation sets until you get one that has four
//    name servers that don't overlap with any of the name servers in your hosted
//    zones.
//
//    * For larger numbers of hosted zones, the easiest solution is to use more
//    than one reusable delegation set.
//
//    * For larger numbers of hosted zones, you can also migrate hosted zones
//    that have overlapping name servers to hosted zones that don't have overlapping
//    name servers, then migrate the hosted zones again to use the reusable
//    delegation set.
//
//    // Example sending a request using the CreateReusableDelegationSetRequest method.
//    req := client.CreateReusableDelegationSetRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateReusableDelegationSet
func (c *Route53) CreateReusableDelegationSetRequest(input *CreateReusableDelegationSetInput) CreateReusableDelegationSetRequest {
	op := &aws.Operation{
		Name:       opCreateReusableDelegationSet,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/delegationset",
	}

	if input == nil {
		input = &CreateReusableDelegationSetInput{}
	}

	output := &CreateReusableDelegationSetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateReusableDelegationSetRequest{Request: req, Input: input, Copy: c.CreateReusableDelegationSetRequest}
}

const opCreateTrafficPolicy = "CreateTrafficPolicy"

// CreateTrafficPolicyRequest is a API request type for the CreateTrafficPolicy API operation.
type CreateTrafficPolicyRequest struct {
	*aws.Request
	Input *CreateTrafficPolicyInput
	Copy  func(*CreateTrafficPolicyInput) CreateTrafficPolicyRequest
}

// Send marshals and sends the CreateTrafficPolicy API request.
func (r CreateTrafficPolicyRequest) Send(ctx context.Context) (*CreateTrafficPolicyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTrafficPolicyOutput), nil
}

// CreateTrafficPolicyRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Creates a traffic policy, which you use to create multiple DNS resource record
// sets for one domain name (such as example.com) or one subdomain name (such
// as www.example.com).
//
//    // Example sending a request using the CreateTrafficPolicyRequest method.
//    req := client.CreateTrafficPolicyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicy
func (c *Route53) CreateTrafficPolicyRequest(input *CreateTrafficPolicyInput) CreateTrafficPolicyRequest {
	op := &aws.Operation{
		Name:       opCreateTrafficPolicy,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/trafficpolicy",
	}

	if input == nil {
		input = &CreateTrafficPolicyInput{}
	}

	output := &CreateTrafficPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTrafficPolicyRequest{Request: req, Input: input, Copy: c.CreateTrafficPolicyRequest}
}

const opCreateTrafficPolicyInstance = "CreateTrafficPolicyInstance"

// CreateTrafficPolicyInstanceRequest is a API request type for the CreateTrafficPolicyInstance API operation.
type CreateTrafficPolicyInstanceRequest struct {
	*aws.Request
	Input *CreateTrafficPolicyInstanceInput
	Copy  func(*CreateTrafficPolicyInstanceInput) CreateTrafficPolicyInstanceRequest
}

// Send marshals and sends the CreateTrafficPolicyInstance API request.
func (r CreateTrafficPolicyInstanceRequest) Send(ctx context.Context) (*CreateTrafficPolicyInstanceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTrafficPolicyInstanceOutput), nil
}

// CreateTrafficPolicyInstanceRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Creates resource record sets in a specified hosted zone based on the settings
// in a specified traffic policy version. In addition, CreateTrafficPolicyInstance
// associates the resource record sets with a specified domain name (such as
// example.com) or subdomain name (such as www.example.com). Amazon Route 53
// responds to DNS queries for the domain or subdomain name by using the resource
// record sets that CreateTrafficPolicyInstance created.
//
//    // Example sending a request using the CreateTrafficPolicyInstanceRequest method.
//    req := client.CreateTrafficPolicyInstanceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicyInstance
func (c *Route53) CreateTrafficPolicyInstanceRequest(input *CreateTrafficPolicyInstanceInput) CreateTrafficPolicyInstanceRequest {
	op := &aws.Operation{
		Name:       opCreateTrafficPolicyInstance,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/trafficpolicyinstance",
	}

	if input == nil {
		input = &CreateTrafficPolicyInstanceInput{}
	}

	output := &CreateTrafficPolicyInstanceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTrafficPolicyInstanceRequest{Request: req, Input: input, Copy: c.CreateTrafficPolicyInstanceRequest}
}

const opCreateTrafficPolicyVersion = "CreateTrafficPolicyVersion"

// CreateTrafficPolicyVersionRequest is a API request type for the CreateTrafficPolicyVersion API operation.
type CreateTrafficPolicyVersionRequest struct {
	*aws.Request
	Input *CreateTrafficPolicyVersionInput
	Copy  func(*CreateTrafficPolicyVersionInput) CreateTrafficPolicyVersionRequest
}

// Send marshals and sends the CreateTrafficPolicyVersion API request.
func (r CreateTrafficPolicyVersionRequest) Send(ctx context.Context) (*CreateTrafficPolicyVersionOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateTrafficPolicyVersionOutput), nil
}

// CreateTrafficPolicyVersionRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Creates a new version of an existing traffic policy. When you create a new
// version of a traffic policy, you specify the ID of the traffic policy that
// you want to update and a JSON-formatted document that describes the new version.
// You use traffic policies to create multiple DNS resource record sets for
// one domain name (such as example.com) or one subdomain name (such as www.example.com).
// You can create a maximum of 1000 versions of a traffic policy. If you reach
// the limit and need to create another version, you'll need to start a new
// traffic policy.
//
//    // Example sending a request using the CreateTrafficPolicyVersionRequest method.
//    req := client.CreateTrafficPolicyVersionRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicyVersion
func (c *Route53) CreateTrafficPolicyVersionRequest(input *CreateTrafficPolicyVersionInput) CreateTrafficPolicyVersionRequest {
	op := &aws.Operation{
		Name:       opCreateTrafficPolicyVersion,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/trafficpolicy/{Id}",
	}

	if input == nil {
		input = &CreateTrafficPolicyVersionInput{}
	}

	output := &CreateTrafficPolicyVersionOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateTrafficPolicyVersionRequest{Request: req, Input: input, Copy: c.CreateTrafficPolicyVersionRequest}
}

const opCreateVPCAssociationAuthorization = "CreateVPCAssociationAuthorization"

// CreateVPCAssociationAuthorizationRequest is a API request type for the CreateVPCAssociationAuthorization API operation.
type CreateVPCAssociationAuthorizationRequest struct {
	*aws.Request
	Input *CreateVPCAssociationAuthorizationInput
	Copy  func(*CreateVPCAssociationAuthorizationInput) CreateVPCAssociationAuthorizationRequest
}

// Send marshals and sends the CreateVPCAssociationAuthorization API request.
func (r CreateVPCAssociationAuthorizationRequest) Send(ctx context.Context) (*CreateVPCAssociationAuthorizationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*CreateVPCAssociationAuthorizationOutput), nil
}

// CreateVPCAssociationAuthorizationRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Authorizes the AWS account that created a specified VPC to submit an AssociateVPCWithHostedZone
// request to associate the VPC with a specified hosted zone that was created
// by a different account. To submit a CreateVPCAssociationAuthorization request,
// you must use the account that created the hosted zone. After you authorize
// the association, use the account that created the VPC to submit an AssociateVPCWithHostedZone
// request.
//
// If you want to associate multiple VPCs that you created by using one account
// with a hosted zone that you created by using a different account, you must
// submit one authorization request for each VPC.
//
//    // Example sending a request using the CreateVPCAssociationAuthorizationRequest method.
//    req := client.CreateVPCAssociationAuthorizationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateVPCAssociationAuthorization
func (c *Route53) CreateVPCAssociationAuthorizationRequest(input *CreateVPCAssociationAuthorizationInput) CreateVPCAssociationAuthorizationRequest {
	op := &aws.Operation{
		Name:       opCreateVPCAssociationAuthorization,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}/authorizevpcassociation",
	}

	if input == nil {
		input = &CreateVPCAssociationAuthorizationInput{}
	}

	output := &CreateVPCAssociationAuthorizationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return CreateVPCAssociationAuthorizationRequest{Request: req, Input: input, Copy: c.CreateVPCAssociationAuthorizationRequest}
}

const opDeleteHealthCheck = "DeleteHealthCheck"

// DeleteHealthCheckRequest is a API request type for the DeleteHealthCheck API operation.
type DeleteHealthCheckRequest struct {
	*aws.Request
	Input *DeleteHealthCheckInput
	Copy  func(*DeleteHealthCheckInput) DeleteHealthCheckRequest
}

// Send marshals and sends the DeleteHealthCheck API request.
func (r DeleteHealthCheckRequest) Send(ctx context.Context) (*DeleteHealthCheckOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteHealthCheckOutput), nil
}

// DeleteHealthCheckRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Deletes a health check.
//
// Amazon Route 53 does not prevent you from deleting a health check even if
// the health check is associated with one or more resource record sets. If
// you delete a health check and you don't update the associated resource record
// sets, the future status of the health check can't be predicted and may change.
// This will affect the routing of DNS queries for your DNS failover configuration.
// For more information, see Replacing and Deleting Health Checks (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html#health-checks-deleting.html)
// in the Amazon Route 53 Developer Guide.
//
//    // Example sending a request using the DeleteHealthCheckRequest method.
//    req := client.DeleteHealthCheckRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteHealthCheck
func (c *Route53) DeleteHealthCheckRequest(input *DeleteHealthCheckInput) DeleteHealthCheckRequest {
	op := &aws.Operation{
		Name:       opDeleteHealthCheck,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2013-04-01/healthcheck/{HealthCheckId}",
	}

	if input == nil {
		input = &DeleteHealthCheckInput{}
	}

	output := &DeleteHealthCheckOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteHealthCheckRequest{Request: req, Input: input, Copy: c.DeleteHealthCheckRequest}
}

const opDeleteHostedZone = "DeleteHostedZone"

// DeleteHostedZoneRequest is a API request type for the DeleteHostedZone API operation.
type DeleteHostedZoneRequest struct {
	*aws.Request
	Input *DeleteHostedZoneInput
	Copy  func(*DeleteHostedZoneInput) DeleteHostedZoneRequest
}

// Send marshals and sends the DeleteHostedZone API request.
func (r DeleteHostedZoneRequest) Send(ctx context.Context) (*DeleteHostedZoneOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteHostedZoneOutput), nil
}

// DeleteHostedZoneRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Deletes a hosted zone.
//
// If the name servers for the hosted zone are associated with a domain and
// if you want to make the domain unavailable on the Internet, we recommend
// that you delete the name servers from the domain to prevent future DNS queries
// from possibly being misrouted. If the domain is registered with Amazon Route
// 53, see UpdateDomainNameservers. If the domain is registered with another
// registrar, use the method provided by the registrar to delete name servers
// for the domain.
//
// Some domain registries don't allow you to remove all of the name servers
// for a domain. If the registry for your domain requires one or more name servers,
// we recommend that you delete the hosted zone only if you transfer DNS service
// to another service provider, and you replace the name servers for the domain
// with name servers from the new provider.
//
// You can delete a hosted zone only if it contains only the default SOA record
// and NS resource record sets. If the hosted zone contains other resource record
// sets, you must delete them before you can delete the hosted zone. If you
// try to delete a hosted zone that contains other resource record sets, the
// request fails, and Route 53 returns a HostedZoneNotEmpty error. For information
// about deleting records from your hosted zone, see ChangeResourceRecordSets.
//
// To verify that the hosted zone has been deleted, do one of the following:
//
//    * Use the GetHostedZone action to request information about the hosted
//    zone.
//
//    * Use the ListHostedZones action to get a list of the hosted zones associated
//    with the current AWS account.
//
//    // Example sending a request using the DeleteHostedZoneRequest method.
//    req := client.DeleteHostedZoneRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteHostedZone
func (c *Route53) DeleteHostedZoneRequest(input *DeleteHostedZoneInput) DeleteHostedZoneRequest {
	op := &aws.Operation{
		Name:       opDeleteHostedZone,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}",
	}

	if input == nil {
		input = &DeleteHostedZoneInput{}
	}

	output := &DeleteHostedZoneOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteHostedZoneRequest{Request: req, Input: input, Copy: c.DeleteHostedZoneRequest}
}

const opDeleteQueryLoggingConfig = "DeleteQueryLoggingConfig"

// DeleteQueryLoggingConfigRequest is a API request type for the DeleteQueryLoggingConfig API operation.
type DeleteQueryLoggingConfigRequest struct {
	*aws.Request
	Input *DeleteQueryLoggingConfigInput
	Copy  func(*DeleteQueryLoggingConfigInput) DeleteQueryLoggingConfigRequest
}

// Send marshals and sends the DeleteQueryLoggingConfig API request.
func (r DeleteQueryLoggingConfigRequest) Send(ctx context.Context) (*DeleteQueryLoggingConfigOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteQueryLoggingConfigOutput), nil
}

// DeleteQueryLoggingConfigRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Deletes a configuration for DNS query logging. If you delete a configuration,
// Amazon Route 53 stops sending query logs to CloudWatch Logs. Route 53 doesn't
// delete any logs that are already in CloudWatch Logs.
//
// For more information about DNS query logs, see CreateQueryLoggingConfig.
//
//    // Example sending a request using the DeleteQueryLoggingConfigRequest method.
//    req := client.DeleteQueryLoggingConfigRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteQueryLoggingConfig
func (c *Route53) DeleteQueryLoggingConfigRequest(input *DeleteQueryLoggingConfigInput) DeleteQueryLoggingConfigRequest {
	op := &aws.Operation{
		Name:       opDeleteQueryLoggingConfig,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2013-04-01/queryloggingconfig/{Id}",
	}

	if input == nil {
		input = &DeleteQueryLoggingConfigInput{}
	}

	output := &DeleteQueryLoggingConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteQueryLoggingConfigRequest{Request: req, Input: input, Copy: c.DeleteQueryLoggingConfigRequest}
}

const opDeleteReusableDelegationSet = "DeleteReusableDelegationSet"

// DeleteReusableDelegationSetRequest is a API request type for the DeleteReusableDelegationSet API operation.
type DeleteReusableDelegationSetRequest struct {
	*aws.Request
	Input *DeleteReusableDelegationSetInput
	Copy  func(*DeleteReusableDelegationSetInput) DeleteReusableDelegationSetRequest
}

// Send marshals and sends the DeleteReusableDelegationSet API request.
func (r DeleteReusableDelegationSetRequest) Send(ctx context.Context) (*DeleteReusableDelegationSetOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteReusableDelegationSetOutput), nil
}

// DeleteReusableDelegationSetRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Deletes a reusable delegation set.
//
// You can delete a reusable delegation set only if it isn't associated with
// any hosted zones.
//
// To verify that the reusable delegation set is not associated with any hosted
// zones, submit a GetReusableDelegationSet request and specify the ID of the
// reusable delegation set that you want to delete.
//
//    // Example sending a request using the DeleteReusableDelegationSetRequest method.
//    req := client.DeleteReusableDelegationSetRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteReusableDelegationSet
func (c *Route53) DeleteReusableDelegationSetRequest(input *DeleteReusableDelegationSetInput) DeleteReusableDelegationSetRequest {
	op := &aws.Operation{
		Name:       opDeleteReusableDelegationSet,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2013-04-01/delegationset/{Id}",
	}

	if input == nil {
		input = &DeleteReusableDelegationSetInput{}
	}

	output := &DeleteReusableDelegationSetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteReusableDelegationSetRequest{Request: req, Input: input, Copy: c.DeleteReusableDelegationSetRequest}
}

const opDeleteTrafficPolicy = "DeleteTrafficPolicy"

// DeleteTrafficPolicyRequest is a API request type for the DeleteTrafficPolicy API operation.
type DeleteTrafficPolicyRequest struct {
	*aws.Request
	Input *DeleteTrafficPolicyInput
	Copy  func(*DeleteTrafficPolicyInput) DeleteTrafficPolicyRequest
}

// Send marshals and sends the DeleteTrafficPolicy API request.
func (r DeleteTrafficPolicyRequest) Send(ctx context.Context) (*DeleteTrafficPolicyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTrafficPolicyOutput), nil
}

// DeleteTrafficPolicyRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Deletes a traffic policy.
//
//    // Example sending a request using the DeleteTrafficPolicyRequest method.
//    req := client.DeleteTrafficPolicyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteTrafficPolicy
func (c *Route53) DeleteTrafficPolicyRequest(input *DeleteTrafficPolicyInput) DeleteTrafficPolicyRequest {
	op := &aws.Operation{
		Name:       opDeleteTrafficPolicy,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2013-04-01/trafficpolicy/{Id}/{Version}",
	}

	if input == nil {
		input = &DeleteTrafficPolicyInput{}
	}

	output := &DeleteTrafficPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTrafficPolicyRequest{Request: req, Input: input, Copy: c.DeleteTrafficPolicyRequest}
}

const opDeleteTrafficPolicyInstance = "DeleteTrafficPolicyInstance"

// DeleteTrafficPolicyInstanceRequest is a API request type for the DeleteTrafficPolicyInstance API operation.
type DeleteTrafficPolicyInstanceRequest struct {
	*aws.Request
	Input *DeleteTrafficPolicyInstanceInput
	Copy  func(*DeleteTrafficPolicyInstanceInput) DeleteTrafficPolicyInstanceRequest
}

// Send marshals and sends the DeleteTrafficPolicyInstance API request.
func (r DeleteTrafficPolicyInstanceRequest) Send(ctx context.Context) (*DeleteTrafficPolicyInstanceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteTrafficPolicyInstanceOutput), nil
}

// DeleteTrafficPolicyInstanceRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Deletes a traffic policy instance and all of the resource record sets that
// Amazon Route 53 created when you created the instance.
//
// In the Route 53 console, traffic policy instances are known as policy records.
//
//    // Example sending a request using the DeleteTrafficPolicyInstanceRequest method.
//    req := client.DeleteTrafficPolicyInstanceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteTrafficPolicyInstance
func (c *Route53) DeleteTrafficPolicyInstanceRequest(input *DeleteTrafficPolicyInstanceInput) DeleteTrafficPolicyInstanceRequest {
	op := &aws.Operation{
		Name:       opDeleteTrafficPolicyInstance,
		HTTPMethod: "DELETE",
		HTTPPath:   "/2013-04-01/trafficpolicyinstance/{Id}",
	}

	if input == nil {
		input = &DeleteTrafficPolicyInstanceInput{}
	}

	output := &DeleteTrafficPolicyInstanceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteTrafficPolicyInstanceRequest{Request: req, Input: input, Copy: c.DeleteTrafficPolicyInstanceRequest}
}

const opDeleteVPCAssociationAuthorization = "DeleteVPCAssociationAuthorization"

// DeleteVPCAssociationAuthorizationRequest is a API request type for the DeleteVPCAssociationAuthorization API operation.
type DeleteVPCAssociationAuthorizationRequest struct {
	*aws.Request
	Input *DeleteVPCAssociationAuthorizationInput
	Copy  func(*DeleteVPCAssociationAuthorizationInput) DeleteVPCAssociationAuthorizationRequest
}

// Send marshals and sends the DeleteVPCAssociationAuthorization API request.
func (r DeleteVPCAssociationAuthorizationRequest) Send(ctx context.Context) (*DeleteVPCAssociationAuthorizationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DeleteVPCAssociationAuthorizationOutput), nil
}

// DeleteVPCAssociationAuthorizationRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Removes authorization to submit an AssociateVPCWithHostedZone request to
// associate a specified VPC with a hosted zone that was created by a different
// account. You must use the account that created the hosted zone to submit
// a DeleteVPCAssociationAuthorization request.
//
// Sending this request only prevents the AWS account that created the VPC from
// associating the VPC with the Amazon Route 53 hosted zone in the future. If
// the VPC is already associated with the hosted zone, DeleteVPCAssociationAuthorization
// won't disassociate the VPC from the hosted zone. If you want to delete an
// existing association, use DisassociateVPCFromHostedZone.
//
//    // Example sending a request using the DeleteVPCAssociationAuthorizationRequest method.
//    req := client.DeleteVPCAssociationAuthorizationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteVPCAssociationAuthorization
func (c *Route53) DeleteVPCAssociationAuthorizationRequest(input *DeleteVPCAssociationAuthorizationInput) DeleteVPCAssociationAuthorizationRequest {
	op := &aws.Operation{
		Name:       opDeleteVPCAssociationAuthorization,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}/deauthorizevpcassociation",
	}

	if input == nil {
		input = &DeleteVPCAssociationAuthorizationInput{}
	}

	output := &DeleteVPCAssociationAuthorizationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DeleteVPCAssociationAuthorizationRequest{Request: req, Input: input, Copy: c.DeleteVPCAssociationAuthorizationRequest}
}

const opDisassociateVPCFromHostedZone = "DisassociateVPCFromHostedZone"

// DisassociateVPCFromHostedZoneRequest is a API request type for the DisassociateVPCFromHostedZone API operation.
type DisassociateVPCFromHostedZoneRequest struct {
	*aws.Request
	Input *DisassociateVPCFromHostedZoneInput
	Copy  func(*DisassociateVPCFromHostedZoneInput) DisassociateVPCFromHostedZoneRequest
}

// Send marshals and sends the DisassociateVPCFromHostedZone API request.
func (r DisassociateVPCFromHostedZoneRequest) Send(ctx context.Context) (*DisassociateVPCFromHostedZoneOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*DisassociateVPCFromHostedZoneOutput), nil
}

// DisassociateVPCFromHostedZoneRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Disassociates a VPC from a Amazon Route 53 private hosted zone. Note the
// following:
//
//    * You can't disassociate the last VPC from a private hosted zone.
//
//    * You can't convert a private hosted zone into a public hosted zone.
//
//    * You can submit a DisassociateVPCFromHostedZone request using either
//    the account that created the hosted zone or the account that created the
//    VPC.
//
//    // Example sending a request using the DisassociateVPCFromHostedZoneRequest method.
//    req := client.DisassociateVPCFromHostedZoneRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DisassociateVPCFromHostedZone
func (c *Route53) DisassociateVPCFromHostedZoneRequest(input *DisassociateVPCFromHostedZoneInput) DisassociateVPCFromHostedZoneRequest {
	op := &aws.Operation{
		Name:       opDisassociateVPCFromHostedZone,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}/disassociatevpc",
	}

	if input == nil {
		input = &DisassociateVPCFromHostedZoneInput{}
	}

	output := &DisassociateVPCFromHostedZoneOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return DisassociateVPCFromHostedZoneRequest{Request: req, Input: input, Copy: c.DisassociateVPCFromHostedZoneRequest}
}

const opGetAccountLimit = "GetAccountLimit"

// GetAccountLimitRequest is a API request type for the GetAccountLimit API operation.
type GetAccountLimitRequest struct {
	*aws.Request
	Input *GetAccountLimitInput
	Copy  func(*GetAccountLimitInput) GetAccountLimitRequest
}

// Send marshals and sends the GetAccountLimit API request.
func (r GetAccountLimitRequest) Send(ctx context.Context) (*GetAccountLimitOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetAccountLimitOutput), nil
}

// GetAccountLimitRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets the specified limit for the current account, for example, the maximum
// number of health checks that you can create using the account.
//
// For the default limit, see Limits (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html)
// in the Amazon Route 53 Developer Guide. To request a higher limit, open a
// case (https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53).
//
//    // Example sending a request using the GetAccountLimitRequest method.
//    req := client.GetAccountLimitRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetAccountLimit
func (c *Route53) GetAccountLimitRequest(input *GetAccountLimitInput) GetAccountLimitRequest {
	op := &aws.Operation{
		Name:       opGetAccountLimit,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/accountlimit/{Type}",
	}

	if input == nil {
		input = &GetAccountLimitInput{}
	}

	output := &GetAccountLimitOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetAccountLimitRequest{Request: req, Input: input, Copy: c.GetAccountLimitRequest}
}

const opGetChange = "GetChange"

// GetChangeRequest is a API request type for the GetChange API operation.
type GetChangeRequest struct {
	*aws.Request
	Input *GetChangeInput
	Copy  func(*GetChangeInput) GetChangeRequest
}

// Send marshals and sends the GetChange API request.
func (r GetChangeRequest) Send(ctx context.Context) (*GetChangeOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetChangeOutput), nil
}

// GetChangeRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Returns the current status of a change batch request. The status is one of
// the following values:
//
//    * PENDING indicates that the changes in this request have not propagated
//    to all Amazon Route 53 DNS servers. This is the initial status of all
//    change batch requests.
//
//    * INSYNC indicates that the changes have propagated to all Route 53 DNS
//    servers.
//
//    // Example sending a request using the GetChangeRequest method.
//    req := client.GetChangeRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetChange
func (c *Route53) GetChangeRequest(input *GetChangeInput) GetChangeRequest {
	op := &aws.Operation{
		Name:       opGetChange,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/change/{Id}",
	}

	if input == nil {
		input = &GetChangeInput{}
	}

	output := &GetChangeOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetChangeRequest{Request: req, Input: input, Copy: c.GetChangeRequest}
}

const opGetCheckerIpRanges = "GetCheckerIpRanges"

// GetCheckerIpRangesRequest is a API request type for the GetCheckerIpRanges API operation.
type GetCheckerIpRangesRequest struct {
	*aws.Request
	Input *GetCheckerIpRangesInput
	Copy  func(*GetCheckerIpRangesInput) GetCheckerIpRangesRequest
}

// Send marshals and sends the GetCheckerIpRanges API request.
func (r GetCheckerIpRangesRequest) Send(ctx context.Context) (*GetCheckerIpRangesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetCheckerIpRangesOutput), nil
}

// GetCheckerIpRangesRequest returns a request value for making API operation for
// Amazon Route 53.
//
// GetCheckerIpRanges still works, but we recommend that you download ip-ranges.json,
// which includes IP address ranges for all AWS services. For more information,
// see IP Address Ranges of Amazon Route 53 Servers (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/route-53-ip-addresses.html)
// in the Amazon Route 53 Developer Guide.
//
//    // Example sending a request using the GetCheckerIpRangesRequest method.
//    req := client.GetCheckerIpRangesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetCheckerIpRanges
func (c *Route53) GetCheckerIpRangesRequest(input *GetCheckerIpRangesInput) GetCheckerIpRangesRequest {
	op := &aws.Operation{
		Name:       opGetCheckerIpRanges,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/checkeripranges",
	}

	if input == nil {
		input = &GetCheckerIpRangesInput{}
	}

	output := &GetCheckerIpRangesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetCheckerIpRangesRequest{Request: req, Input: input, Copy: c.GetCheckerIpRangesRequest}
}

const opGetGeoLocation = "GetGeoLocation"

// GetGeoLocationRequest is a API request type for the GetGeoLocation API operation.
type GetGeoLocationRequest struct {
	*aws.Request
	Input *GetGeoLocationInput
	Copy  func(*GetGeoLocationInput) GetGeoLocationRequest
}

// Send marshals and sends the GetGeoLocation API request.
func (r GetGeoLocationRequest) Send(ctx context.Context) (*GetGeoLocationOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetGeoLocationOutput), nil
}

// GetGeoLocationRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about whether a specified geographic location is supported
// for Amazon Route 53 geolocation resource record sets.
//
// Use the following syntax to determine whether a continent is supported for
// geolocation:
//
// GET /2013-04-01/geolocation?continentcode=two-letter abbreviation for a continent
//
// Use the following syntax to determine whether a country is supported for
// geolocation:
//
// GET /2013-04-01/geolocation?countrycode=two-character country code
//
// Use the following syntax to determine whether a subdivision of a country
// is supported for geolocation:
//
// GET /2013-04-01/geolocation?countrycode=two-character country code&subdivisioncode=subdivision
// code
//
//    // Example sending a request using the GetGeoLocationRequest method.
//    req := client.GetGeoLocationRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetGeoLocation
func (c *Route53) GetGeoLocationRequest(input *GetGeoLocationInput) GetGeoLocationRequest {
	op := &aws.Operation{
		Name:       opGetGeoLocation,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/geolocation",
	}

	if input == nil {
		input = &GetGeoLocationInput{}
	}

	output := &GetGeoLocationOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetGeoLocationRequest{Request: req, Input: input, Copy: c.GetGeoLocationRequest}
}

const opGetHealthCheck = "GetHealthCheck"

// GetHealthCheckRequest is a API request type for the GetHealthCheck API operation.
type GetHealthCheckRequest struct {
	*aws.Request
	Input *GetHealthCheckInput
	Copy  func(*GetHealthCheckInput) GetHealthCheckRequest
}

// Send marshals and sends the GetHealthCheck API request.
func (r GetHealthCheckRequest) Send(ctx context.Context) (*GetHealthCheckOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetHealthCheckOutput), nil
}

// GetHealthCheckRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about a specified health check.
//
//    // Example sending a request using the GetHealthCheckRequest method.
//    req := client.GetHealthCheckRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheck
func (c *Route53) GetHealthCheckRequest(input *GetHealthCheckInput) GetHealthCheckRequest {
	op := &aws.Operation{
		Name:       opGetHealthCheck,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/healthcheck/{HealthCheckId}",
	}

	if input == nil {
		input = &GetHealthCheckInput{}
	}

	output := &GetHealthCheckOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetHealthCheckRequest{Request: req, Input: input, Copy: c.GetHealthCheckRequest}
}

const opGetHealthCheckCount = "GetHealthCheckCount"

// GetHealthCheckCountRequest is a API request type for the GetHealthCheckCount API operation.
type GetHealthCheckCountRequest struct {
	*aws.Request
	Input *GetHealthCheckCountInput
	Copy  func(*GetHealthCheckCountInput) GetHealthCheckCountRequest
}

// Send marshals and sends the GetHealthCheckCount API request.
func (r GetHealthCheckCountRequest) Send(ctx context.Context) (*GetHealthCheckCountOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetHealthCheckCountOutput), nil
}

// GetHealthCheckCountRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Retrieves the number of health checks that are associated with the current
// AWS account.
//
//    // Example sending a request using the GetHealthCheckCountRequest method.
//    req := client.GetHealthCheckCountRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckCount
func (c *Route53) GetHealthCheckCountRequest(input *GetHealthCheckCountInput) GetHealthCheckCountRequest {
	op := &aws.Operation{
		Name:       opGetHealthCheckCount,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/healthcheckcount",
	}

	if input == nil {
		input = &GetHealthCheckCountInput{}
	}

	output := &GetHealthCheckCountOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetHealthCheckCountRequest{Request: req, Input: input, Copy: c.GetHealthCheckCountRequest}
}

const opGetHealthCheckLastFailureReason = "GetHealthCheckLastFailureReason"

// GetHealthCheckLastFailureReasonRequest is a API request type for the GetHealthCheckLastFailureReason API operation.
type GetHealthCheckLastFailureReasonRequest struct {
	*aws.Request
	Input *GetHealthCheckLastFailureReasonInput
	Copy  func(*GetHealthCheckLastFailureReasonInput) GetHealthCheckLastFailureReasonRequest
}

// Send marshals and sends the GetHealthCheckLastFailureReason API request.
func (r GetHealthCheckLastFailureReasonRequest) Send(ctx context.Context) (*GetHealthCheckLastFailureReasonOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetHealthCheckLastFailureReasonOutput), nil
}

// GetHealthCheckLastFailureReasonRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets the reason that a specified health check failed most recently.
//
//    // Example sending a request using the GetHealthCheckLastFailureReasonRequest method.
//    req := client.GetHealthCheckLastFailureReasonRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckLastFailureReason
func (c *Route53) GetHealthCheckLastFailureReasonRequest(input *GetHealthCheckLastFailureReasonInput) GetHealthCheckLastFailureReasonRequest {
	op := &aws.Operation{
		Name:       opGetHealthCheckLastFailureReason,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/healthcheck/{HealthCheckId}/lastfailurereason",
	}

	if input == nil {
		input = &GetHealthCheckLastFailureReasonInput{}
	}

	output := &GetHealthCheckLastFailureReasonOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetHealthCheckLastFailureReasonRequest{Request: req, Input: input, Copy: c.GetHealthCheckLastFailureReasonRequest}
}

const opGetHealthCheckStatus = "GetHealthCheckStatus"

// GetHealthCheckStatusRequest is a API request type for the GetHealthCheckStatus API operation.
type GetHealthCheckStatusRequest struct {
	*aws.Request
	Input *GetHealthCheckStatusInput
	Copy  func(*GetHealthCheckStatusInput) GetHealthCheckStatusRequest
}

// Send marshals and sends the GetHealthCheckStatus API request.
func (r GetHealthCheckStatusRequest) Send(ctx context.Context) (*GetHealthCheckStatusOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetHealthCheckStatusOutput), nil
}

// GetHealthCheckStatusRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets status of a specified health check.
//
//    // Example sending a request using the GetHealthCheckStatusRequest method.
//    req := client.GetHealthCheckStatusRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckStatus
func (c *Route53) GetHealthCheckStatusRequest(input *GetHealthCheckStatusInput) GetHealthCheckStatusRequest {
	op := &aws.Operation{
		Name:       opGetHealthCheckStatus,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/healthcheck/{HealthCheckId}/status",
	}

	if input == nil {
		input = &GetHealthCheckStatusInput{}
	}

	output := &GetHealthCheckStatusOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetHealthCheckStatusRequest{Request: req, Input: input, Copy: c.GetHealthCheckStatusRequest}
}

const opGetHostedZone = "GetHostedZone"

// GetHostedZoneRequest is a API request type for the GetHostedZone API operation.
type GetHostedZoneRequest struct {
	*aws.Request
	Input *GetHostedZoneInput
	Copy  func(*GetHostedZoneInput) GetHostedZoneRequest
}

// Send marshals and sends the GetHostedZone API request.
func (r GetHostedZoneRequest) Send(ctx context.Context) (*GetHostedZoneOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetHostedZoneOutput), nil
}

// GetHostedZoneRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about a specified hosted zone including the four name servers
// assigned to the hosted zone.
//
//    // Example sending a request using the GetHostedZoneRequest method.
//    req := client.GetHostedZoneRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZone
func (c *Route53) GetHostedZoneRequest(input *GetHostedZoneInput) GetHostedZoneRequest {
	op := &aws.Operation{
		Name:       opGetHostedZone,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}",
	}

	if input == nil {
		input = &GetHostedZoneInput{}
	}

	output := &GetHostedZoneOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetHostedZoneRequest{Request: req, Input: input, Copy: c.GetHostedZoneRequest}
}

const opGetHostedZoneCount = "GetHostedZoneCount"

// GetHostedZoneCountRequest is a API request type for the GetHostedZoneCount API operation.
type GetHostedZoneCountRequest struct {
	*aws.Request
	Input *GetHostedZoneCountInput
	Copy  func(*GetHostedZoneCountInput) GetHostedZoneCountRequest
}

// Send marshals and sends the GetHostedZoneCount API request.
func (r GetHostedZoneCountRequest) Send(ctx context.Context) (*GetHostedZoneCountOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetHostedZoneCountOutput), nil
}

// GetHostedZoneCountRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Retrieves the number of hosted zones that are associated with the current
// AWS account.
//
//    // Example sending a request using the GetHostedZoneCountRequest method.
//    req := client.GetHostedZoneCountRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZoneCount
func (c *Route53) GetHostedZoneCountRequest(input *GetHostedZoneCountInput) GetHostedZoneCountRequest {
	op := &aws.Operation{
		Name:       opGetHostedZoneCount,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/hostedzonecount",
	}

	if input == nil {
		input = &GetHostedZoneCountInput{}
	}

	output := &GetHostedZoneCountOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetHostedZoneCountRequest{Request: req, Input: input, Copy: c.GetHostedZoneCountRequest}
}

const opGetHostedZoneLimit = "GetHostedZoneLimit"

// GetHostedZoneLimitRequest is a API request type for the GetHostedZoneLimit API operation.
type GetHostedZoneLimitRequest struct {
	*aws.Request
	Input *GetHostedZoneLimitInput
	Copy  func(*GetHostedZoneLimitInput) GetHostedZoneLimitRequest
}

// Send marshals and sends the GetHostedZoneLimit API request.
func (r GetHostedZoneLimitRequest) Send(ctx context.Context) (*GetHostedZoneLimitOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetHostedZoneLimitOutput), nil
}

// GetHostedZoneLimitRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets the specified limit for a specified hosted zone, for example, the maximum
// number of records that you can create in the hosted zone.
//
// For the default limit, see Limits (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html)
// in the Amazon Route 53 Developer Guide. To request a higher limit, open a
// case (https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53).
//
//    // Example sending a request using the GetHostedZoneLimitRequest method.
//    req := client.GetHostedZoneLimitRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZoneLimit
func (c *Route53) GetHostedZoneLimitRequest(input *GetHostedZoneLimitInput) GetHostedZoneLimitRequest {
	op := &aws.Operation{
		Name:       opGetHostedZoneLimit,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/hostedzonelimit/{Id}/{Type}",
	}

	if input == nil {
		input = &GetHostedZoneLimitInput{}
	}

	output := &GetHostedZoneLimitOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetHostedZoneLimitRequest{Request: req, Input: input, Copy: c.GetHostedZoneLimitRequest}
}

const opGetQueryLoggingConfig = "GetQueryLoggingConfig"

// GetQueryLoggingConfigRequest is a API request type for the GetQueryLoggingConfig API operation.
type GetQueryLoggingConfigRequest struct {
	*aws.Request
	Input *GetQueryLoggingConfigInput
	Copy  func(*GetQueryLoggingConfigInput) GetQueryLoggingConfigRequest
}

// Send marshals and sends the GetQueryLoggingConfig API request.
func (r GetQueryLoggingConfigRequest) Send(ctx context.Context) (*GetQueryLoggingConfigOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetQueryLoggingConfigOutput), nil
}

// GetQueryLoggingConfigRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about a specified configuration for DNS query logging.
//
// For more information about DNS query logs, see CreateQueryLoggingConfig and
// Logging DNS Queries (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html).
//
//    // Example sending a request using the GetQueryLoggingConfigRequest method.
//    req := client.GetQueryLoggingConfigRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetQueryLoggingConfig
func (c *Route53) GetQueryLoggingConfigRequest(input *GetQueryLoggingConfigInput) GetQueryLoggingConfigRequest {
	op := &aws.Operation{
		Name:       opGetQueryLoggingConfig,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/queryloggingconfig/{Id}",
	}

	if input == nil {
		input = &GetQueryLoggingConfigInput{}
	}

	output := &GetQueryLoggingConfigOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetQueryLoggingConfigRequest{Request: req, Input: input, Copy: c.GetQueryLoggingConfigRequest}
}

const opGetReusableDelegationSet = "GetReusableDelegationSet"

// GetReusableDelegationSetRequest is a API request type for the GetReusableDelegationSet API operation.
type GetReusableDelegationSetRequest struct {
	*aws.Request
	Input *GetReusableDelegationSetInput
	Copy  func(*GetReusableDelegationSetInput) GetReusableDelegationSetRequest
}

// Send marshals and sends the GetReusableDelegationSet API request.
func (r GetReusableDelegationSetRequest) Send(ctx context.Context) (*GetReusableDelegationSetOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetReusableDelegationSetOutput), nil
}

// GetReusableDelegationSetRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Retrieves information about a specified reusable delegation set, including
// the four name servers that are assigned to the delegation set.
//
//    // Example sending a request using the GetReusableDelegationSetRequest method.
//    req := client.GetReusableDelegationSetRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetReusableDelegationSet
func (c *Route53) GetReusableDelegationSetRequest(input *GetReusableDelegationSetInput) GetReusableDelegationSetRequest {
	op := &aws.Operation{
		Name:       opGetReusableDelegationSet,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/delegationset/{Id}",
	}

	if input == nil {
		input = &GetReusableDelegationSetInput{}
	}

	output := &GetReusableDelegationSetOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetReusableDelegationSetRequest{Request: req, Input: input, Copy: c.GetReusableDelegationSetRequest}
}

const opGetReusableDelegationSetLimit = "GetReusableDelegationSetLimit"

// GetReusableDelegationSetLimitRequest is a API request type for the GetReusableDelegationSetLimit API operation.
type GetReusableDelegationSetLimitRequest struct {
	*aws.Request
	Input *GetReusableDelegationSetLimitInput
	Copy  func(*GetReusableDelegationSetLimitInput) GetReusableDelegationSetLimitRequest
}

// Send marshals and sends the GetReusableDelegationSetLimit API request.
func (r GetReusableDelegationSetLimitRequest) Send(ctx context.Context) (*GetReusableDelegationSetLimitOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetReusableDelegationSetLimitOutput), nil
}

// GetReusableDelegationSetLimitRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets the maximum number of hosted zones that you can associate with the specified
// reusable delegation set.
//
// For the default limit, see Limits (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html)
// in the Amazon Route 53 Developer Guide. To request a higher limit, open a
// case (https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-route53).
//
//    // Example sending a request using the GetReusableDelegationSetLimitRequest method.
//    req := client.GetReusableDelegationSetLimitRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetReusableDelegationSetLimit
func (c *Route53) GetReusableDelegationSetLimitRequest(input *GetReusableDelegationSetLimitInput) GetReusableDelegationSetLimitRequest {
	op := &aws.Operation{
		Name:       opGetReusableDelegationSetLimit,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/reusabledelegationsetlimit/{Id}/{Type}",
	}

	if input == nil {
		input = &GetReusableDelegationSetLimitInput{}
	}

	output := &GetReusableDelegationSetLimitOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetReusableDelegationSetLimitRequest{Request: req, Input: input, Copy: c.GetReusableDelegationSetLimitRequest}
}

const opGetTrafficPolicy = "GetTrafficPolicy"

// GetTrafficPolicyRequest is a API request type for the GetTrafficPolicy API operation.
type GetTrafficPolicyRequest struct {
	*aws.Request
	Input *GetTrafficPolicyInput
	Copy  func(*GetTrafficPolicyInput) GetTrafficPolicyRequest
}

// Send marshals and sends the GetTrafficPolicy API request.
func (r GetTrafficPolicyRequest) Send(ctx context.Context) (*GetTrafficPolicyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTrafficPolicyOutput), nil
}

// GetTrafficPolicyRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about a specific traffic policy version.
//
//    // Example sending a request using the GetTrafficPolicyRequest method.
//    req := client.GetTrafficPolicyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicy
func (c *Route53) GetTrafficPolicyRequest(input *GetTrafficPolicyInput) GetTrafficPolicyRequest {
	op := &aws.Operation{
		Name:       opGetTrafficPolicy,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/trafficpolicy/{Id}/{Version}",
	}

	if input == nil {
		input = &GetTrafficPolicyInput{}
	}

	output := &GetTrafficPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTrafficPolicyRequest{Request: req, Input: input, Copy: c.GetTrafficPolicyRequest}
}

const opGetTrafficPolicyInstance = "GetTrafficPolicyInstance"

// GetTrafficPolicyInstanceRequest is a API request type for the GetTrafficPolicyInstance API operation.
type GetTrafficPolicyInstanceRequest struct {
	*aws.Request
	Input *GetTrafficPolicyInstanceInput
	Copy  func(*GetTrafficPolicyInstanceInput) GetTrafficPolicyInstanceRequest
}

// Send marshals and sends the GetTrafficPolicyInstance API request.
func (r GetTrafficPolicyInstanceRequest) Send(ctx context.Context) (*GetTrafficPolicyInstanceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTrafficPolicyInstanceOutput), nil
}

// GetTrafficPolicyInstanceRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about a specified traffic policy instance.
//
// After you submit a CreateTrafficPolicyInstance or an UpdateTrafficPolicyInstance
// request, there's a brief delay while Amazon Route 53 creates the resource
// record sets that are specified in the traffic policy definition. For more
// information, see the State response element.
//
// In the Route 53 console, traffic policy instances are known as policy records.
//
//    // Example sending a request using the GetTrafficPolicyInstanceRequest method.
//    req := client.GetTrafficPolicyInstanceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicyInstance
func (c *Route53) GetTrafficPolicyInstanceRequest(input *GetTrafficPolicyInstanceInput) GetTrafficPolicyInstanceRequest {
	op := &aws.Operation{
		Name:       opGetTrafficPolicyInstance,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/trafficpolicyinstance/{Id}",
	}

	if input == nil {
		input = &GetTrafficPolicyInstanceInput{}
	}

	output := &GetTrafficPolicyInstanceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTrafficPolicyInstanceRequest{Request: req, Input: input, Copy: c.GetTrafficPolicyInstanceRequest}
}

const opGetTrafficPolicyInstanceCount = "GetTrafficPolicyInstanceCount"

// GetTrafficPolicyInstanceCountRequest is a API request type for the GetTrafficPolicyInstanceCount API operation.
type GetTrafficPolicyInstanceCountRequest struct {
	*aws.Request
	Input *GetTrafficPolicyInstanceCountInput
	Copy  func(*GetTrafficPolicyInstanceCountInput) GetTrafficPolicyInstanceCountRequest
}

// Send marshals and sends the GetTrafficPolicyInstanceCount API request.
func (r GetTrafficPolicyInstanceCountRequest) Send(ctx context.Context) (*GetTrafficPolicyInstanceCountOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*GetTrafficPolicyInstanceCountOutput), nil
}

// GetTrafficPolicyInstanceCountRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets the number of traffic policy instances that are associated with the
// current AWS account.
//
//    // Example sending a request using the GetTrafficPolicyInstanceCountRequest method.
//    req := client.GetTrafficPolicyInstanceCountRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicyInstanceCount
func (c *Route53) GetTrafficPolicyInstanceCountRequest(input *GetTrafficPolicyInstanceCountInput) GetTrafficPolicyInstanceCountRequest {
	op := &aws.Operation{
		Name:       opGetTrafficPolicyInstanceCount,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/trafficpolicyinstancecount",
	}

	if input == nil {
		input = &GetTrafficPolicyInstanceCountInput{}
	}

	output := &GetTrafficPolicyInstanceCountOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return GetTrafficPolicyInstanceCountRequest{Request: req, Input: input, Copy: c.GetTrafficPolicyInstanceCountRequest}
}

const opListGeoLocations = "ListGeoLocations"

// ListGeoLocationsRequest is a API request type for the ListGeoLocations API operation.
type ListGeoLocationsRequest struct {
	*aws.Request
	Input *ListGeoLocationsInput
	Copy  func(*ListGeoLocationsInput) ListGeoLocationsRequest
}

// Send marshals and sends the ListGeoLocations API request.
func (r ListGeoLocationsRequest) Send(ctx context.Context) (*ListGeoLocationsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListGeoLocationsOutput), nil
}

// ListGeoLocationsRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Retrieves a list of supported geographic locations.
//
// Countries are listed first, and continents are listed last. If Amazon Route
// 53 supports subdivisions for a country (for example, states or provinces),
// the subdivisions for that country are listed in alphabetical order immediately
// after the corresponding country.
//
//    // Example sending a request using the ListGeoLocationsRequest method.
//    req := client.ListGeoLocationsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListGeoLocations
func (c *Route53) ListGeoLocationsRequest(input *ListGeoLocationsInput) ListGeoLocationsRequest {
	op := &aws.Operation{
		Name:       opListGeoLocations,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/geolocations",
	}

	if input == nil {
		input = &ListGeoLocationsInput{}
	}

	output := &ListGeoLocationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListGeoLocationsRequest{Request: req, Input: input, Copy: c.ListGeoLocationsRequest}
}

const opListHealthChecks = "ListHealthChecks"

// ListHealthChecksRequest is a API request type for the ListHealthChecks API operation.
type ListHealthChecksRequest struct {
	*aws.Request
	Input *ListHealthChecksInput
	Copy  func(*ListHealthChecksInput) ListHealthChecksRequest
}

// Send marshals and sends the ListHealthChecks API request.
func (r ListHealthChecksRequest) Send(ctx context.Context) (*ListHealthChecksOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListHealthChecksOutput), nil
}

// ListHealthChecksRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Retrieve a list of the health checks that are associated with the current
// AWS account.
//
//    // Example sending a request using the ListHealthChecksRequest method.
//    req := client.ListHealthChecksRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHealthChecks
func (c *Route53) ListHealthChecksRequest(input *ListHealthChecksInput) ListHealthChecksRequest {
	op := &aws.Operation{
		Name:       opListHealthChecks,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/healthcheck",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"NextMarker"},
			LimitToken:      "MaxItems",
			TruncationToken: "IsTruncated",
		},
	}

	if input == nil {
		input = &ListHealthChecksInput{}
	}

	output := &ListHealthChecksOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListHealthChecksRequest{Request: req, Input: input, Copy: c.ListHealthChecksRequest}
}

// Paginate pages iterates over the pages of a ListHealthChecksRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListHealthChecks operation.
//		req := client.ListHealthChecksRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListHealthChecksRequest) Paginate(opts ...aws.Option) ListHealthChecksPager {
	return ListHealthChecksPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListHealthChecksInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListHealthChecksPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListHealthChecksPager struct {
	aws.Pager
}

func (p *ListHealthChecksPager) CurrentPage() *ListHealthChecksOutput {
	return p.Pager.CurrentPage().(*ListHealthChecksOutput)
}

const opListHostedZones = "ListHostedZones"

// ListHostedZonesRequest is a API request type for the ListHostedZones API operation.
type ListHostedZonesRequest struct {
	*aws.Request
	Input *ListHostedZonesInput
	Copy  func(*ListHostedZonesInput) ListHostedZonesRequest
}

// Send marshals and sends the ListHostedZones API request.
func (r ListHostedZonesRequest) Send(ctx context.Context) (*ListHostedZonesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListHostedZonesOutput), nil
}

// ListHostedZonesRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Retrieves a list of the public and private hosted zones that are associated
// with the current AWS account. The response includes a HostedZones child element
// for each hosted zone.
//
// Amazon Route 53 returns a maximum of 100 items in each response. If you have
// a lot of hosted zones, you can use the maxitems parameter to list them in
// groups of up to 100.
//
//    // Example sending a request using the ListHostedZonesRequest method.
//    req := client.ListHostedZonesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHostedZones
func (c *Route53) ListHostedZonesRequest(input *ListHostedZonesInput) ListHostedZonesRequest {
	op := &aws.Operation{
		Name:       opListHostedZones,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/hostedzone",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"Marker"},
			OutputTokens:    []string{"NextMarker"},
			LimitToken:      "MaxItems",
			TruncationToken: "IsTruncated",
		},
	}

	if input == nil {
		input = &ListHostedZonesInput{}
	}

	output := &ListHostedZonesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListHostedZonesRequest{Request: req, Input: input, Copy: c.ListHostedZonesRequest}
}

// Paginate pages iterates over the pages of a ListHostedZonesRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListHostedZones operation.
//		req := client.ListHostedZonesRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListHostedZonesRequest) Paginate(opts ...aws.Option) ListHostedZonesPager {
	return ListHostedZonesPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListHostedZonesInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListHostedZonesPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListHostedZonesPager struct {
	aws.Pager
}

func (p *ListHostedZonesPager) CurrentPage() *ListHostedZonesOutput {
	return p.Pager.CurrentPage().(*ListHostedZonesOutput)
}

const opListHostedZonesByName = "ListHostedZonesByName"

// ListHostedZonesByNameRequest is a API request type for the ListHostedZonesByName API operation.
type ListHostedZonesByNameRequest struct {
	*aws.Request
	Input *ListHostedZonesByNameInput
	Copy  func(*ListHostedZonesByNameInput) ListHostedZonesByNameRequest
}

// Send marshals and sends the ListHostedZonesByName API request.
func (r ListHostedZonesByNameRequest) Send(ctx context.Context) (*ListHostedZonesByNameOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListHostedZonesByNameOutput), nil
}

// ListHostedZonesByNameRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Retrieves a list of your hosted zones in lexicographic order. The response
// includes a HostedZones child element for each hosted zone created by the
// current AWS account.
//
// ListHostedZonesByName sorts hosted zones by name with the labels reversed.
// For example:
//
// com.example.www.
//
// Note the trailing dot, which can change the sort order in some circumstances.
//
// If the domain name includes escape characters or Punycode, ListHostedZonesByName
// alphabetizes the domain name using the escaped or Punycoded value, which
// is the format that Amazon Route 53 saves in its database. For example, to
// create a hosted zone for exämple.com, you specify ex\344mple.com for the
// domain name. ListHostedZonesByName alphabetizes it as:
//
// com.ex\344mple.
//
// The labels are reversed and alphabetized using the escaped value. For more
// information about valid domain name formats, including internationalized
// domain names, see DNS Domain Name Format (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html)
// in the Amazon Route 53 Developer Guide.
//
// Route 53 returns up to 100 items in each response. If you have a lot of hosted
// zones, use the MaxItems parameter to list them in groups of up to 100. The
// response includes values that help navigate from one group of MaxItems hosted
// zones to the next:
//
//    * The DNSName and HostedZoneId elements in the response contain the values,
//    if any, specified for the dnsname and hostedzoneid parameters in the request
//    that produced the current response.
//
//    * The MaxItems element in the response contains the value, if any, that
//    you specified for the maxitems parameter in the request that produced
//    the current response.
//
//    * If the value of IsTruncated in the response is true, there are more
//    hosted zones associated with the current AWS account.
//
// If IsTruncated is false, this response includes the last hosted zone that
//    is associated with the current account. The NextDNSName element and NextHostedZoneId
//    elements are omitted from the response.
//
//    * The NextDNSName and NextHostedZoneId elements in the response contain
//    the domain name and the hosted zone ID of the next hosted zone that is
//    associated with the current AWS account. If you want to list more hosted
//    zones, make another call to ListHostedZonesByName, and specify the value
//    of NextDNSName and NextHostedZoneId in the dnsname and hostedzoneid parameters,
//    respectively.
//
//    // Example sending a request using the ListHostedZonesByNameRequest method.
//    req := client.ListHostedZonesByNameRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHostedZonesByName
func (c *Route53) ListHostedZonesByNameRequest(input *ListHostedZonesByNameInput) ListHostedZonesByNameRequest {
	op := &aws.Operation{
		Name:       opListHostedZonesByName,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/hostedzonesbyname",
	}

	if input == nil {
		input = &ListHostedZonesByNameInput{}
	}

	output := &ListHostedZonesByNameOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListHostedZonesByNameRequest{Request: req, Input: input, Copy: c.ListHostedZonesByNameRequest}
}

const opListQueryLoggingConfigs = "ListQueryLoggingConfigs"

// ListQueryLoggingConfigsRequest is a API request type for the ListQueryLoggingConfigs API operation.
type ListQueryLoggingConfigsRequest struct {
	*aws.Request
	Input *ListQueryLoggingConfigsInput
	Copy  func(*ListQueryLoggingConfigsInput) ListQueryLoggingConfigsRequest
}

// Send marshals and sends the ListQueryLoggingConfigs API request.
func (r ListQueryLoggingConfigsRequest) Send(ctx context.Context) (*ListQueryLoggingConfigsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListQueryLoggingConfigsOutput), nil
}

// ListQueryLoggingConfigsRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Lists the configurations for DNS query logging that are associated with the
// current AWS account or the configuration that is associated with a specified
// hosted zone.
//
// For more information about DNS query logs, see CreateQueryLoggingConfig.
// Additional information, including the format of DNS query logs, appears in
// Logging DNS Queries (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html)
// in the Amazon Route 53 Developer Guide.
//
//    // Example sending a request using the ListQueryLoggingConfigsRequest method.
//    req := client.ListQueryLoggingConfigsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListQueryLoggingConfigs
func (c *Route53) ListQueryLoggingConfigsRequest(input *ListQueryLoggingConfigsInput) ListQueryLoggingConfigsRequest {
	op := &aws.Operation{
		Name:       opListQueryLoggingConfigs,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/queryloggingconfig",
	}

	if input == nil {
		input = &ListQueryLoggingConfigsInput{}
	}

	output := &ListQueryLoggingConfigsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListQueryLoggingConfigsRequest{Request: req, Input: input, Copy: c.ListQueryLoggingConfigsRequest}
}

const opListResourceRecordSets = "ListResourceRecordSets"

// ListResourceRecordSetsRequest is a API request type for the ListResourceRecordSets API operation.
type ListResourceRecordSetsRequest struct {
	*aws.Request
	Input *ListResourceRecordSetsInput
	Copy  func(*ListResourceRecordSetsInput) ListResourceRecordSetsRequest
}

// Send marshals and sends the ListResourceRecordSets API request.
func (r ListResourceRecordSetsRequest) Send(ctx context.Context) (*ListResourceRecordSetsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListResourceRecordSetsOutput), nil
}

// ListResourceRecordSetsRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Lists the resource record sets in a specified hosted zone.
//
// ListResourceRecordSets returns up to 100 resource record sets at a time in
// ASCII order, beginning at a position specified by the name and type elements.
//
// Sort order
//
// ListResourceRecordSets sorts results first by DNS name with the labels reversed,
// for example:
//
// com.example.www.
//
// Note the trailing dot, which can change the sort order when the record name
// contains characters that appear before . (decimal 46) in the ASCII table.
// These characters include the following: ! " # $ % & ' ( ) * + , -
//
// When multiple records have the same DNS name, ListResourceRecordSets sorts
// results by the record type.
//
// Specifying where to start listing records
//
// You can use the name and type elements to specify the resource record set
// that the list begins with:
//
// If you do not specify Name or TypeThe results begin with the first resource
// record set that the hosted zone contains.
//
// If you specify Name but not TypeThe results begin with the first resource
// record set in the list whose name is greater than or equal to Name.
//
// If you specify Type but not NameAmazon Route 53 returns the InvalidInput
// error.
//
// If you specify both Name and TypeThe results begin with the first resource
// record set in the list whose name is greater than or equal to Name, and whose
// type is greater than or equal to Type.
//
// Resource record sets that are PENDING
//
// This action returns the most current version of the records. This includes
// records that are PENDING, and that are not yet available on all Route 53
// DNS servers.
//
// Changing resource record sets
//
// To ensure that you get an accurate listing of the resource record sets for
// a hosted zone at a point in time, do not submit a ChangeResourceRecordSets
// request while you're paging through the results of a ListResourceRecordSets
// request. If you do, some pages may display results without the latest changes
// while other pages display results with the latest changes.
//
// Displaying the next page of results
//
// If a ListResourceRecordSets command returns more than one page of results,
// the value of IsTruncated is true. To display the next page of results, get
// the values of NextRecordName, NextRecordType, and NextRecordIdentifier (if
// any) from the response. Then submit another ListResourceRecordSets request,
// and specify those values for StartRecordName, StartRecordType, and StartRecordIdentifier.
//
//    // Example sending a request using the ListResourceRecordSetsRequest method.
//    req := client.ListResourceRecordSetsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListResourceRecordSets
func (c *Route53) ListResourceRecordSetsRequest(input *ListResourceRecordSetsInput) ListResourceRecordSetsRequest {
	op := &aws.Operation{
		Name:       opListResourceRecordSets,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}/rrset",
		Paginator: &aws.Paginator{
			InputTokens:     []string{"StartRecordName", "StartRecordType", "StartRecordIdentifier"},
			OutputTokens:    []string{"NextRecordName", "NextRecordType", "NextRecordIdentifier"},
			LimitToken:      "MaxItems",
			TruncationToken: "IsTruncated",
		},
	}

	if input == nil {
		input = &ListResourceRecordSetsInput{}
	}

	output := &ListResourceRecordSetsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListResourceRecordSetsRequest{Request: req, Input: input, Copy: c.ListResourceRecordSetsRequest}
}

// Paginate pages iterates over the pages of a ListResourceRecordSetsRequest operation,
// calling the Next method for each page. Using the paginators Next
// method will depict whether or not there are more pages.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListResourceRecordSets operation.
//		req := client.ListResourceRecordSetsRequest(input)
//		p := req.Paginate()
//		for p.Next() {
//			page := p.CurrentPage()
//		}
//
//		if err := p.Err(); err != nil {
//			return err
//		}
//
func (p *ListResourceRecordSetsRequest) Paginate(opts ...aws.Option) ListResourceRecordSetsPager {
	return ListResourceRecordSetsPager{
		Pager: aws.Pager{
			NewRequest: func(ctx context.Context) (*aws.Request, error) {
				var inCpy *ListResourceRecordSetsInput
				if p.Input != nil {
					tmp := *p.Input
					inCpy = &tmp
				}

				req := p.Copy(inCpy)
				req.ApplyOptions(opts...)
				req.SetContext(ctx)

				return req.Request, nil
			},
		},
	}
}

// ListResourceRecordSetsPager is used to paginate the request. This can be done by
// calling Next and CurrentPage.
type ListResourceRecordSetsPager struct {
	aws.Pager
}

func (p *ListResourceRecordSetsPager) CurrentPage() *ListResourceRecordSetsOutput {
	return p.Pager.CurrentPage().(*ListResourceRecordSetsOutput)
}

const opListReusableDelegationSets = "ListReusableDelegationSets"

// ListReusableDelegationSetsRequest is a API request type for the ListReusableDelegationSets API operation.
type ListReusableDelegationSetsRequest struct {
	*aws.Request
	Input *ListReusableDelegationSetsInput
	Copy  func(*ListReusableDelegationSetsInput) ListReusableDelegationSetsRequest
}

// Send marshals and sends the ListReusableDelegationSets API request.
func (r ListReusableDelegationSetsRequest) Send(ctx context.Context) (*ListReusableDelegationSetsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListReusableDelegationSetsOutput), nil
}

// ListReusableDelegationSetsRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Retrieves a list of the reusable delegation sets that are associated with
// the current AWS account.
//
//    // Example sending a request using the ListReusableDelegationSetsRequest method.
//    req := client.ListReusableDelegationSetsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListReusableDelegationSets
func (c *Route53) ListReusableDelegationSetsRequest(input *ListReusableDelegationSetsInput) ListReusableDelegationSetsRequest {
	op := &aws.Operation{
		Name:       opListReusableDelegationSets,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/delegationset",
	}

	if input == nil {
		input = &ListReusableDelegationSetsInput{}
	}

	output := &ListReusableDelegationSetsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListReusableDelegationSetsRequest{Request: req, Input: input, Copy: c.ListReusableDelegationSetsRequest}
}

const opListTagsForResource = "ListTagsForResource"

// ListTagsForResourceRequest is a API request type for the ListTagsForResource API operation.
type ListTagsForResourceRequest struct {
	*aws.Request
	Input *ListTagsForResourceInput
	Copy  func(*ListTagsForResourceInput) ListTagsForResourceRequest
}

// Send marshals and sends the ListTagsForResource API request.
func (r ListTagsForResourceRequest) Send(ctx context.Context) (*ListTagsForResourceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTagsForResourceOutput), nil
}

// ListTagsForResourceRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Lists tags for one health check or hosted zone.
//
// For information about using tags for cost allocation, see Using Cost Allocation
// Tags (http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html)
// in the AWS Billing and Cost Management User Guide.
//
//    // Example sending a request using the ListTagsForResourceRequest method.
//    req := client.ListTagsForResourceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTagsForResource
func (c *Route53) ListTagsForResourceRequest(input *ListTagsForResourceInput) ListTagsForResourceRequest {
	op := &aws.Operation{
		Name:       opListTagsForResource,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/tags/{ResourceType}/{ResourceId}",
	}

	if input == nil {
		input = &ListTagsForResourceInput{}
	}

	output := &ListTagsForResourceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTagsForResourceRequest{Request: req, Input: input, Copy: c.ListTagsForResourceRequest}
}

const opListTagsForResources = "ListTagsForResources"

// ListTagsForResourcesRequest is a API request type for the ListTagsForResources API operation.
type ListTagsForResourcesRequest struct {
	*aws.Request
	Input *ListTagsForResourcesInput
	Copy  func(*ListTagsForResourcesInput) ListTagsForResourcesRequest
}

// Send marshals and sends the ListTagsForResources API request.
func (r ListTagsForResourcesRequest) Send(ctx context.Context) (*ListTagsForResourcesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTagsForResourcesOutput), nil
}

// ListTagsForResourcesRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Lists tags for up to 10 health checks or hosted zones.
//
// For information about using tags for cost allocation, see Using Cost Allocation
// Tags (http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html)
// in the AWS Billing and Cost Management User Guide.
//
//    // Example sending a request using the ListTagsForResourcesRequest method.
//    req := client.ListTagsForResourcesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTagsForResources
func (c *Route53) ListTagsForResourcesRequest(input *ListTagsForResourcesInput) ListTagsForResourcesRequest {
	op := &aws.Operation{
		Name:       opListTagsForResources,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/tags/{ResourceType}",
	}

	if input == nil {
		input = &ListTagsForResourcesInput{}
	}

	output := &ListTagsForResourcesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTagsForResourcesRequest{Request: req, Input: input, Copy: c.ListTagsForResourcesRequest}
}

const opListTrafficPolicies = "ListTrafficPolicies"

// ListTrafficPoliciesRequest is a API request type for the ListTrafficPolicies API operation.
type ListTrafficPoliciesRequest struct {
	*aws.Request
	Input *ListTrafficPoliciesInput
	Copy  func(*ListTrafficPoliciesInput) ListTrafficPoliciesRequest
}

// Send marshals and sends the ListTrafficPolicies API request.
func (r ListTrafficPoliciesRequest) Send(ctx context.Context) (*ListTrafficPoliciesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTrafficPoliciesOutput), nil
}

// ListTrafficPoliciesRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about the latest version for every traffic policy that is
// associated with the current AWS account. Policies are listed in the order
// that they were created in.
//
//    // Example sending a request using the ListTrafficPoliciesRequest method.
//    req := client.ListTrafficPoliciesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicies
func (c *Route53) ListTrafficPoliciesRequest(input *ListTrafficPoliciesInput) ListTrafficPoliciesRequest {
	op := &aws.Operation{
		Name:       opListTrafficPolicies,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/trafficpolicies",
	}

	if input == nil {
		input = &ListTrafficPoliciesInput{}
	}

	output := &ListTrafficPoliciesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTrafficPoliciesRequest{Request: req, Input: input, Copy: c.ListTrafficPoliciesRequest}
}

const opListTrafficPolicyInstances = "ListTrafficPolicyInstances"

// ListTrafficPolicyInstancesRequest is a API request type for the ListTrafficPolicyInstances API operation.
type ListTrafficPolicyInstancesRequest struct {
	*aws.Request
	Input *ListTrafficPolicyInstancesInput
	Copy  func(*ListTrafficPolicyInstancesInput) ListTrafficPolicyInstancesRequest
}

// Send marshals and sends the ListTrafficPolicyInstances API request.
func (r ListTrafficPolicyInstancesRequest) Send(ctx context.Context) (*ListTrafficPolicyInstancesOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTrafficPolicyInstancesOutput), nil
}

// ListTrafficPolicyInstancesRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about the traffic policy instances that you created by using
// the current AWS account.
//
// After you submit an UpdateTrafficPolicyInstance request, there's a brief
// delay while Amazon Route 53 creates the resource record sets that are specified
// in the traffic policy definition. For more information, see the State response
// element.
//
// Route 53 returns a maximum of 100 items in each response. If you have a lot
// of traffic policy instances, you can use the MaxItems parameter to list them
// in groups of up to 100.
//
//    // Example sending a request using the ListTrafficPolicyInstancesRequest method.
//    req := client.ListTrafficPolicyInstancesRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstances
func (c *Route53) ListTrafficPolicyInstancesRequest(input *ListTrafficPolicyInstancesInput) ListTrafficPolicyInstancesRequest {
	op := &aws.Operation{
		Name:       opListTrafficPolicyInstances,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/trafficpolicyinstances",
	}

	if input == nil {
		input = &ListTrafficPolicyInstancesInput{}
	}

	output := &ListTrafficPolicyInstancesOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTrafficPolicyInstancesRequest{Request: req, Input: input, Copy: c.ListTrafficPolicyInstancesRequest}
}

const opListTrafficPolicyInstancesByHostedZone = "ListTrafficPolicyInstancesByHostedZone"

// ListTrafficPolicyInstancesByHostedZoneRequest is a API request type for the ListTrafficPolicyInstancesByHostedZone API operation.
type ListTrafficPolicyInstancesByHostedZoneRequest struct {
	*aws.Request
	Input *ListTrafficPolicyInstancesByHostedZoneInput
	Copy  func(*ListTrafficPolicyInstancesByHostedZoneInput) ListTrafficPolicyInstancesByHostedZoneRequest
}

// Send marshals and sends the ListTrafficPolicyInstancesByHostedZone API request.
func (r ListTrafficPolicyInstancesByHostedZoneRequest) Send(ctx context.Context) (*ListTrafficPolicyInstancesByHostedZoneOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTrafficPolicyInstancesByHostedZoneOutput), nil
}

// ListTrafficPolicyInstancesByHostedZoneRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about the traffic policy instances that you created in a
// specified hosted zone.
//
// After you submit a CreateTrafficPolicyInstance or an UpdateTrafficPolicyInstance
// request, there's a brief delay while Amazon Route 53 creates the resource
// record sets that are specified in the traffic policy definition. For more
// information, see the State response element.
//
// Route 53 returns a maximum of 100 items in each response. If you have a lot
// of traffic policy instances, you can use the MaxItems parameter to list them
// in groups of up to 100.
//
//    // Example sending a request using the ListTrafficPolicyInstancesByHostedZoneRequest method.
//    req := client.ListTrafficPolicyInstancesByHostedZoneRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstancesByHostedZone
func (c *Route53) ListTrafficPolicyInstancesByHostedZoneRequest(input *ListTrafficPolicyInstancesByHostedZoneInput) ListTrafficPolicyInstancesByHostedZoneRequest {
	op := &aws.Operation{
		Name:       opListTrafficPolicyInstancesByHostedZone,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/trafficpolicyinstances/hostedzone",
	}

	if input == nil {
		input = &ListTrafficPolicyInstancesByHostedZoneInput{}
	}

	output := &ListTrafficPolicyInstancesByHostedZoneOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTrafficPolicyInstancesByHostedZoneRequest{Request: req, Input: input, Copy: c.ListTrafficPolicyInstancesByHostedZoneRequest}
}

const opListTrafficPolicyInstancesByPolicy = "ListTrafficPolicyInstancesByPolicy"

// ListTrafficPolicyInstancesByPolicyRequest is a API request type for the ListTrafficPolicyInstancesByPolicy API operation.
type ListTrafficPolicyInstancesByPolicyRequest struct {
	*aws.Request
	Input *ListTrafficPolicyInstancesByPolicyInput
	Copy  func(*ListTrafficPolicyInstancesByPolicyInput) ListTrafficPolicyInstancesByPolicyRequest
}

// Send marshals and sends the ListTrafficPolicyInstancesByPolicy API request.
func (r ListTrafficPolicyInstancesByPolicyRequest) Send(ctx context.Context) (*ListTrafficPolicyInstancesByPolicyOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTrafficPolicyInstancesByPolicyOutput), nil
}

// ListTrafficPolicyInstancesByPolicyRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about the traffic policy instances that you created by using
// a specify traffic policy version.
//
// After you submit a CreateTrafficPolicyInstance or an UpdateTrafficPolicyInstance
// request, there's a brief delay while Amazon Route 53 creates the resource
// record sets that are specified in the traffic policy definition. For more
// information, see the State response element.
//
// Route 53 returns a maximum of 100 items in each response. If you have a lot
// of traffic policy instances, you can use the MaxItems parameter to list them
// in groups of up to 100.
//
//    // Example sending a request using the ListTrafficPolicyInstancesByPolicyRequest method.
//    req := client.ListTrafficPolicyInstancesByPolicyRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstancesByPolicy
func (c *Route53) ListTrafficPolicyInstancesByPolicyRequest(input *ListTrafficPolicyInstancesByPolicyInput) ListTrafficPolicyInstancesByPolicyRequest {
	op := &aws.Operation{
		Name:       opListTrafficPolicyInstancesByPolicy,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/trafficpolicyinstances/trafficpolicy",
	}

	if input == nil {
		input = &ListTrafficPolicyInstancesByPolicyInput{}
	}

	output := &ListTrafficPolicyInstancesByPolicyOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTrafficPolicyInstancesByPolicyRequest{Request: req, Input: input, Copy: c.ListTrafficPolicyInstancesByPolicyRequest}
}

const opListTrafficPolicyVersions = "ListTrafficPolicyVersions"

// ListTrafficPolicyVersionsRequest is a API request type for the ListTrafficPolicyVersions API operation.
type ListTrafficPolicyVersionsRequest struct {
	*aws.Request
	Input *ListTrafficPolicyVersionsInput
	Copy  func(*ListTrafficPolicyVersionsInput) ListTrafficPolicyVersionsRequest
}

// Send marshals and sends the ListTrafficPolicyVersions API request.
func (r ListTrafficPolicyVersionsRequest) Send(ctx context.Context) (*ListTrafficPolicyVersionsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListTrafficPolicyVersionsOutput), nil
}

// ListTrafficPolicyVersionsRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets information about all of the versions for a specified traffic policy.
//
// Traffic policy versions are listed in numerical order by VersionNumber.
//
//    // Example sending a request using the ListTrafficPolicyVersionsRequest method.
//    req := client.ListTrafficPolicyVersionsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyVersions
func (c *Route53) ListTrafficPolicyVersionsRequest(input *ListTrafficPolicyVersionsInput) ListTrafficPolicyVersionsRequest {
	op := &aws.Operation{
		Name:       opListTrafficPolicyVersions,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/trafficpolicies/{Id}/versions",
	}

	if input == nil {
		input = &ListTrafficPolicyVersionsInput{}
	}

	output := &ListTrafficPolicyVersionsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListTrafficPolicyVersionsRequest{Request: req, Input: input, Copy: c.ListTrafficPolicyVersionsRequest}
}

const opListVPCAssociationAuthorizations = "ListVPCAssociationAuthorizations"

// ListVPCAssociationAuthorizationsRequest is a API request type for the ListVPCAssociationAuthorizations API operation.
type ListVPCAssociationAuthorizationsRequest struct {
	*aws.Request
	Input *ListVPCAssociationAuthorizationsInput
	Copy  func(*ListVPCAssociationAuthorizationsInput) ListVPCAssociationAuthorizationsRequest
}

// Send marshals and sends the ListVPCAssociationAuthorizations API request.
func (r ListVPCAssociationAuthorizationsRequest) Send(ctx context.Context) (*ListVPCAssociationAuthorizationsOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*ListVPCAssociationAuthorizationsOutput), nil
}

// ListVPCAssociationAuthorizationsRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets a list of the VPCs that were created by other accounts and that can
// be associated with a specified hosted zone because you've submitted one or
// more CreateVPCAssociationAuthorization requests.
//
// The response includes a VPCs element with a VPC child element for each VPC
// that can be associated with the hosted zone.
//
//    // Example sending a request using the ListVPCAssociationAuthorizationsRequest method.
//    req := client.ListVPCAssociationAuthorizationsRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListVPCAssociationAuthorizations
func (c *Route53) ListVPCAssociationAuthorizationsRequest(input *ListVPCAssociationAuthorizationsInput) ListVPCAssociationAuthorizationsRequest {
	op := &aws.Operation{
		Name:       opListVPCAssociationAuthorizations,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}/authorizevpcassociation",
	}

	if input == nil {
		input = &ListVPCAssociationAuthorizationsInput{}
	}

	output := &ListVPCAssociationAuthorizationsOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return ListVPCAssociationAuthorizationsRequest{Request: req, Input: input, Copy: c.ListVPCAssociationAuthorizationsRequest}
}

const opTestDNSAnswer = "TestDNSAnswer"

// TestDNSAnswerRequest is a API request type for the TestDNSAnswer API operation.
type TestDNSAnswerRequest struct {
	*aws.Request
	Input *TestDNSAnswerInput
	Copy  func(*TestDNSAnswerInput) TestDNSAnswerRequest
}

// Send marshals and sends the TestDNSAnswer API request.
func (r TestDNSAnswerRequest) Send(ctx context.Context) (*TestDNSAnswerOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*TestDNSAnswerOutput), nil
}

// TestDNSAnswerRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Gets the value that Amazon Route 53 returns in response to a DNS request
// for a specified record name and type. You can optionally specify the IP address
// of a DNS resolver, an EDNS0 client subnet IP address, and a subnet mask.
//
//    // Example sending a request using the TestDNSAnswerRequest method.
//    req := client.TestDNSAnswerRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/TestDNSAnswer
func (c *Route53) TestDNSAnswerRequest(input *TestDNSAnswerInput) TestDNSAnswerRequest {
	op := &aws.Operation{
		Name:       opTestDNSAnswer,
		HTTPMethod: "GET",
		HTTPPath:   "/2013-04-01/testdnsanswer",
	}

	if input == nil {
		input = &TestDNSAnswerInput{}
	}

	output := &TestDNSAnswerOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return TestDNSAnswerRequest{Request: req, Input: input, Copy: c.TestDNSAnswerRequest}
}

const opUpdateHealthCheck = "UpdateHealthCheck"

// UpdateHealthCheckRequest is a API request type for the UpdateHealthCheck API operation.
type UpdateHealthCheckRequest struct {
	*aws.Request
	Input *UpdateHealthCheckInput
	Copy  func(*UpdateHealthCheckInput) UpdateHealthCheckRequest
}

// Send marshals and sends the UpdateHealthCheck API request.
func (r UpdateHealthCheckRequest) Send(ctx context.Context) (*UpdateHealthCheckOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateHealthCheckOutput), nil
}

// UpdateHealthCheckRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Updates an existing health check. Note that some values can't be updated.
//
// For more information about updating health checks, see Creating, Updating,
// and Deleting Health Checks (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html)
// in the Amazon Route 53 Developer Guide.
//
//    // Example sending a request using the UpdateHealthCheckRequest method.
//    req := client.UpdateHealthCheckRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateHealthCheck
func (c *Route53) UpdateHealthCheckRequest(input *UpdateHealthCheckInput) UpdateHealthCheckRequest {
	op := &aws.Operation{
		Name:       opUpdateHealthCheck,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/healthcheck/{HealthCheckId}",
	}

	if input == nil {
		input = &UpdateHealthCheckInput{}
	}

	output := &UpdateHealthCheckOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateHealthCheckRequest{Request: req, Input: input, Copy: c.UpdateHealthCheckRequest}
}

const opUpdateHostedZoneComment = "UpdateHostedZoneComment"

// UpdateHostedZoneCommentRequest is a API request type for the UpdateHostedZoneComment API operation.
type UpdateHostedZoneCommentRequest struct {
	*aws.Request
	Input *UpdateHostedZoneCommentInput
	Copy  func(*UpdateHostedZoneCommentInput) UpdateHostedZoneCommentRequest
}

// Send marshals and sends the UpdateHostedZoneComment API request.
func (r UpdateHostedZoneCommentRequest) Send(ctx context.Context) (*UpdateHostedZoneCommentOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateHostedZoneCommentOutput), nil
}

// UpdateHostedZoneCommentRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Updates the comment for a specified hosted zone.
//
//    // Example sending a request using the UpdateHostedZoneCommentRequest method.
//    req := client.UpdateHostedZoneCommentRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateHostedZoneComment
func (c *Route53) UpdateHostedZoneCommentRequest(input *UpdateHostedZoneCommentInput) UpdateHostedZoneCommentRequest {
	op := &aws.Operation{
		Name:       opUpdateHostedZoneComment,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/hostedzone/{Id}",
	}

	if input == nil {
		input = &UpdateHostedZoneCommentInput{}
	}

	output := &UpdateHostedZoneCommentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateHostedZoneCommentRequest{Request: req, Input: input, Copy: c.UpdateHostedZoneCommentRequest}
}

const opUpdateTrafficPolicyComment = "UpdateTrafficPolicyComment"

// UpdateTrafficPolicyCommentRequest is a API request type for the UpdateTrafficPolicyComment API operation.
type UpdateTrafficPolicyCommentRequest struct {
	*aws.Request
	Input *UpdateTrafficPolicyCommentInput
	Copy  func(*UpdateTrafficPolicyCommentInput) UpdateTrafficPolicyCommentRequest
}

// Send marshals and sends the UpdateTrafficPolicyComment API request.
func (r UpdateTrafficPolicyCommentRequest) Send(ctx context.Context) (*UpdateTrafficPolicyCommentOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateTrafficPolicyCommentOutput), nil
}

// UpdateTrafficPolicyCommentRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Updates the comment for a specified traffic policy version.
//
//    // Example sending a request using the UpdateTrafficPolicyCommentRequest method.
//    req := client.UpdateTrafficPolicyCommentRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateTrafficPolicyComment
func (c *Route53) UpdateTrafficPolicyCommentRequest(input *UpdateTrafficPolicyCommentInput) UpdateTrafficPolicyCommentRequest {
	op := &aws.Operation{
		Name:       opUpdateTrafficPolicyComment,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/trafficpolicy/{Id}/{Version}",
	}

	if input == nil {
		input = &UpdateTrafficPolicyCommentInput{}
	}

	output := &UpdateTrafficPolicyCommentOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateTrafficPolicyCommentRequest{Request: req, Input: input, Copy: c.UpdateTrafficPolicyCommentRequest}
}

const opUpdateTrafficPolicyInstance = "UpdateTrafficPolicyInstance"

// UpdateTrafficPolicyInstanceRequest is a API request type for the UpdateTrafficPolicyInstance API operation.
type UpdateTrafficPolicyInstanceRequest struct {
	*aws.Request
	Input *UpdateTrafficPolicyInstanceInput
	Copy  func(*UpdateTrafficPolicyInstanceInput) UpdateTrafficPolicyInstanceRequest
}

// Send marshals and sends the UpdateTrafficPolicyInstance API request.
func (r UpdateTrafficPolicyInstanceRequest) Send(ctx context.Context) (*UpdateTrafficPolicyInstanceOutput, error) {
	r.Request.SetContext(ctx)
	err := r.Request.Send()
	if err != nil {
		return nil, err
	}

	return r.Request.Data.(*UpdateTrafficPolicyInstanceOutput), nil
}

// UpdateTrafficPolicyInstanceRequest returns a request value for making API operation for
// Amazon Route 53.
//
// Updates the resource record sets in a specified hosted zone that were created
// based on the settings in a specified traffic policy version.
//
// When you update a traffic policy instance, Amazon Route 53 continues to respond
// to DNS queries for the root resource record set name (such as example.com)
// while it replaces one group of resource record sets with another. Route 53
// performs the following operations:
//
// Route 53 creates a new group of resource record sets based on the specified
// traffic policy. This is true regardless of how significant the differences
// are between the existing resource record sets and the new resource record
// sets.
//
// When all of the new resource record sets have been created, Route 53 starts
// to respond to DNS queries for the root resource record set name (such as
// example.com) by using the new resource record sets.
//
// Route 53 deletes the old group of resource record sets that are associated
// with the root resource record set name.
//
//    // Example sending a request using the UpdateTrafficPolicyInstanceRequest method.
//    req := client.UpdateTrafficPolicyInstanceRequest(params)
//    resp, err := req.Send(context.TODO())
//    if err == nil {
//        fmt.Println(resp)
//    }
//
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateTrafficPolicyInstance
func (c *Route53) UpdateTrafficPolicyInstanceRequest(input *UpdateTrafficPolicyInstanceInput) UpdateTrafficPolicyInstanceRequest {
	op := &aws.Operation{
		Name:       opUpdateTrafficPolicyInstance,
		HTTPMethod: "POST",
		HTTPPath:   "/2013-04-01/trafficpolicyinstance/{Id}",
	}

	if input == nil {
		input = &UpdateTrafficPolicyInstanceInput{}
	}

	output := &UpdateTrafficPolicyInstanceOutput{}
	req := c.newRequest(op, input, output)
	output.responseMetadata = aws.Response{Request: req}

	return UpdateTrafficPolicyInstanceRequest{Request: req, Input: input, Copy: c.UpdateTrafficPolicyInstanceRequest}
}

// A complex type that contains the type of limit that you specified in the
// request and the current value for that limit.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/AccountLimit
type AccountLimit struct {
	_ struct{} `type:"structure"`

	// The limit that you requested. Valid values include the following:
	//
	//    * MAX_HEALTH_CHECKS_BY_OWNER: The maximum number of health checks that
	//    you can create using the current account.
	//
	//    * MAX_HOSTED_ZONES_BY_OWNER: The maximum number of hosted zones that you
	//    can create using the current account.
	//
	//    * MAX_REUSABLE_DELEGATION_SETS_BY_OWNER: The maximum number of reusable
	//    delegation sets that you can create using the current account.
	//
	//    * MAX_TRAFFIC_POLICIES_BY_OWNER: The maximum number of traffic policies
	//    that you can create using the current account.
	//
	//    * MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER: The maximum number of traffic
	//    policy instances that you can create using the current account. (Traffic
	//    policy instances are referred to as traffic flow policy records in the
	//    Amazon Route 53 console.)
	//
	// Type is a required field
	Type AccountLimitType `type:"string" required:"true" enum:"true"`

	// The current value for the limit that is specified by AccountLimit$Type.
	//
	// Value is a required field
	Value *int64 `min:"1" type:"long" required:"true"`
}

// String returns the string representation
func (s AccountLimit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AccountLimit) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AccountLimit) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A complex type that identifies the CloudWatch alarm that you want Amazon
// Route 53 health checkers to use to determine whether the specified health
// check is healthy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/AlarmIdentifier
type AlarmIdentifier struct {
	_ struct{} `type:"structure"`

	// The name of the CloudWatch alarm that you want Amazon Route 53 health checkers
	// to use to determine whether this health check is healthy.
	//
	// Route 53 supports CloudWatch alarms with the following features:
	//
	// Standard-resolution metrics. High-resolution metrics aren't supported. For
	// more information, see High-Resolution Metrics (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/publishingMetrics.html#high-resolution-metrics)
	// in the Amazon CloudWatch User Guide.
	//
	// Statistics: Average, Minimum, Maximum, Sum, and SampleCount. Extended statistics
	// aren't supported.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// For the CloudWatch alarm that you want Route 53 health checkers to use to
	// determine whether this health check is healthy, the region that the alarm
	// was created in.
	//
	// For the current list of CloudWatch regions, see Amazon CloudWatch (http://docs.aws.amazon.com/general/latest/gr/rande.html#cw_region)
	// in the AWS Regions and Endpoints chapter of the Amazon Web Services General
	// Reference.
	//
	// Region is a required field
	Region CloudWatchRegion `min:"1" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s AlarmIdentifier) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AlarmIdentifier) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AlarmIdentifier) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AlarmIdentifier"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.Name != nil && len(*s.Name) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Name", 1))
	}
	if len(s.Region) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Region"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AlarmIdentifier) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	if len(s.Region) > 0 {
		v := s.Region

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Region", v, metadata)
	}
	return nil
}

// Alias resource record sets only: Information about the CloudFront distribution,
// Elastic Beanstalk environment, ELB load balancer, Amazon S3 bucket, or Amazon
// Route 53 resource record set that you're redirecting queries to. An Elastic
// Beanstalk environment must have a regionalized subdomain.
//
// When creating resource record sets for a private hosted zone, note the following:
//
//    * Resource record sets can't be created for CloudFront distributions in
//    a private hosted zone.
//
//    * Creating geolocation alias resource record sets or latency alias resource
//    record sets in a private hosted zone is unsupported.
//
//    * For information about creating failover resource record sets in a private
//    hosted zone, see Configuring Failover in a Private Hosted Zone (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/AliasTarget
type AliasTarget struct {
	_ struct{} `type:"structure"`

	// Alias resource record sets only: The value that you specify depends on where
	// you want to route queries:
	//
	// CloudFront distributionSpecify the domain name that CloudFront assigned when
	// you created your distribution.
	//
	// Your CloudFront distribution must include an alternate domain name that matches
	// the name of the resource record set. For example, if the name of the resource
	// record set is acme.example.com, your CloudFront distribution must include
	// acme.example.com as one of the alternate domain names. For more information,
	// see Using Alternate Domain Names (CNAMEs) (http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html)
	// in the Amazon CloudFront Developer Guide.
	//
	// For failover alias records, you can't specify a CloudFront distribution for
	// both the primary and secondary records. A distribution must include an alternate
	// domain name that matches the name of the record. However, the primary and
	// secondary records have the same name, and you can't include the same alternate
	// domain name in more than one distribution.
	//
	// Elastic Beanstalk environmentIf the domain name for your Elastic Beanstalk
	// environment includes the region that you deployed the environment in, you
	// can create an alias record that routes traffic to the environment. For example,
	// the domain name my-environment.us-west-2.elasticbeanstalk.com is a regionalized
	// domain name.
	//
	// For environments that were created before early 2016, the domain name doesn't
	// include the region. To route traffic to these environments, you must create
	// a CNAME record instead of an alias record. Note that you can't create a CNAME
	// record for the root domain name. For example, if your domain name is example.com,
	// you can create a record that routes traffic for acme.example.com to your
	// Elastic Beanstalk environment, but you can't create a record that routes
	// traffic for example.com to your Elastic Beanstalk environment.
	//
	// For Elastic Beanstalk environments that have regionalized subdomains, specify
	// the CNAME attribute for the environment. You can use the following methods
	// to get the value of the CNAME attribute:
	//
	// AWS Management Console: For information about how to get the value by using
	// the console, see Using Custom Domains with AWS Elastic Beanstalk (http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/customdomains.html)
	// in the AWS Elastic Beanstalk Developer Guide.
	//
	// Elastic Beanstalk API: Use the DescribeEnvironments action to get the value
	// of the CNAME attribute. For more information, see DescribeEnvironments (http://docs.aws.amazon.com/elasticbeanstalk/latest/api/API_DescribeEnvironments.html)
	// in the AWS Elastic Beanstalk API Reference.
	//
	// AWS CLI: Use the describe-environments command to get the value of the CNAME
	// attribute. For more information, see describe-environments (http://docs.aws.amazon.com/cli/latest/reference/elasticbeanstalk/describe-environments.html)
	// in the AWS Command Line Interface Reference.
	//
	// ELB load balancerSpecify the DNS name that is associated with the load balancer.
	// Get the DNS name by using the AWS Management Console, the ELB API, or the
	// AWS CLI.
	//
	// AWS Management Console: Go to the EC2 page, choose Load Balancers in the
	// navigation pane, choose the load balancer, choose the Description tab, and
	// get the value of the DNS name field.
	//
	// If you're routing traffic to a Classic Load Balancer, get the value that
	// begins with dualstack. If you're routing traffic to another type of load
	// balancer, get the value that applies to the record type, A or AAAA.
	//
	// Elastic Load Balancing API: Use DescribeLoadBalancers to get the value of
	// DNSName. For more information, see the applicable guide:
	//
	// Classic Load Balancers: DescribeLoadBalancers (http://docs.aws.amazon.com/elasticloadbalancing/2012-06-01/APIReference/API_DescribeLoadBalancers.html)
	//
	// Application and Network Load Balancers: DescribeLoadBalancers (http://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html)
	//
	// AWS CLI: Use describe-load-balancers to get the value of DNSName. For more
	// information, see the applicable guide:
	//
	// Classic Load Balancers: describe-load-balancers (http://docs.aws.amazon.com/cli/latest/reference/elb/describe-load-balancers.html)
	//
	// Application and Network Load Balancers: describe-load-balancers (http://docs.aws.amazon.com/cli/latest/reference/elbv2/describe-load-balancers.html)
	//
	// Amazon S3 bucket that is configured as a static websiteSpecify the domain
	// name of the Amazon S3 website endpoint that you created the bucket in, for
	// example, s3-website.us-east-2.amazonaws.com. For more information about valid
	// values, see the table Amazon Simple Storage Service (S3) Website Endpoints
	// (http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region) in the
	// Amazon Web Services General Reference. For more information about using S3
	// buckets for websites, see Getting Started with Amazon Route 53 (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/getting-started.html)
	// in the Amazon Route 53 Developer Guide.
	//
	// Another Route 53 resource record setSpecify the value of the Name element
	// for a resource record set in the current hosted zone.
	//
	// If you're creating an alias record that has the same name as the hosted zone
	// (known as the zone apex), you can't specify the domain name for a record
	// for which the value of Type is CNAME. This is because the alias record must
	// have the same type as the record that you're routing traffic to, and creating
	// a CNAME record for the zone apex isn't supported even for an alias record.
	//
	// DNSName is a required field
	DNSName *string `type:"string" required:"true"`

	// Applies only to alias, failover alias, geolocation alias, latency alias,
	// and weighted alias resource record sets: When EvaluateTargetHealth is true,
	// an alias resource record set inherits the health of the referenced AWS resource,
	// such as an ELB load balancer or another resource record set in the hosted
	// zone.
	//
	// Note the following:
	//
	// CloudFront distributionsYou can't set EvaluateTargetHealth to true when the
	// alias target is a CloudFront distribution.
	//
	// Elastic Beanstalk environments that have regionalized subdomainsIf you specify
	// an Elastic Beanstalk environment in DNSName and the environment contains
	// an ELB load balancer, Elastic Load Balancing routes queries only to the healthy
	// Amazon EC2 instances that are registered with the load balancer. (An environment
	// automatically contains an ELB load balancer if it includes more than one
	// Amazon EC2 instance.) If you set EvaluateTargetHealth to true and either
	// no Amazon EC2 instances are healthy or the load balancer itself is unhealthy,
	// Route 53 routes queries to other available resources that are healthy, if
	// any.
	//
	// If the environment contains a single Amazon EC2 instance, there are no special
	// requirements.
	//
	// ELB load balancersHealth checking behavior depends on the type of load balancer:
	//
	// Classic Load Balancers: If you specify an ELB Classic Load Balancer in DNSName,
	// Elastic Load Balancing routes queries only to the healthy Amazon EC2 instances
	// that are registered with the load balancer. If you set EvaluateTargetHealth
	// to true and either no EC2 instances are healthy or the load balancer itself
	// is unhealthy, Route 53 routes queries to other resources.
	//
	// Application and Network Load Balancers: If you specify an ELB Application
	// or Network Load Balancer and you set EvaluateTargetHealth to true, Route
	// 53 routes queries to the load balancer based on the health of the target
	// groups that are associated with the load balancer:
	//
	// For an Application or Network Load Balancer to be considered healthy, every
	// target group that contains targets must contain at least one healthy target.
	// If any target group contains only unhealthy targets, the load balancer is
	// considered unhealthy, and Route 53 routes queries to other resources.
	//
	// A target group that has no registered targets is considered healthy.
	//
	// When you create a load balancer, you configure settings for Elastic Load
	// Balancing health checks; they're not Route 53 health checks, but they perform
	// a similar function. Do not create Route 53 health checks for the EC2 instances
	// that you register with an ELB load balancer.
	//
	// S3 bucketsThere are no special requirements for setting EvaluateTargetHealth
	// to true when the alias target is an S3 bucket.
	//
	// Other records in the same hosted zoneIf the AWS resource that you specify
	// in DNSName is a record or a group of records (for example, a group of weighted
	// records) but is not another alias record, we recommend that you associate
	// a health check with all of the records in the alias target. For more information,
	// see What Happens When You Omit Health Checks? (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-complex-configs.html#dns-failover-complex-configs-hc-omitting)
	// in the Amazon Route 53 Developer Guide.
	//
	// For more information and examples, see Amazon Route 53 Health Checks and
	// DNS Failover (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html)
	// in the Amazon Route 53 Developer Guide.
	//
	// EvaluateTargetHealth is a required field
	EvaluateTargetHealth *bool `type:"boolean" required:"true"`

	// Alias resource records sets only: The value used depends on where you want
	// to route traffic:
	//
	// CloudFront distributionSpecify Z2FDTNDATAQYW2.
	//
	// Alias resource record sets for CloudFront can't be created in a private zone.
	//
	// Elastic Beanstalk environmentSpecify the hosted zone ID for the region that
	// you created the environment in. The environment must have a regionalized
	// subdomain. For a list of regions and the corresponding hosted zone IDs, see
	// AWS Elastic Beanstalk (http://docs.aws.amazon.com/general/latest/gr/rande.html#elasticbeanstalk_region)
	// in the "AWS Regions and Endpoints" chapter of the Amazon Web Services General
	// Reference.
	//
	// ELB load balancerSpecify the value of the hosted zone ID for the load balancer.
	// Use the following methods to get the hosted zone ID:
	//
	// Elastic Load Balancing (http://docs.aws.amazon.com/general/latest/gr/rande.html#elb_region)
	// table in the "AWS Regions and Endpoints" chapter of the Amazon Web Services
	// General Reference: Use the value that corresponds with the region that you
	// created your load balancer in. Note that there are separate columns for Application
	// and Classic Load Balancers and for Network Load Balancers.
	//
	// AWS Management Console: Go to the Amazon EC2 page, choose Load Balancers
	// in the navigation pane, select the load balancer, and get the value of the
	// Hosted zone field on the Description tab.
	//
	// Elastic Load Balancing API: Use DescribeLoadBalancers to get the applicable
	// value. For more information, see the applicable guide:
	//
	// Classic Load Balancers: Use DescribeLoadBalancers (http://docs.aws.amazon.com/elasticloadbalancing/2012-06-01/APIReference/API_DescribeLoadBalancers.html)
	// to get the value of CanonicalHostedZoneNameId.
	//
	// Application and Network Load Balancers: Use DescribeLoadBalancers (http://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_DescribeLoadBalancers.html)
	// to get the value of CanonicalHostedZoneId.
	//
	// AWS CLI: Use describe-load-balancers to get the applicable value. For more
	// information, see the applicable guide:
	//
	// Classic Load Balancers: Use describe-load-balancers (http://docs.aws.amazon.com/cli/latest/reference/elb/describe-load-balancers.html)
	// to get the value of CanonicalHostedZoneNameId.
	//
	// Application and Network Load Balancers: Use describe-load-balancers (http://docs.aws.amazon.com/cli/latest/reference/elbv2/describe-load-balancers.html)
	// to get the value of CanonicalHostedZoneId.
	//
	// An Amazon S3 bucket configured as a static websiteSpecify the hosted zone
	// ID for the region that you created the bucket in. For more information about
	// valid values, see the Amazon Simple Storage Service Website Endpoints (http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region)
	// table in the "AWS Regions and Endpoints" chapter of the Amazon Web Services
	// General Reference.
	//
	// Another Route 53 resource record set in your hosted zoneSpecify the hosted
	// zone ID of your hosted zone. (An alias resource record set can't reference
	// a resource record set in a different hosted zone.)
	//
	// HostedZoneId is a required field
	HostedZoneId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s AliasTarget) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AliasTarget) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AliasTarget) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AliasTarget"}

	if s.DNSName == nil {
		invalidParams.Add(aws.NewErrParamRequired("DNSName"))
	}

	if s.EvaluateTargetHealth == nil {
		invalidParams.Add(aws.NewErrParamRequired("EvaluateTargetHealth"))
	}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AliasTarget) MarshalFields(e protocol.FieldEncoder) error {
	if s.DNSName != nil {
		v := *s.DNSName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DNSName", protocol.StringValue(v), metadata)
	}
	if s.EvaluateTargetHealth != nil {
		v := *s.EvaluateTargetHealth

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EvaluateTargetHealth", protocol.BoolValue(v), metadata)
	}
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the request to associate a
// VPC with a private hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/AssociateVPCWithHostedZoneRequest
type AssociateVPCWithHostedZoneInput struct {
	_ struct{} `locationName:"AssociateVPCWithHostedZoneRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// Optional: A comment about the association request.
	Comment *string `type:"string"`

	// The ID of the private hosted zone that you want to associate an Amazon VPC
	// with.
	//
	// Note that you can't associate a VPC with a hosted zone that doesn't have
	// an existing VPC association.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"uri" locationName:"Id" type:"string" required:"true"`

	// A complex type that contains information about the VPC that you want to associate
	// with a private hosted zone.
	//
	// VPC is a required field
	VPC *VPC `type:"structure" required:"true"`
}

// String returns the string representation
func (s AssociateVPCWithHostedZoneInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AssociateVPCWithHostedZoneInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AssociateVPCWithHostedZoneInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "AssociateVPCWithHostedZoneInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if s.VPC == nil {
		invalidParams.Add(aws.NewErrParamRequired("VPC"))
	}
	if s.VPC != nil {
		if err := s.VPC.Validate(); err != nil {
			invalidParams.AddNested("VPC", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AssociateVPCWithHostedZoneInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "AssociateVPCWithHostedZoneRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.Comment != nil {
			v := *s.Comment

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
		}
		if s.VPC != nil {
			v := s.VPC

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "VPC", v, metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the AssociateVPCWithHostedZone
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/AssociateVPCWithHostedZoneResponse
type AssociateVPCWithHostedZoneOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that describes the changes made to your hosted zone.
	//
	// ChangeInfo is a required field
	ChangeInfo *ChangeInfo `type:"structure" required:"true"`
}

// String returns the string representation
func (s AssociateVPCWithHostedZoneOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AssociateVPCWithHostedZoneOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s AssociateVPCWithHostedZoneOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s AssociateVPCWithHostedZoneOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ChangeInfo != nil {
		v := s.ChangeInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ChangeInfo", v, metadata)
	}
	return nil
}

// The information for each resource record set that you want to change.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/Change
type Change struct {
	_ struct{} `type:"structure"`

	// The action to perform:
	//
	//    * CREATE: Creates a resource record set that has the specified values.
	//
	//    * DELETE: Deletes a existing resource record set.
	//
	// To delete the resource record set that is associated with a traffic policy
	//    instance, use DeleteTrafficPolicyInstance. Amazon Route 53 will delete
	//    the resource record set automatically. If you delete the resource record
	//    set by using ChangeResourceRecordSets, Route 53 doesn't automatically
	//    delete the traffic policy instance, and you'll continue to be charged
	//    for it even though it's no longer in use.
	//
	//    * UPSERT: If a resource record set doesn't already exist, Route 53 creates
	//    it. If a resource record set does exist, Route 53 updates it with the
	//    values in the request.
	//
	// Action is a required field
	Action ChangeAction `type:"string" required:"true" enum:"true"`

	// Information about the resource record set to create, delete, or update.
	//
	// ResourceRecordSet is a required field
	ResourceRecordSet *ResourceRecordSet `type:"structure" required:"true"`
}

// String returns the string representation
func (s Change) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Change) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Change) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "Change"}
	if len(s.Action) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Action"))
	}

	if s.ResourceRecordSet == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceRecordSet"))
	}
	if s.ResourceRecordSet != nil {
		if err := s.ResourceRecordSet.Validate(); err != nil {
			invalidParams.AddNested("ResourceRecordSet", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Change) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Action) > 0 {
		v := s.Action

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Action", v, metadata)
	}
	if s.ResourceRecordSet != nil {
		v := s.ResourceRecordSet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ResourceRecordSet", v, metadata)
	}
	return nil
}

// The information for a change request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ChangeBatch
type ChangeBatch struct {
	_ struct{} `type:"structure"`

	// Information about the changes to make to the record sets.
	//
	// Changes is a required field
	Changes []Change `locationNameList:"Change" min:"1" type:"list" required:"true"`

	// Optional: Any comments you want to include about a change batch request.
	Comment *string `type:"string"`
}

// String returns the string representation
func (s ChangeBatch) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ChangeBatch) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ChangeBatch) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ChangeBatch"}

	if s.Changes == nil {
		invalidParams.Add(aws.NewErrParamRequired("Changes"))
	}
	if s.Changes != nil && len(s.Changes) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Changes", 1))
	}
	if s.Changes != nil {
		for i, v := range s.Changes {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Changes", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ChangeBatch) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Changes) > 0 {
		v := s.Changes

		metadata := protocol.Metadata{ListLocationName: "Change"}
		ls0 := e.List(protocol.BodyTarget, "Changes", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Comment != nil {
		v := *s.Comment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that describes change information about changes made to your
// hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ChangeInfo
type ChangeInfo struct {
	_ struct{} `type:"structure"`

	// A complex type that describes change information about changes made to your
	// hosted zone.
	//
	// This element contains an ID that you use when performing a GetChange action
	// to get detailed information about the change.
	Comment *string `type:"string"`

	// The ID of the request.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`

	// The current state of the request. PENDING indicates that this request has
	// not yet been applied to all Amazon Route 53 DNS servers.
	//
	// Status is a required field
	Status ChangeStatus `type:"string" required:"true" enum:"true"`

	// The date and time that the change request was submitted in ISO 8601 format
	// (https://en.wikipedia.org/wiki/ISO_8601) and Coordinated Universal Time (UTC).
	// For example, the value 2017-03-27T17:48:16.751Z represents March 27, 2017
	// at 17:48:16.751 UTC.
	//
	// SubmittedAt is a required field
	SubmittedAt *time.Time `type:"timestamp" timestampFormat:"iso8601" required:"true"`
}

// String returns the string representation
func (s ChangeInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ChangeInfo) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ChangeInfo) MarshalFields(e protocol.FieldEncoder) error {
	if s.Comment != nil {
		v := *s.Comment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	if s.SubmittedAt != nil {
		v := *s.SubmittedAt

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubmittedAt", protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormat}, metadata)
	}
	return nil
}

// A complex type that contains change information for the resource record set.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ChangeResourceRecordSetsRequest
type ChangeResourceRecordSetsInput struct {
	_ struct{} `locationName:"ChangeResourceRecordSetsRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// A complex type that contains an optional comment and the Changes element.
	//
	// ChangeBatch is a required field
	ChangeBatch *ChangeBatch `type:"structure" required:"true"`

	// The ID of the hosted zone that contains the resource record sets that you
	// want to change.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"uri" locationName:"Id" type:"string" required:"true"`
}

// String returns the string representation
func (s ChangeResourceRecordSetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ChangeResourceRecordSetsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ChangeResourceRecordSetsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ChangeResourceRecordSetsInput"}

	if s.ChangeBatch == nil {
		invalidParams.Add(aws.NewErrParamRequired("ChangeBatch"))
	}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}
	if s.ChangeBatch != nil {
		if err := s.ChangeBatch.Validate(); err != nil {
			invalidParams.AddNested("ChangeBatch", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ChangeResourceRecordSetsInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "ChangeResourceRecordSetsRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.ChangeBatch != nil {
			v := s.ChangeBatch

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "ChangeBatch", v, metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type containing the response for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ChangeResourceRecordSetsResponse
type ChangeResourceRecordSetsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains information about changes made to your hosted
	// zone.
	//
	// This element contains an ID that you use when performing a GetChange action
	// to get detailed information about the change.
	//
	// ChangeInfo is a required field
	ChangeInfo *ChangeInfo `type:"structure" required:"true"`
}

// String returns the string representation
func (s ChangeResourceRecordSetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ChangeResourceRecordSetsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ChangeResourceRecordSetsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ChangeResourceRecordSetsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ChangeInfo != nil {
		v := s.ChangeInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ChangeInfo", v, metadata)
	}
	return nil
}

// A complex type that contains information about the tags that you want to
// add, edit, or delete.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ChangeTagsForResourceRequest
type ChangeTagsForResourceInput struct {
	_ struct{} `locationName:"ChangeTagsForResourceRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// A complex type that contains a list of the tags that you want to add to the
	// specified health check or hosted zone and/or the tags that you want to edit
	// Value for.
	//
	// You can add a maximum of 10 tags to a health check or a hosted zone.
	AddTags []Tag `locationNameList:"Tag" min:"1" type:"list"`

	// A complex type that contains a list of the tags that you want to delete from
	// the specified health check or hosted zone. You can specify up to 10 keys.
	RemoveTagKeys []string `locationNameList:"Key" min:"1" type:"list"`

	// The ID of the resource for which you want to add, change, or delete tags.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" type:"string" required:"true"`

	// The type of the resource.
	//
	//    * The resource type for health checks is healthcheck.
	//
	//    * The resource type for hosted zones is hostedzone.
	//
	// ResourceType is a required field
	ResourceType TagResourceType `location:"uri" locationName:"ResourceType" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s ChangeTagsForResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ChangeTagsForResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ChangeTagsForResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ChangeTagsForResourceInput"}
	if s.AddTags != nil && len(s.AddTags) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("AddTags", 1))
	}
	if s.RemoveTagKeys != nil && len(s.RemoveTagKeys) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RemoveTagKeys", 1))
	}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if len(s.ResourceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResourceType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ChangeTagsForResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "ChangeTagsForResourceRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if len(s.AddTags) > 0 {
			v := s.AddTags

			metadata := protocol.Metadata{ListLocationName: "Tag"}
			ls0 := e.List(protocol.BodyTarget, "AddTags", metadata)
			ls0.Start()
			for _, v1 := range v {
				ls0.ListAddFields(v1)
			}
			ls0.End()

		}
		if len(s.RemoveTagKeys) > 0 {
			v := s.RemoveTagKeys

			metadata := protocol.Metadata{ListLocationName: "Key"}
			ls0 := e.List(protocol.BodyTarget, "RemoveTagKeys", metadata)
			ls0.Start()
			for _, v1 := range v {
				ls0.ListAddValue(protocol.StringValue(v1))
			}
			ls0.End()

		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.StringValue(v), metadata)
	}
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceType", v, metadata)
	}
	return nil
}

// Empty response for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ChangeTagsForResourceResponse
type ChangeTagsForResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s ChangeTagsForResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ChangeTagsForResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ChangeTagsForResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ChangeTagsForResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A complex type that contains information about the CloudWatch alarm that
// Amazon Route 53 is monitoring for this health check.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CloudWatchAlarmConfiguration
type CloudWatchAlarmConfiguration struct {
	_ struct{} `type:"structure"`

	// For the metric that the CloudWatch alarm is associated with, the arithmetic
	// operation that is used for the comparison.
	//
	// ComparisonOperator is a required field
	ComparisonOperator ComparisonOperator `type:"string" required:"true" enum:"true"`

	// For the metric that the CloudWatch alarm is associated with, a complex type
	// that contains information about the dimensions for the metric. For information,
	// see Amazon CloudWatch Namespaces, Dimensions, and Metrics Reference (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html)
	// in the Amazon CloudWatch User Guide.
	Dimensions []Dimension `locationNameList:"Dimension" type:"list"`

	// For the metric that the CloudWatch alarm is associated with, the number of
	// periods that the metric is compared to the threshold.
	//
	// EvaluationPeriods is a required field
	EvaluationPeriods *int64 `min:"1" type:"integer" required:"true"`

	// The name of the CloudWatch metric that the alarm is associated with.
	//
	// MetricName is a required field
	MetricName *string `min:"1" type:"string" required:"true"`

	// The namespace of the metric that the alarm is associated with. For more information,
	// see Amazon CloudWatch Namespaces, Dimensions, and Metrics Reference (http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html)
	// in the Amazon CloudWatch User Guide.
	//
	// Namespace is a required field
	Namespace *string `min:"1" type:"string" required:"true"`

	// For the metric that the CloudWatch alarm is associated with, the duration
	// of one evaluation period in seconds.
	//
	// Period is a required field
	Period *int64 `min:"60" type:"integer" required:"true"`

	// For the metric that the CloudWatch alarm is associated with, the statistic
	// that is applied to the metric.
	//
	// Statistic is a required field
	Statistic Statistic `type:"string" required:"true" enum:"true"`

	// For the metric that the CloudWatch alarm is associated with, the value the
	// metric is compared with.
	//
	// Threshold is a required field
	Threshold *float64 `type:"double" required:"true"`
}

// String returns the string representation
func (s CloudWatchAlarmConfiguration) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CloudWatchAlarmConfiguration) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CloudWatchAlarmConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ComparisonOperator) > 0 {
		v := s.ComparisonOperator

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ComparisonOperator", v, metadata)
	}
	if len(s.Dimensions) > 0 {
		v := s.Dimensions

		metadata := protocol.Metadata{ListLocationName: "Dimension"}
		ls0 := e.List(protocol.BodyTarget, "Dimensions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.EvaluationPeriods != nil {
		v := *s.EvaluationPeriods

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EvaluationPeriods", protocol.Int64Value(v), metadata)
	}
	if s.MetricName != nil {
		v := *s.MetricName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MetricName", protocol.StringValue(v), metadata)
	}
	if s.Namespace != nil {
		v := *s.Namespace

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Namespace", protocol.StringValue(v), metadata)
	}
	if s.Period != nil {
		v := *s.Period

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Period", protocol.Int64Value(v), metadata)
	}
	if len(s.Statistic) > 0 {
		v := s.Statistic

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Statistic", v, metadata)
	}
	if s.Threshold != nil {
		v := *s.Threshold

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Threshold", protocol.Float64Value(v), metadata)
	}
	return nil
}

// A complex type that contains the health check request information.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateHealthCheckRequest
type CreateHealthCheckInput struct {
	_ struct{} `locationName:"CreateHealthCheckRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// A unique string that identifies the request and that allows you to retry
	// a failed CreateHealthCheck request without the risk of creating two identical
	// health checks:
	//
	//    * If you send a CreateHealthCheck request with the same CallerReference
	//    and settings as a previous request, and if the health check doesn't exist,
	//    Amazon Route 53 creates the health check. If the health check does exist,
	//    Route 53 returns the settings for the existing health check.
	//
	//    * If you send a CreateHealthCheck request with the same CallerReference
	//    as a deleted health check, regardless of the settings, Route 53 returns
	//    a HealthCheckAlreadyExists error.
	//
	//    * If you send a CreateHealthCheck request with the same CallerReference
	//    as an existing health check but with different settings, Route 53 returns
	//    a HealthCheckAlreadyExists error.
	//
	//    * If you send a CreateHealthCheck request with a unique CallerReference
	//    but settings identical to an existing health check, Route 53 creates the
	//    health check.
	//
	// CallerReference is a required field
	CallerReference *string `min:"1" type:"string" required:"true"`

	// A complex type that contains settings for a new health check.
	//
	// HealthCheckConfig is a required field
	HealthCheckConfig *HealthCheckConfig `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateHealthCheckInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateHealthCheckInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateHealthCheckInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateHealthCheckInput"}

	if s.CallerReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("CallerReference"))
	}
	if s.CallerReference != nil && len(*s.CallerReference) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CallerReference", 1))
	}

	if s.HealthCheckConfig == nil {
		invalidParams.Add(aws.NewErrParamRequired("HealthCheckConfig"))
	}
	if s.HealthCheckConfig != nil {
		if err := s.HealthCheckConfig.Validate(); err != nil {
			invalidParams.AddNested("HealthCheckConfig", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateHealthCheckInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "CreateHealthCheckRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.CallerReference != nil {
			v := *s.CallerReference

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "CallerReference", protocol.StringValue(v), metadata)
		}
		if s.HealthCheckConfig != nil {
			v := s.HealthCheckConfig

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "HealthCheckConfig", v, metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	return nil
}

// A complex type containing the response information for the new health check.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateHealthCheckResponse
type CreateHealthCheckOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains identifying information about the health check.
	//
	// HealthCheck is a required field
	HealthCheck *HealthCheck `type:"structure" required:"true"`

	// The unique URL representing the new health check.
	//
	// Location is a required field
	Location *string `location:"header" locationName:"Location" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateHealthCheckOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateHealthCheckOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateHealthCheckOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateHealthCheckOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HealthCheck != nil {
		v := s.HealthCheck

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "HealthCheck", v, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the request to create a public
// or private hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateHostedZoneRequest
type CreateHostedZoneInput struct {
	_ struct{} `locationName:"CreateHostedZoneRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// A unique string that identifies the request and that allows failed CreateHostedZone
	// requests to be retried without the risk of executing the operation twice.
	// You must use a unique CallerReference string every time you submit a CreateHostedZone
	// request. CallerReference can be any unique string, for example, a date/time
	// stamp.
	//
	// CallerReference is a required field
	CallerReference *string `min:"1" type:"string" required:"true"`

	// If you want to associate a reusable delegation set with this hosted zone,
	// the ID that Amazon Route 53 assigned to the reusable delegation set when
	// you created it. For more information about reusable delegation sets, see
	// CreateReusableDelegationSet.
	DelegationSetId *string `type:"string"`

	// (Optional) A complex type that contains the following optional values:
	//
	//    * For public and private hosted zones, an optional comment
	//
	//    * For private hosted zones, an optional PrivateZone element
	//
	// If you don't specify a comment or the PrivateZone element, omit HostedZoneConfig
	// and the other elements.
	HostedZoneConfig *HostedZoneConfig `type:"structure"`

	// The name of the domain. Specify a fully qualified domain name, for example,
	// www.example.com. The trailing dot is optional; Amazon Route 53 assumes that
	// the domain name is fully qualified. This means that Route 53 treats www.example.com
	// (without a trailing dot) and www.example.com. (with a trailing dot) as identical.
	//
	// If you're creating a public hosted zone, this is the name you have registered
	// with your DNS registrar. If your domain name is registered with a registrar
	// other than Route 53, change the name servers for your domain to the set of
	// NameServers that CreateHostedZone returns in DelegationSet.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// (Private hosted zones only) A complex type that contains information about
	// the Amazon VPC that you're associating with this hosted zone.
	//
	// You can specify only one Amazon VPC when you create a private hosted zone.
	// To associate additional Amazon VPCs with the hosted zone, use AssociateVPCWithHostedZone
	// after you create a hosted zone.
	VPC *VPC `type:"structure"`
}

// String returns the string representation
func (s CreateHostedZoneInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateHostedZoneInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateHostedZoneInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateHostedZoneInput"}

	if s.CallerReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("CallerReference"))
	}
	if s.CallerReference != nil && len(*s.CallerReference) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CallerReference", 1))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}
	if s.VPC != nil {
		if err := s.VPC.Validate(); err != nil {
			invalidParams.AddNested("VPC", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateHostedZoneInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "CreateHostedZoneRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.CallerReference != nil {
			v := *s.CallerReference

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "CallerReference", protocol.StringValue(v), metadata)
		}
		if s.DelegationSetId != nil {
			v := *s.DelegationSetId

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "DelegationSetId", protocol.StringValue(v), metadata)
		}
		if s.HostedZoneConfig != nil {
			v := s.HostedZoneConfig

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "HostedZoneConfig", v, metadata)
		}
		if s.Name != nil {
			v := *s.Name

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
		}
		if s.VPC != nil {
			v := s.VPC

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "VPC", v, metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	return nil
}

// A complex type containing the response information for the hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateHostedZoneResponse
type CreateHostedZoneOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains information about the CreateHostedZone request.
	//
	// ChangeInfo is a required field
	ChangeInfo *ChangeInfo `type:"structure" required:"true"`

	// A complex type that describes the name servers for this hosted zone.
	//
	// DelegationSet is a required field
	DelegationSet *DelegationSet `type:"structure" required:"true"`

	// A complex type that contains general information about the hosted zone.
	//
	// HostedZone is a required field
	HostedZone *HostedZone `type:"structure" required:"true"`

	// The unique URL representing the new hosted zone.
	//
	// Location is a required field
	Location *string `location:"header" locationName:"Location" type:"string" required:"true"`

	// A complex type that contains information about an Amazon VPC that you associated
	// with this hosted zone.
	VPC *VPC `type:"structure"`
}

// String returns the string representation
func (s CreateHostedZoneOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateHostedZoneOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateHostedZoneOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateHostedZoneOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ChangeInfo != nil {
		v := s.ChangeInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ChangeInfo", v, metadata)
	}
	if s.DelegationSet != nil {
		v := s.DelegationSet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DelegationSet", v, metadata)
	}
	if s.HostedZone != nil {
		v := s.HostedZone

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "HostedZone", v, metadata)
	}
	if s.VPC != nil {
		v := s.VPC

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "VPC", v, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.StringValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateQueryLoggingConfigRequest
type CreateQueryLoggingConfigInput struct {
	_ struct{} `locationName:"CreateQueryLoggingConfigRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// The Amazon Resource Name (ARN) for the log group that you want to Amazon
	// Route 53 to send query logs to. This is the format of the ARN:
	//
	// arn:aws:logs:region:account-id:log-group:log_group_name
	//
	// To get the ARN for a log group, you can use the CloudWatch console, the DescribeLogGroups
	// (http://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogGroups.html)
	// API action, the describe-log-groups (http://docs.aws.amazon.com/cli/latest/reference/logs/describe-log-groups.html)
	// command, or the applicable command in one of the AWS SDKs.
	//
	// CloudWatchLogsLogGroupArn is a required field
	CloudWatchLogsLogGroupArn *string `type:"string" required:"true"`

	// The ID of the hosted zone that you want to log queries for. You can log queries
	// only for public hosted zones.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `type:"string" required:"true"`
}

// String returns the string representation
func (s CreateQueryLoggingConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateQueryLoggingConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateQueryLoggingConfigInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateQueryLoggingConfigInput"}

	if s.CloudWatchLogsLogGroupArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("CloudWatchLogsLogGroupArn"))
	}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateQueryLoggingConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "CreateQueryLoggingConfigRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.CloudWatchLogsLogGroupArn != nil {
			v := *s.CloudWatchLogsLogGroupArn

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "CloudWatchLogsLogGroupArn", protocol.StringValue(v), metadata)
		}
		if s.HostedZoneId != nil {
			v := *s.HostedZoneId

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateQueryLoggingConfigResponse
type CreateQueryLoggingConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The unique URL representing the new query logging configuration.
	//
	// Location is a required field
	Location *string `location:"header" locationName:"Location" type:"string" required:"true"`

	// A complex type that contains the ID for a query logging configuration, the
	// ID of the hosted zone that you want to log queries for, and the ARN for the
	// log group that you want Amazon Route 53 to send query logs to.
	//
	// QueryLoggingConfig is a required field
	QueryLoggingConfig *QueryLoggingConfig `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateQueryLoggingConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateQueryLoggingConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateQueryLoggingConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateQueryLoggingConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.QueryLoggingConfig != nil {
		v := s.QueryLoggingConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "QueryLoggingConfig", v, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.StringValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateReusableDelegationSetRequest
type CreateReusableDelegationSetInput struct {
	_ struct{} `locationName:"CreateReusableDelegationSetRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// A unique string that identifies the request, and that allows you to retry
	// failed CreateReusableDelegationSet requests without the risk of executing
	// the operation twice. You must use a unique CallerReference string every time
	// you submit a CreateReusableDelegationSet request. CallerReference can be
	// any unique string, for example a date/time stamp.
	//
	// CallerReference is a required field
	CallerReference *string `min:"1" type:"string" required:"true"`

	// If you want to mark the delegation set for an existing hosted zone as reusable,
	// the ID for that hosted zone.
	HostedZoneId *string `type:"string"`
}

// String returns the string representation
func (s CreateReusableDelegationSetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateReusableDelegationSetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateReusableDelegationSetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateReusableDelegationSetInput"}

	if s.CallerReference == nil {
		invalidParams.Add(aws.NewErrParamRequired("CallerReference"))
	}
	if s.CallerReference != nil && len(*s.CallerReference) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CallerReference", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateReusableDelegationSetInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "CreateReusableDelegationSetRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.CallerReference != nil {
			v := *s.CallerReference

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "CallerReference", protocol.StringValue(v), metadata)
		}
		if s.HostedZoneId != nil {
			v := *s.HostedZoneId

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateReusableDelegationSetResponse
type CreateReusableDelegationSetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains name server information.
	//
	// DelegationSet is a required field
	DelegationSet *DelegationSet `type:"structure" required:"true"`

	// The unique URL representing the new reusable delegation set.
	//
	// Location is a required field
	Location *string `location:"header" locationName:"Location" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateReusableDelegationSetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateReusableDelegationSetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateReusableDelegationSetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateReusableDelegationSetOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DelegationSet != nil {
		v := s.DelegationSet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DelegationSet", v, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the traffic policy that you
// want to create.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicyRequest
type CreateTrafficPolicyInput struct {
	_ struct{} `locationName:"CreateTrafficPolicyRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// (Optional) Any comments that you want to include about the traffic policy.
	Comment *string `type:"string"`

	// The definition of this traffic policy in JSON format. For more information,
	// see Traffic Policy Document Format (http://docs.aws.amazon.com/Route53/latest/APIReference/api-policies-traffic-policy-document-format.html).
	//
	// Document is a required field
	Document *string `type:"string" required:"true"`

	// The name of the traffic policy.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`
}

// String returns the string representation
func (s CreateTrafficPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTrafficPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTrafficPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTrafficPolicyInput"}

	if s.Document == nil {
		invalidParams.Add(aws.NewErrParamRequired("Document"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTrafficPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "CreateTrafficPolicyRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.Comment != nil {
			v := *s.Comment

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
		}
		if s.Document != nil {
			v := *s.Document

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Document", protocol.StringValue(v), metadata)
		}
		if s.Name != nil {
			v := *s.Name

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	return nil
}

// A complex type that contains information about the resource record sets that
// you want to create based on a specified traffic policy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicyInstanceRequest
type CreateTrafficPolicyInstanceInput struct {
	_ struct{} `locationName:"CreateTrafficPolicyInstanceRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// The ID of the hosted zone that you want Amazon Route 53 to create resource
	// record sets in by using the configuration in a traffic policy.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `type:"string" required:"true"`

	// The domain name (such as example.com) or subdomain name (such as www.example.com)
	// for which Amazon Route 53 responds to DNS queries by using the resource record
	// sets that Route 53 creates for this traffic policy instance.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// (Optional) The TTL that you want Amazon Route 53 to assign to all of the
	// resource record sets that it creates in the specified hosted zone.
	//
	// TTL is a required field
	TTL *int64 `type:"long" required:"true"`

	// The ID of the traffic policy that you want to use to create resource record
	// sets in the specified hosted zone.
	//
	// TrafficPolicyId is a required field
	TrafficPolicyId *string `min:"1" type:"string" required:"true"`

	// The version of the traffic policy that you want to use to create resource
	// record sets in the specified hosted zone.
	//
	// TrafficPolicyVersion is a required field
	TrafficPolicyVersion *int64 `min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s CreateTrafficPolicyInstanceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTrafficPolicyInstanceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTrafficPolicyInstanceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTrafficPolicyInstanceInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.TTL == nil {
		invalidParams.Add(aws.NewErrParamRequired("TTL"))
	}

	if s.TrafficPolicyId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TrafficPolicyId"))
	}
	if s.TrafficPolicyId != nil && len(*s.TrafficPolicyId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TrafficPolicyId", 1))
	}

	if s.TrafficPolicyVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("TrafficPolicyVersion"))
	}
	if s.TrafficPolicyVersion != nil && *s.TrafficPolicyVersion < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("TrafficPolicyVersion", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTrafficPolicyInstanceInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "CreateTrafficPolicyInstanceRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.HostedZoneId != nil {
			v := *s.HostedZoneId

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
		}
		if s.Name != nil {
			v := *s.Name

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
		}
		if s.TTL != nil {
			v := *s.TTL

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "TTL", protocol.Int64Value(v), metadata)
		}
		if s.TrafficPolicyId != nil {
			v := *s.TrafficPolicyId

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "TrafficPolicyId", protocol.StringValue(v), metadata)
		}
		if s.TrafficPolicyVersion != nil {
			v := *s.TrafficPolicyVersion

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "TrafficPolicyVersion", protocol.Int64Value(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	return nil
}

// A complex type that contains the response information for the CreateTrafficPolicyInstance
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicyInstanceResponse
type CreateTrafficPolicyInstanceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A unique URL that represents a new traffic policy instance.
	//
	// Location is a required field
	Location *string `location:"header" locationName:"Location" type:"string" required:"true"`

	// A complex type that contains settings for the new traffic policy instance.
	//
	// TrafficPolicyInstance is a required field
	TrafficPolicyInstance *TrafficPolicyInstance `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateTrafficPolicyInstanceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTrafficPolicyInstanceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTrafficPolicyInstanceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTrafficPolicyInstanceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TrafficPolicyInstance != nil {
		v := s.TrafficPolicyInstance

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TrafficPolicyInstance", v, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the CreateTrafficPolicy
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicyResponse
type CreateTrafficPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A unique URL that represents a new traffic policy.
	//
	// Location is a required field
	Location *string `location:"header" locationName:"Location" type:"string" required:"true"`

	// A complex type that contains settings for the new traffic policy.
	//
	// TrafficPolicy is a required field
	TrafficPolicy *TrafficPolicy `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateTrafficPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTrafficPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTrafficPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTrafficPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TrafficPolicy != nil {
		v := s.TrafficPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TrafficPolicy", v, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the traffic policy that you
// want to create a new version for.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicyVersionRequest
type CreateTrafficPolicyVersionInput struct {
	_ struct{} `locationName:"CreateTrafficPolicyVersionRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// The comment that you specified in the CreateTrafficPolicyVersion request,
	// if any.
	Comment *string `type:"string"`

	// The definition of this version of the traffic policy, in JSON format. You
	// specified the JSON in the CreateTrafficPolicyVersion request. For more information
	// about the JSON format, see CreateTrafficPolicy.
	//
	// Document is a required field
	Document *string `type:"string" required:"true"`

	// The ID of the traffic policy for which you want to create a new version.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateTrafficPolicyVersionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTrafficPolicyVersionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateTrafficPolicyVersionInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateTrafficPolicyVersionInput"}

	if s.Document == nil {
		invalidParams.Add(aws.NewErrParamRequired("Document"))
	}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTrafficPolicyVersionInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "CreateTrafficPolicyVersionRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.Comment != nil {
			v := *s.Comment

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
		}
		if s.Document != nil {
			v := *s.Document

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Document", protocol.StringValue(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the CreateTrafficPolicyVersion
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateTrafficPolicyVersionResponse
type CreateTrafficPolicyVersionOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A unique URL that represents a new traffic policy version.
	//
	// Location is a required field
	Location *string `location:"header" locationName:"Location" type:"string" required:"true"`

	// A complex type that contains settings for the new version of the traffic
	// policy.
	//
	// TrafficPolicy is a required field
	TrafficPolicy *TrafficPolicy `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateTrafficPolicyVersionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateTrafficPolicyVersionOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateTrafficPolicyVersionOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateTrafficPolicyVersionOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TrafficPolicy != nil {
		v := s.TrafficPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TrafficPolicy", v, metadata)
	}
	if s.Location != nil {
		v := *s.Location

		metadata := protocol.Metadata{}
		e.SetValue(protocol.HeaderTarget, "Location", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the request to authorize associating
// a VPC with your private hosted zone. Authorization is only required when
// a private hosted zone and a VPC were created by using different accounts.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateVPCAssociationAuthorizationRequest
type CreateVPCAssociationAuthorizationInput struct {
	_ struct{} `locationName:"CreateVPCAssociationAuthorizationRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// The ID of the private hosted zone that you want to authorize associating
	// a VPC with.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"uri" locationName:"Id" type:"string" required:"true"`

	// A complex type that contains the VPC ID and region for the VPC that you want
	// to authorize associating with your hosted zone.
	//
	// VPC is a required field
	VPC *VPC `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateVPCAssociationAuthorizationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVPCAssociationAuthorizationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateVPCAssociationAuthorizationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "CreateVPCAssociationAuthorizationInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if s.VPC == nil {
		invalidParams.Add(aws.NewErrParamRequired("VPC"))
	}
	if s.VPC != nil {
		if err := s.VPC.Validate(); err != nil {
			invalidParams.AddNested("VPC", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateVPCAssociationAuthorizationInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "CreateVPCAssociationAuthorizationRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.VPC != nil {
			v := s.VPC

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "VPC", v, metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information from a CreateVPCAssociationAuthorization
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/CreateVPCAssociationAuthorizationResponse
type CreateVPCAssociationAuthorizationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the hosted zone that you authorized associating a VPC with.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `type:"string" required:"true"`

	// The VPC that you authorized associating with a hosted zone.
	//
	// VPC is a required field
	VPC *VPC `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateVPCAssociationAuthorizationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateVPCAssociationAuthorizationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s CreateVPCAssociationAuthorizationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s CreateVPCAssociationAuthorizationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
	}
	if s.VPC != nil {
		v := s.VPC

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "VPC", v, metadata)
	}
	return nil
}

// A complex type that lists the name servers in a delegation set, as well as
// the CallerReference and the ID for the delegation set.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DelegationSet
type DelegationSet struct {
	_ struct{} `type:"structure"`

	// The value that you specified for CallerReference when you created the reusable
	// delegation set.
	CallerReference *string `min:"1" type:"string"`

	// The ID that Amazon Route 53 assigns to a reusable delegation set.
	Id *string `type:"string"`

	// A complex type that contains a list of the authoritative name servers for
	// a hosted zone or for a reusable delegation set.
	//
	// NameServers is a required field
	NameServers []string `locationNameList:"NameServer" min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s DelegationSet) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DelegationSet) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DelegationSet) MarshalFields(e protocol.FieldEncoder) error {
	if s.CallerReference != nil {
		v := *s.CallerReference

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CallerReference", protocol.StringValue(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if len(s.NameServers) > 0 {
		v := s.NameServers

		metadata := protocol.Metadata{ListLocationName: "NameServer"}
		ls0 := e.List(protocol.BodyTarget, "NameServers", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	return nil
}

// This action deletes a health check.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteHealthCheckRequest
type DeleteHealthCheckInput struct {
	_ struct{} `type:"structure"`

	// The ID of the health check that you want to delete.
	//
	// HealthCheckId is a required field
	HealthCheckId *string `location:"uri" locationName:"HealthCheckId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteHealthCheckInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteHealthCheckInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteHealthCheckInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteHealthCheckInput"}

	if s.HealthCheckId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HealthCheckId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteHealthCheckInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HealthCheckId != nil {
		v := *s.HealthCheckId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "HealthCheckId", protocol.StringValue(v), metadata)
	}
	return nil
}

// An empty element.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteHealthCheckResponse
type DeleteHealthCheckOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteHealthCheckOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteHealthCheckOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteHealthCheckOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteHealthCheckOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A request to delete a hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteHostedZoneRequest
type DeleteHostedZoneInput struct {
	_ struct{} `type:"structure"`

	// The ID of the hosted zone you want to delete.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteHostedZoneInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteHostedZoneInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteHostedZoneInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteHostedZoneInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteHostedZoneInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response to a DeleteHostedZone request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteHostedZoneResponse
type DeleteHostedZoneOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains the ID, the status, and the date and time of
	// a request to delete a hosted zone.
	//
	// ChangeInfo is a required field
	ChangeInfo *ChangeInfo `type:"structure" required:"true"`
}

// String returns the string representation
func (s DeleteHostedZoneOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteHostedZoneOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteHostedZoneOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteHostedZoneOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ChangeInfo != nil {
		v := s.ChangeInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ChangeInfo", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteQueryLoggingConfigRequest
type DeleteQueryLoggingConfigInput struct {
	_ struct{} `type:"structure"`

	// The ID of the configuration that you want to delete.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteQueryLoggingConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteQueryLoggingConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteQueryLoggingConfigInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteQueryLoggingConfigInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteQueryLoggingConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteQueryLoggingConfigResponse
type DeleteQueryLoggingConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteQueryLoggingConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteQueryLoggingConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteQueryLoggingConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteQueryLoggingConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A request to delete a reusable delegation set.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteReusableDelegationSetRequest
type DeleteReusableDelegationSetInput struct {
	_ struct{} `type:"structure"`

	// The ID of the reusable delegation set that you want to delete.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteReusableDelegationSetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteReusableDelegationSetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteReusableDelegationSetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteReusableDelegationSetInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteReusableDelegationSetInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// An empty element.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteReusableDelegationSetResponse
type DeleteReusableDelegationSetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteReusableDelegationSetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteReusableDelegationSetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteReusableDelegationSetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteReusableDelegationSetOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A request to delete a specified traffic policy version.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteTrafficPolicyRequest
type DeleteTrafficPolicyInput struct {
	_ struct{} `type:"structure"`

	// The ID of the traffic policy that you want to delete.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`

	// The version number of the traffic policy that you want to delete.
	//
	// Version is a required field
	Version *int64 `location:"uri" locationName:"Version" min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s DeleteTrafficPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTrafficPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTrafficPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTrafficPolicyInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && *s.Version < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTrafficPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Version", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A request to delete a specified traffic policy instance.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteTrafficPolicyInstanceRequest
type DeleteTrafficPolicyInstanceInput struct {
	_ struct{} `type:"structure"`

	// The ID of the traffic policy instance that you want to delete.
	//
	// When you delete a traffic policy instance, Amazon Route 53 also deletes all
	// of the resource record sets that were created when you created the traffic
	// policy instance.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteTrafficPolicyInstanceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTrafficPolicyInstanceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteTrafficPolicyInstanceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteTrafficPolicyInstanceInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTrafficPolicyInstanceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// An empty element.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteTrafficPolicyInstanceResponse
type DeleteTrafficPolicyInstanceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteTrafficPolicyInstanceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTrafficPolicyInstanceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTrafficPolicyInstanceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTrafficPolicyInstanceOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// An empty element.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteTrafficPolicyResponse
type DeleteTrafficPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteTrafficPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteTrafficPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteTrafficPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteTrafficPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// A complex type that contains information about the request to remove authorization
// to associate a VPC that was created by one AWS account with a hosted zone
// that was created with a different AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteVPCAssociationAuthorizationRequest
type DeleteVPCAssociationAuthorizationInput struct {
	_ struct{} `locationName:"DeleteVPCAssociationAuthorizationRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// When removing authorization to associate a VPC that was created by one AWS
	// account with a hosted zone that was created with a different AWS account,
	// the ID of the hosted zone.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"uri" locationName:"Id" type:"string" required:"true"`

	// When removing authorization to associate a VPC that was created by one AWS
	// account with a hosted zone that was created with a different AWS account,
	// a complex type that includes the ID and region of the VPC.
	//
	// VPC is a required field
	VPC *VPC `type:"structure" required:"true"`
}

// String returns the string representation
func (s DeleteVPCAssociationAuthorizationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVPCAssociationAuthorizationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteVPCAssociationAuthorizationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DeleteVPCAssociationAuthorizationInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if s.VPC == nil {
		invalidParams.Add(aws.NewErrParamRequired("VPC"))
	}
	if s.VPC != nil {
		if err := s.VPC.Validate(); err != nil {
			invalidParams.AddNested("VPC", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVPCAssociationAuthorizationInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "DeleteVPCAssociationAuthorizationRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.VPC != nil {
			v := s.VPC

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "VPC", v, metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// Empty response for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DeleteVPCAssociationAuthorizationResponse
type DeleteVPCAssociationAuthorizationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response
}

// String returns the string representation
func (s DeleteVPCAssociationAuthorizationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteVPCAssociationAuthorizationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DeleteVPCAssociationAuthorizationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DeleteVPCAssociationAuthorizationOutput) MarshalFields(e protocol.FieldEncoder) error {
	return nil
}

// For the metric that the CloudWatch alarm is associated with, a complex type
// that contains information about one dimension.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/Dimension
type Dimension struct {
	_ struct{} `type:"structure"`

	// For the metric that the CloudWatch alarm is associated with, the name of
	// one dimension.
	//
	// Name is a required field
	Name *string `min:"1" type:"string" required:"true"`

	// For the metric that the CloudWatch alarm is associated with, the value of
	// one dimension.
	//
	// Value is a required field
	Value *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s Dimension) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Dimension) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Dimension) MarshalFields(e protocol.FieldEncoder) error {
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the VPC that you want to disassociate
// from a specified private hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DisassociateVPCFromHostedZoneRequest
type DisassociateVPCFromHostedZoneInput struct {
	_ struct{} `locationName:"DisassociateVPCFromHostedZoneRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// Optional: A comment about the disassociation request.
	Comment *string `type:"string"`

	// The ID of the private hosted zone that you want to disassociate a VPC from.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"uri" locationName:"Id" type:"string" required:"true"`

	// A complex type that contains information about the VPC that you're disassociating
	// from the specified hosted zone.
	//
	// VPC is a required field
	VPC *VPC `type:"structure" required:"true"`
}

// String returns the string representation
func (s DisassociateVPCFromHostedZoneInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DisassociateVPCFromHostedZoneInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DisassociateVPCFromHostedZoneInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "DisassociateVPCFromHostedZoneInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if s.VPC == nil {
		invalidParams.Add(aws.NewErrParamRequired("VPC"))
	}
	if s.VPC != nil {
		if err := s.VPC.Validate(); err != nil {
			invalidParams.AddNested("VPC", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DisassociateVPCFromHostedZoneInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "DisassociateVPCFromHostedZoneRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.Comment != nil {
			v := *s.Comment

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
		}
		if s.VPC != nil {
			v := s.VPC

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "VPC", v, metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the disassociate
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/DisassociateVPCFromHostedZoneResponse
type DisassociateVPCFromHostedZoneOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that describes the changes made to the specified private hosted
	// zone.
	//
	// ChangeInfo is a required field
	ChangeInfo *ChangeInfo `type:"structure" required:"true"`
}

// String returns the string representation
func (s DisassociateVPCFromHostedZoneOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DisassociateVPCFromHostedZoneOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s DisassociateVPCFromHostedZoneOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s DisassociateVPCFromHostedZoneOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ChangeInfo != nil {
		v := s.ChangeInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ChangeInfo", v, metadata)
	}
	return nil
}

// A complex type that contains information about a geographic location.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GeoLocation
type GeoLocation struct {
	_ struct{} `type:"structure"`

	// The two-letter code for the continent.
	//
	// Valid values: AF | AN | AS | EU | OC | NA | SA
	//
	// Constraint: Specifying ContinentCode with either CountryCode or SubdivisionCode
	// returns an InvalidInput error.
	ContinentCode *string `min:"2" type:"string"`

	// The two-letter code for the country.
	CountryCode *string `min:"1" type:"string"`

	// The code for the subdivision. Route 53 currently supports only states in
	// the United States.
	SubdivisionCode *string `min:"1" type:"string"`
}

// String returns the string representation
func (s GeoLocation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GeoLocation) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GeoLocation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GeoLocation"}
	if s.ContinentCode != nil && len(*s.ContinentCode) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("ContinentCode", 2))
	}
	if s.CountryCode != nil && len(*s.CountryCode) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CountryCode", 1))
	}
	if s.SubdivisionCode != nil && len(*s.SubdivisionCode) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SubdivisionCode", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GeoLocation) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContinentCode != nil {
		v := *s.ContinentCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContinentCode", protocol.StringValue(v), metadata)
	}
	if s.CountryCode != nil {
		v := *s.CountryCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CountryCode", protocol.StringValue(v), metadata)
	}
	if s.SubdivisionCode != nil {
		v := *s.SubdivisionCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubdivisionCode", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the codes and full continent, country, and subdivision
// names for the specified geolocation code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GeoLocationDetails
type GeoLocationDetails struct {
	_ struct{} `type:"structure"`

	// The two-letter code for the continent.
	ContinentCode *string `min:"2" type:"string"`

	// The full name of the continent.
	ContinentName *string `min:"1" type:"string"`

	// The two-letter code for the country.
	CountryCode *string `min:"1" type:"string"`

	// The name of the country.
	CountryName *string `min:"1" type:"string"`

	// The code for the subdivision. Route 53 currently supports only states in
	// the United States.
	SubdivisionCode *string `min:"1" type:"string"`

	// The full name of the subdivision. Route 53 currently supports only states
	// in the United States.
	SubdivisionName *string `min:"1" type:"string"`
}

// String returns the string representation
func (s GeoLocationDetails) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GeoLocationDetails) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GeoLocationDetails) MarshalFields(e protocol.FieldEncoder) error {
	if s.ContinentCode != nil {
		v := *s.ContinentCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContinentCode", protocol.StringValue(v), metadata)
	}
	if s.ContinentName != nil {
		v := *s.ContinentName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContinentName", protocol.StringValue(v), metadata)
	}
	if s.CountryCode != nil {
		v := *s.CountryCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CountryCode", protocol.StringValue(v), metadata)
	}
	if s.CountryName != nil {
		v := *s.CountryName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CountryName", protocol.StringValue(v), metadata)
	}
	if s.SubdivisionCode != nil {
		v := *s.SubdivisionCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubdivisionCode", protocol.StringValue(v), metadata)
	}
	if s.SubdivisionName != nil {
		v := *s.SubdivisionName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SubdivisionName", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the request to create a hosted
// zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetAccountLimitRequest
type GetAccountLimitInput struct {
	_ struct{} `type:"structure"`

	// The limit that you want to get. Valid values include the following:
	//
	//    * MAX_HEALTH_CHECKS_BY_OWNER: The maximum number of health checks that
	//    you can create using the current account.
	//
	//    * MAX_HOSTED_ZONES_BY_OWNER: The maximum number of hosted zones that you
	//    can create using the current account.
	//
	//    * MAX_REUSABLE_DELEGATION_SETS_BY_OWNER: The maximum number of reusable
	//    delegation sets that you can create using the current account.
	//
	//    * MAX_TRAFFIC_POLICIES_BY_OWNER: The maximum number of traffic policies
	//    that you can create using the current account.
	//
	//    * MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER: The maximum number of traffic
	//    policy instances that you can create using the current account. (Traffic
	//    policy instances are referred to as traffic flow policy records in the
	//    Amazon Route 53 console.)
	//
	// Type is a required field
	Type AccountLimitType `location:"uri" locationName:"Type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s GetAccountLimitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetAccountLimitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetAccountLimitInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetAccountLimitInput"}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetAccountLimitInput) MarshalFields(e protocol.FieldEncoder) error {

	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Type", v, metadata)
	}
	return nil
}

// A complex type that contains the requested limit.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetAccountLimitResponse
type GetAccountLimitOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current number of entities that you have created of the specified type.
	// For example, if you specified MAX_HEALTH_CHECKS_BY_OWNER for the value of
	// Type in the request, the value of Count is the current number of health checks
	// that you have created using the current account.
	//
	// Count is a required field
	Count *int64 `type:"long" required:"true"`

	// The current setting for the specified limit. For example, if you specified
	// MAX_HEALTH_CHECKS_BY_OWNER for the value of Type in the request, the value
	// of Limit is the maximum number of health checks that you can create using
	// the current account.
	//
	// Limit is a required field
	Limit *AccountLimit `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetAccountLimitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetAccountLimitOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetAccountLimitOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetAccountLimitOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Count != nil {
		v := *s.Count

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Count", protocol.Int64Value(v), metadata)
	}
	if s.Limit != nil {
		v := s.Limit

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Limit", v, metadata)
	}
	return nil
}

// The input for a GetChange request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetChangeRequest
type GetChangeInput struct {
	_ struct{} `type:"structure"`

	// The ID of the change batch request. The value that you specify here is the
	// value that ChangeResourceRecordSets returned in the Id element when you submitted
	// the request.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetChangeInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetChangeInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetChangeInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetChangeInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetChangeInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the ChangeInfo element.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetChangeResponse
type GetChangeOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains information about the specified change batch.
	//
	// ChangeInfo is a required field
	ChangeInfo *ChangeInfo `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetChangeOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetChangeOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetChangeOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetChangeOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ChangeInfo != nil {
		v := s.ChangeInfo

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ChangeInfo", v, metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetCheckerIpRangesRequest
type GetCheckerIpRangesInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetCheckerIpRangesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCheckerIpRangesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetCheckerIpRangesInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetCheckerIpRangesResponse
type GetCheckerIpRangesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// CheckerIpRanges is a required field
	CheckerIpRanges []string `type:"list" required:"true"`
}

// String returns the string representation
func (s GetCheckerIpRangesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCheckerIpRangesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetCheckerIpRangesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetCheckerIpRangesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.CheckerIpRanges) > 0 {
		v := s.CheckerIpRanges

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "CheckerIpRanges", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	return nil
}

// A request for information about whether a specified geographic location is
// supported for Amazon Route 53 geolocation resource record sets.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetGeoLocationRequest
type GetGeoLocationInput struct {
	_ struct{} `type:"structure"`

	// Amazon Route 53 supports the following continent codes:
	//
	//    * AF: Africa
	//
	//    * AN: Antarctica
	//
	//    * AS: Asia
	//
	//    * EU: Europe
	//
	//    * OC: Oceania
	//
	//    * NA: North America
	//
	//    * SA: South America
	ContinentCode *string `location:"querystring" locationName:"continentcode" min:"2" type:"string"`

	// Amazon Route 53 uses the two-letter country codes that are specified in ISO
	// standard 3166-1 alpha-2 (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
	CountryCode *string `location:"querystring" locationName:"countrycode" min:"1" type:"string"`

	// Amazon Route 53 uses the one- to three-letter subdivision codes that are
	// specified in ISO standard 3166-1 alpha-2 (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
	// Route 53 doesn't support subdivision codes for all countries. If you specify
	// subdivisioncode, you must also specify countrycode.
	SubdivisionCode *string `location:"querystring" locationName:"subdivisioncode" min:"1" type:"string"`
}

// String returns the string representation
func (s GetGeoLocationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGeoLocationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetGeoLocationInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetGeoLocationInput"}
	if s.ContinentCode != nil && len(*s.ContinentCode) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("ContinentCode", 2))
	}
	if s.CountryCode != nil && len(*s.CountryCode) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CountryCode", 1))
	}
	if s.SubdivisionCode != nil && len(*s.SubdivisionCode) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SubdivisionCode", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGeoLocationInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ContinentCode != nil {
		v := *s.ContinentCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "continentcode", protocol.StringValue(v), metadata)
	}
	if s.CountryCode != nil {
		v := *s.CountryCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "countrycode", protocol.StringValue(v), metadata)
	}
	if s.SubdivisionCode != nil {
		v := *s.SubdivisionCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "subdivisioncode", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the specified geolocation
// code.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetGeoLocationResponse
type GetGeoLocationOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains the codes and full continent, country, and subdivision
	// names for the specified geolocation code.
	//
	// GeoLocationDetails is a required field
	GeoLocationDetails *GeoLocationDetails `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetGeoLocationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetGeoLocationOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetGeoLocationOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetGeoLocationOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.GeoLocationDetails != nil {
		v := s.GeoLocationDetails

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "GeoLocationDetails", v, metadata)
	}
	return nil
}

// A request for the number of health checks that are associated with the current
// AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckCountRequest
type GetHealthCheckCountInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetHealthCheckCountInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHealthCheckCountInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHealthCheckCountInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// A complex type that contains the response to a GetHealthCheckCount request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckCountResponse
type GetHealthCheckCountOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The number of health checks associated with the current AWS account.
	//
	// HealthCheckCount is a required field
	HealthCheckCount *int64 `type:"long" required:"true"`
}

// String returns the string representation
func (s GetHealthCheckCountOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHealthCheckCountOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetHealthCheckCountOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHealthCheckCountOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HealthCheckCount != nil {
		v := *s.HealthCheckCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HealthCheckCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A request to get information about a specified health check.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckRequest
type GetHealthCheckInput struct {
	_ struct{} `type:"structure"`

	// The identifier that Amazon Route 53 assigned to the health check when you
	// created it. When you add or update a resource record set, you use this value
	// to specify which health check to use. The value can be up to 64 characters
	// long.
	//
	// HealthCheckId is a required field
	HealthCheckId *string `location:"uri" locationName:"HealthCheckId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetHealthCheckInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHealthCheckInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetHealthCheckInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetHealthCheckInput"}

	if s.HealthCheckId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HealthCheckId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHealthCheckInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HealthCheckId != nil {
		v := *s.HealthCheckId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "HealthCheckId", protocol.StringValue(v), metadata)
	}
	return nil
}

// A request for the reason that a health check failed most recently.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckLastFailureReasonRequest
type GetHealthCheckLastFailureReasonInput struct {
	_ struct{} `type:"structure"`

	// The ID for the health check for which you want the last failure reason. When
	// you created the health check, CreateHealthCheck returned the ID in the response,
	// in the HealthCheckId element.
	//
	// If you want to get the last failure reason for a calculated health check,
	// you must use the Amazon Route 53 console or the CloudWatch console. You can't
	// use GetHealthCheckLastFailureReason for a calculated health check.
	//
	// HealthCheckId is a required field
	HealthCheckId *string `location:"uri" locationName:"HealthCheckId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetHealthCheckLastFailureReasonInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHealthCheckLastFailureReasonInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetHealthCheckLastFailureReasonInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetHealthCheckLastFailureReasonInput"}

	if s.HealthCheckId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HealthCheckId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHealthCheckLastFailureReasonInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HealthCheckId != nil {
		v := *s.HealthCheckId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "HealthCheckId", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response to a GetHealthCheckLastFailureReason
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckLastFailureReasonResponse
type GetHealthCheckLastFailureReasonOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list that contains one Observation element for each Amazon Route 53 health
	// checker that is reporting a last failure reason.
	//
	// HealthCheckObservations is a required field
	HealthCheckObservations []HealthCheckObservation `locationNameList:"HealthCheckObservation" type:"list" required:"true"`
}

// String returns the string representation
func (s GetHealthCheckLastFailureReasonOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHealthCheckLastFailureReasonOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetHealthCheckLastFailureReasonOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHealthCheckLastFailureReasonOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.HealthCheckObservations) > 0 {
		v := s.HealthCheckObservations

		metadata := protocol.Metadata{ListLocationName: "HealthCheckObservation"}
		ls0 := e.List(protocol.BodyTarget, "HealthCheckObservations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A complex type that contains the response to a GetHealthCheck request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckResponse
type GetHealthCheckOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains information about one health check that is associated
	// with the current AWS account.
	//
	// HealthCheck is a required field
	HealthCheck *HealthCheck `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetHealthCheckOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHealthCheckOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetHealthCheckOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHealthCheckOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HealthCheck != nil {
		v := s.HealthCheck

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "HealthCheck", v, metadata)
	}
	return nil
}

// A request to get the status for a health check.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckStatusRequest
type GetHealthCheckStatusInput struct {
	_ struct{} `type:"structure"`

	// The ID for the health check that you want the current status for. When you
	// created the health check, CreateHealthCheck returned the ID in the response,
	// in the HealthCheckId element.
	//
	// If you want to check the status of a calculated health check, you must use
	// the Amazon Route 53 console or the CloudWatch console. You can't use GetHealthCheckStatus
	// to get the status of a calculated health check.
	//
	// HealthCheckId is a required field
	HealthCheckId *string `location:"uri" locationName:"HealthCheckId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetHealthCheckStatusInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHealthCheckStatusInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetHealthCheckStatusInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetHealthCheckStatusInput"}

	if s.HealthCheckId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HealthCheckId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHealthCheckStatusInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HealthCheckId != nil {
		v := *s.HealthCheckId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "HealthCheckId", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response to a GetHealthCheck request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHealthCheckStatusResponse
type GetHealthCheckStatusOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list that contains one HealthCheckObservation element for each Amazon Route
	// 53 health checker that is reporting a status about the health check endpoint.
	//
	// HealthCheckObservations is a required field
	HealthCheckObservations []HealthCheckObservation `locationNameList:"HealthCheckObservation" type:"list" required:"true"`
}

// String returns the string representation
func (s GetHealthCheckStatusOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHealthCheckStatusOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetHealthCheckStatusOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHealthCheckStatusOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.HealthCheckObservations) > 0 {
		v := s.HealthCheckObservations

		metadata := protocol.Metadata{ListLocationName: "HealthCheckObservation"}
		ls0 := e.List(protocol.BodyTarget, "HealthCheckObservations", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A request to retrieve a count of all the hosted zones that are associated
// with the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZoneCountRequest
type GetHostedZoneCountInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetHostedZoneCountInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHostedZoneCountInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHostedZoneCountInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// A complex type that contains the response to a GetHostedZoneCount request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZoneCountResponse
type GetHostedZoneCountOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The total number of public and private hosted zones that are associated with
	// the current AWS account.
	//
	// HostedZoneCount is a required field
	HostedZoneCount *int64 `type:"long" required:"true"`
}

// String returns the string representation
func (s GetHostedZoneCountOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHostedZoneCountOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetHostedZoneCountOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHostedZoneCountOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostedZoneCount != nil {
		v := *s.HostedZoneCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A request to get information about a specified hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZoneRequest
type GetHostedZoneInput struct {
	_ struct{} `type:"structure"`

	// The ID of the hosted zone that you want to get information about.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetHostedZoneInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHostedZoneInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetHostedZoneInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetHostedZoneInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHostedZoneInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the request to create a hosted
// zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZoneLimitRequest
type GetHostedZoneLimitInput struct {
	_ struct{} `type:"structure"`

	// The ID of the hosted zone that you want to get a limit for.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"uri" locationName:"Id" type:"string" required:"true"`

	// The limit that you want to get. Valid values include the following:
	//
	//    * MAX_RRSETS_BY_ZONE: The maximum number of records that you can create
	//    in the specified hosted zone.
	//
	//    * MAX_VPCS_ASSOCIATED_BY_ZONE: The maximum number of Amazon VPCs that
	//    you can associate with the specified private hosted zone.
	//
	// Type is a required field
	Type HostedZoneLimitType `location:"uri" locationName:"Type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s GetHostedZoneLimitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHostedZoneLimitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetHostedZoneLimitInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetHostedZoneLimitInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHostedZoneLimitInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Type", v, metadata)
	}
	return nil
}

// A complex type that contains the requested limit.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZoneLimitResponse
type GetHostedZoneLimitOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current number of entities that you have created of the specified type.
	// For example, if you specified MAX_RRSETS_BY_ZONE for the value of Type in
	// the request, the value of Count is the current number of records that you
	// have created in the specified hosted zone.
	//
	// Count is a required field
	Count *int64 `type:"long" required:"true"`

	// The current setting for the specified limit. For example, if you specified
	// MAX_RRSETS_BY_ZONE for the value of Type in the request, the value of Limit
	// is the maximum number of records that you can create in the specified hosted
	// zone.
	//
	// Limit is a required field
	Limit *HostedZoneLimit `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetHostedZoneLimitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHostedZoneLimitOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetHostedZoneLimitOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHostedZoneLimitOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Count != nil {
		v := *s.Count

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Count", protocol.Int64Value(v), metadata)
	}
	if s.Limit != nil {
		v := s.Limit

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Limit", v, metadata)
	}
	return nil
}

// A complex type that contain the response to a GetHostedZone request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetHostedZoneResponse
type GetHostedZoneOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that lists the Amazon Route 53 name servers for the specified
	// hosted zone.
	DelegationSet *DelegationSet `type:"structure"`

	// A complex type that contains general information about the specified hosted
	// zone.
	//
	// HostedZone is a required field
	HostedZone *HostedZone `type:"structure" required:"true"`

	// A complex type that contains information about the VPCs that are associated
	// with the specified hosted zone.
	VPCs []VPC `locationNameList:"VPC" min:"1" type:"list"`
}

// String returns the string representation
func (s GetHostedZoneOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetHostedZoneOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetHostedZoneOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetHostedZoneOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DelegationSet != nil {
		v := s.DelegationSet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DelegationSet", v, metadata)
	}
	if s.HostedZone != nil {
		v := s.HostedZone

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "HostedZone", v, metadata)
	}
	if len(s.VPCs) > 0 {
		v := s.VPCs

		metadata := protocol.Metadata{ListLocationName: "VPC"}
		ls0 := e.List(protocol.BodyTarget, "VPCs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetQueryLoggingConfigRequest
type GetQueryLoggingConfigInput struct {
	_ struct{} `type:"structure"`

	// The ID of the configuration for DNS query logging that you want to get information
	// about.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetQueryLoggingConfigInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetQueryLoggingConfigInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetQueryLoggingConfigInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetQueryLoggingConfigInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetQueryLoggingConfigInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetQueryLoggingConfigResponse
type GetQueryLoggingConfigOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains information about the query logging configuration
	// that you specified in a GetQueryLoggingConfig request.
	//
	// QueryLoggingConfig is a required field
	QueryLoggingConfig *QueryLoggingConfig `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetQueryLoggingConfigOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetQueryLoggingConfigOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetQueryLoggingConfigOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetQueryLoggingConfigOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.QueryLoggingConfig != nil {
		v := s.QueryLoggingConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "QueryLoggingConfig", v, metadata)
	}
	return nil
}

// A request to get information about a specified reusable delegation set.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetReusableDelegationSetRequest
type GetReusableDelegationSetInput struct {
	_ struct{} `type:"structure"`

	// The ID of the reusable delegation set that you want to get a list of name
	// servers for.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" type:"string" required:"true"`
}

// String returns the string representation
func (s GetReusableDelegationSetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetReusableDelegationSetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetReusableDelegationSetInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetReusableDelegationSetInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetReusableDelegationSetInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the request to create a hosted
// zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetReusableDelegationSetLimitRequest
type GetReusableDelegationSetLimitInput struct {
	_ struct{} `type:"structure"`

	// The ID of the delegation set that you want to get the limit for.
	//
	// DelegationSetId is a required field
	DelegationSetId *string `location:"uri" locationName:"Id" type:"string" required:"true"`

	// Specify MAX_ZONES_BY_REUSABLE_DELEGATION_SET to get the maximum number of
	// hosted zones that you can associate with the specified reusable delegation
	// set.
	//
	// Type is a required field
	Type ReusableDelegationSetLimitType `location:"uri" locationName:"Type" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s GetReusableDelegationSetLimitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetReusableDelegationSetLimitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetReusableDelegationSetLimitInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetReusableDelegationSetLimitInput"}

	if s.DelegationSetId == nil {
		invalidParams.Add(aws.NewErrParamRequired("DelegationSetId"))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetReusableDelegationSetLimitInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DelegationSetId != nil {
		v := *s.DelegationSetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Type", v, metadata)
	}
	return nil
}

// A complex type that contains the requested limit.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetReusableDelegationSetLimitResponse
type GetReusableDelegationSetLimitOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The current number of hosted zones that you can associate with the specified
	// reusable delegation set.
	//
	// Count is a required field
	Count *int64 `type:"long" required:"true"`

	// The current setting for the limit on hosted zones that you can associate
	// with the specified reusable delegation set.
	//
	// Limit is a required field
	Limit *ReusableDelegationSetLimit `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetReusableDelegationSetLimitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetReusableDelegationSetLimitOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetReusableDelegationSetLimitOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetReusableDelegationSetLimitOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Count != nil {
		v := *s.Count

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Count", protocol.Int64Value(v), metadata)
	}
	if s.Limit != nil {
		v := s.Limit

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Limit", v, metadata)
	}
	return nil
}

// A complex type that contains the response to the GetReusableDelegationSet
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetReusableDelegationSetResponse
type GetReusableDelegationSetOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains information about the reusable delegation set.
	//
	// DelegationSet is a required field
	DelegationSet *DelegationSet `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetReusableDelegationSetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetReusableDelegationSetOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetReusableDelegationSetOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetReusableDelegationSetOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DelegationSet != nil {
		v := s.DelegationSet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "DelegationSet", v, metadata)
	}
	return nil
}

// Gets information about a specific traffic policy version.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicyRequest
type GetTrafficPolicyInput struct {
	_ struct{} `type:"structure"`

	// The ID of the traffic policy that you want to get information about.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`

	// The version number of the traffic policy that you want to get information
	// about.
	//
	// Version is a required field
	Version *int64 `location:"uri" locationName:"Version" min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s GetTrafficPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTrafficPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTrafficPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTrafficPolicyInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && *s.Version < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTrafficPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Version", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Request to get the number of traffic policy instances that are associated
// with the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicyInstanceCountRequest
type GetTrafficPolicyInstanceCountInput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s GetTrafficPolicyInstanceCountInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTrafficPolicyInstanceCountInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTrafficPolicyInstanceCountInput) MarshalFields(e protocol.FieldEncoder) error {

	return nil
}

// A complex type that contains information about the resource record sets that
// Amazon Route 53 created based on a specified traffic policy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicyInstanceCountResponse
type GetTrafficPolicyInstanceCountOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The number of traffic policy instances that are associated with the current
	// AWS account.
	//
	// TrafficPolicyInstanceCount is a required field
	TrafficPolicyInstanceCount *int64 `type:"integer" required:"true"`
}

// String returns the string representation
func (s GetTrafficPolicyInstanceCountOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTrafficPolicyInstanceCountOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTrafficPolicyInstanceCountOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTrafficPolicyInstanceCountOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TrafficPolicyInstanceCount != nil {
		v := *s.TrafficPolicyInstanceCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyInstanceCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// Gets information about a specified traffic policy instance.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicyInstanceRequest
type GetTrafficPolicyInstanceInput struct {
	_ struct{} `type:"structure"`

	// The ID of the traffic policy instance that you want to get information about.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetTrafficPolicyInstanceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTrafficPolicyInstanceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetTrafficPolicyInstanceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "GetTrafficPolicyInstanceInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTrafficPolicyInstanceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the resource record sets that
// Amazon Route 53 created based on a specified traffic policy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicyInstanceResponse
type GetTrafficPolicyInstanceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains settings for the traffic policy instance.
	//
	// TrafficPolicyInstance is a required field
	TrafficPolicyInstance *TrafficPolicyInstance `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetTrafficPolicyInstanceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTrafficPolicyInstanceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTrafficPolicyInstanceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTrafficPolicyInstanceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TrafficPolicyInstance != nil {
		v := s.TrafficPolicyInstance

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TrafficPolicyInstance", v, metadata)
	}
	return nil
}

// A complex type that contains the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/GetTrafficPolicyResponse
type GetTrafficPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains settings for the specified traffic policy.
	//
	// TrafficPolicy is a required field
	TrafficPolicy *TrafficPolicy `type:"structure" required:"true"`
}

// String returns the string representation
func (s GetTrafficPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetTrafficPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s GetTrafficPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s GetTrafficPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TrafficPolicy != nil {
		v := s.TrafficPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TrafficPolicy", v, metadata)
	}
	return nil
}

// A complex type that contains information about one health check that is associated
// with the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/HealthCheck
type HealthCheck struct {
	_ struct{} `type:"structure"`

	// A unique string that you specified when you created the health check.
	//
	// CallerReference is a required field
	CallerReference *string `min:"1" type:"string" required:"true"`

	// A complex type that contains information about the CloudWatch alarm that
	// Amazon Route 53 is monitoring for this health check.
	CloudWatchAlarmConfiguration *CloudWatchAlarmConfiguration `type:"structure"`

	// A complex type that contains detailed information about one health check.
	//
	// HealthCheckConfig is a required field
	HealthCheckConfig *HealthCheckConfig `type:"structure" required:"true"`

	// The version of the health check. You can optionally pass this value in a
	// call to UpdateHealthCheck to prevent overwriting another change to the health
	// check.
	//
	// HealthCheckVersion is a required field
	HealthCheckVersion *int64 `min:"1" type:"long" required:"true"`

	// The identifier that Amazon Route 53assigned to the health check when you
	// created it. When you add or update a resource record set, you use this value
	// to specify which health check to use. The value can be up to 64 characters
	// long.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`

	// If the health check was created by another service, the service that created
	// the health check. When a health check is created by another service, you
	// can't edit or delete it using Amazon Route 53.
	LinkedService *LinkedService `type:"structure"`
}

// String returns the string representation
func (s HealthCheck) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HealthCheck) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HealthCheck) MarshalFields(e protocol.FieldEncoder) error {
	if s.CallerReference != nil {
		v := *s.CallerReference

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CallerReference", protocol.StringValue(v), metadata)
	}
	if s.CloudWatchAlarmConfiguration != nil {
		v := s.CloudWatchAlarmConfiguration

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "CloudWatchAlarmConfiguration", v, metadata)
	}
	if s.HealthCheckConfig != nil {
		v := s.HealthCheckConfig

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "HealthCheckConfig", v, metadata)
	}
	if s.HealthCheckVersion != nil {
		v := *s.HealthCheckVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HealthCheckVersion", protocol.Int64Value(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.LinkedService != nil {
		v := s.LinkedService

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LinkedService", v, metadata)
	}
	return nil
}

// A complex type that contains information about the health check.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/HealthCheckConfig
type HealthCheckConfig struct {
	_ struct{} `type:"structure"`

	// A complex type that identifies the CloudWatch alarm that you want Amazon
	// Route 53 health checkers to use to determine whether the specified health
	// check is healthy.
	AlarmIdentifier *AlarmIdentifier `type:"structure"`

	// (CALCULATED Health Checks Only) A complex type that contains one ChildHealthCheck
	// element for each health check that you want to associate with a CALCULATED
	// health check.
	ChildHealthChecks []string `locationNameList:"ChildHealthCheck" type:"list"`

	// Stops Route 53 from performing health checks. When you disable a health check,
	// here's what happens:
	//
	//    * Health checks that check the health of endpoints: Route 53 stops submitting
	//    requests to your application, server, or other resource.
	//
	//    * Calculated health checks: Route 53 stops aggregating the status of the
	//    referenced health checks.
	//
	//    * Health checks that monitor CloudWatch alarms: Route 53 stops monitoring
	//    the corresponding CloudWatch metrics.
	//
	// After you disable a health check, Route 53 considers the status of the health
	// check to always be healthy. If you configured DNS failover, Route 53 continues
	// to route traffic to the corresponding resources. If you want to stop routing
	// traffic to a resource, change the value of UpdateHealthCheckRequest$Inverted.
	//
	// Charges for a health check still apply when the health check is disabled.
	// For more information, see Amazon Route 53 Pricing (http://aws.amazon.com/route53/pricing/).
	Disabled *bool `type:"boolean"`

	// Specify whether you want Amazon Route 53 to send the value of FullyQualifiedDomainName
	// to the endpoint in the client_hello message during TLS negotiation. This
	// allows the endpoint to respond to HTTPS health check requests with the applicable
	// SSL/TLS certificate.
	//
	// Some endpoints require that HTTPS requests include the host name in the client_hello
	// message. If you don't enable SNI, the status of the health check will be
	// SSL alert handshake_failure. A health check can also have that status for
	// other reasons. If SNI is enabled and you're still getting the error, check
	// the SSL/TLS configuration on your endpoint and confirm that your certificate
	// is valid.
	//
	// The SSL/TLS certificate on your endpoint includes a domain name in the Common
	// Name field and possibly several more in the Subject Alternative Names field.
	// One of the domain names in the certificate should match the value that you
	// specify for FullyQualifiedDomainName. If the endpoint responds to the client_hello
	// message with a certificate that does not include the domain name that you
	// specified in FullyQualifiedDomainName, a health checker will retry the handshake.
	// In the second attempt, the health checker will omit FullyQualifiedDomainName
	// from the client_hello message.
	EnableSNI *bool `type:"boolean"`

	// The number of consecutive health checks that an endpoint must pass or fail
	// for Amazon Route 53 to change the current status of the endpoint from unhealthy
	// to healthy or vice versa. For more information, see How Amazon Route 53 Determines
	// Whether an Endpoint Is Healthy (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html)
	// in the Amazon Route 53 Developer Guide.
	//
	// If you don't specify a value for FailureThreshold, the default value is three
	// health checks.
	FailureThreshold *int64 `min:"1" type:"integer"`

	// Amazon Route 53 behavior depends on whether you specify a value for IPAddress.
	//
	// If you specify a value forIPAddress:
	//
	// Amazon Route 53 sends health check requests to the specified IPv4 or IPv6
	// address and passes the value of FullyQualifiedDomainName in the Host header
	// for all health checks except TCP health checks. This is typically the fully
	// qualified DNS name of the endpoint on which you want Route 53 to perform
	// health checks.
	//
	// When Route 53 checks the health of an endpoint, here is how it constructs
	// the Host header:
	//
	//    * If you specify a value of 80 for Port and HTTP or HTTP_STR_MATCH for
	//    Type, Route 53 passes the value of FullyQualifiedDomainName to the endpoint
	//    in the Host header.
	//
	//    * If you specify a value of 443 for Port and HTTPS or HTTPS_STR_MATCH
	//    for Type, Route 53 passes the value of FullyQualifiedDomainName to the
	//    endpoint in the Host header.
	//
	//    * If you specify another value for Port and any value except TCP for Type,
	//    Route 53 passes FullyQualifiedDomainName:Port to the endpoint in the Host
	//    header.
	//
	// If you don't specify a value for FullyQualifiedDomainName, Route 53 substitutes
	// the value of IPAddress in the Host header in each of the preceding cases.
	//
	// If you don't specify a value for IPAddress:
	//
	// Route 53 sends a DNS request to the domain that you specify for FullyQualifiedDomainName
	// at the interval that you specify for RequestInterval. Using an IPv4 address
	// that DNS returns, Route 53 then checks the health of the endpoint.
	//
	// If you don't specify a value for IPAddress, Route 53 uses only IPv4 to send
	// health checks to the endpoint. If there's no resource record set with a type
	// of A for the name that you specify for FullyQualifiedDomainName, the health
	// check fails with a "DNS resolution failed" error.
	//
	// If you want to check the health of weighted, latency, or failover resource
	// record sets and you choose to specify the endpoint only by FullyQualifiedDomainName,
	// we recommend that you create a separate health check for each endpoint. For
	// example, create a health check for each HTTP server that is serving content
	// for www.example.com. For the value of FullyQualifiedDomainName, specify the
	// domain name of the server (such as us-east-2-www.example.com), not the name
	// of the resource record sets (www.example.com).
	//
	// In this configuration, if you create a health check for which the value of
	// FullyQualifiedDomainName matches the name of the resource record sets and
	// you then associate the health check with those resource record sets, health
	// check results will be unpredictable.
	//
	// In addition, if the value that you specify for Type is HTTP, HTTPS, HTTP_STR_MATCH,
	// or HTTPS_STR_MATCH, Route 53 passes the value of FullyQualifiedDomainName
	// in the Host header, as it does when you specify a value for IPAddress. If
	// the value of Type is TCP, Route 53 doesn't pass a Host header.
	FullyQualifiedDomainName *string `type:"string"`

	// The number of child health checks that are associated with a CALCULATED health
	// that Amazon Route 53 must consider healthy for the CALCULATED health check
	// to be considered healthy. To specify the child health checks that you want
	// to associate with a CALCULATED health check, use the HealthCheckConfig$ChildHealthChecks
	// and HealthCheckConfig$ChildHealthChecks elements.
	//
	// Note the following:
	//
	//    * If you specify a number greater than the number of child health checks,
	//    Route 53 always considers this health check to be unhealthy.
	//
	//    * If you specify 0, Route 53 always considers this health check to be
	//    healthy.
	HealthThreshold *int64 `type:"integer"`

	// The IPv4 or IPv6 IP address of the endpoint that you want Amazon Route 53
	// to perform health checks on. If you don't specify a value for IPAddress,
	// Route 53 sends a DNS request to resolve the domain name that you specify
	// in FullyQualifiedDomainName at the interval that you specify in RequestInterval.
	// Using an IP address returned by DNS, Route 53 then checks the health of the
	// endpoint.
	//
	// Use one of the following formats for the value of IPAddress:
	//
	//    * IPv4 address: four values between 0 and 255, separated by periods (.),
	//    for example, 192.0.2.44.
	//
	//    * IPv6 address: eight groups of four hexadecimal values, separated by
	//    colons (:), for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345. You
	//    can also shorten IPv6 addresses as described in RFC 5952, for example,
	//    2001:db8:85a3::abcd:1:2345.
	//
	// If the endpoint is an EC2 instance, we recommend that you create an Elastic
	// IP address, associate it with your EC2 instance, and specify the Elastic
	// IP address for IPAddress. This ensures that the IP address of your instance
	// will never change.
	//
	// For more information, see HealthCheckConfig$FullyQualifiedDomainName.
	//
	// Constraints: Route 53 can't check the health of endpoints for which the IP
	// address is in local, private, non-routable, or multicast ranges. For more
	// information about IP addresses for which you can't create health checks,
	// see the following documents:
	//
	//    * RFC 5735, Special Use IPv4 Addresses (https://tools.ietf.org/html/rfc5735)
	//
	//    * RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space (https://tools.ietf.org/html/rfc6598)
	//
	//    * RFC 5156, Special-Use IPv6 Addresses (https://tools.ietf.org/html/rfc5156)
	//
	// When the value of Type is CALCULATED or CLOUDWATCH_METRIC, omit IPAddress.
	IPAddress *string `type:"string"`

	// When CloudWatch has insufficient data about the metric to determine the alarm
	// state, the status that you want Amazon Route 53 to assign to the health check:
	//
	//    * Healthy: Route 53 considers the health check to be healthy.
	//
	//    * Unhealthy: Route 53 considers the health check to be unhealthy.
	//
	//    * LastKnownStatus: Route 53 uses the status of the health check from the
	//    last time that CloudWatch had sufficient data to determine the alarm state.
	//    For new health checks that have no last known status, the default status
	//    for the health check is healthy.
	InsufficientDataHealthStatus InsufficientDataHealthStatus `type:"string" enum:"true"`

	// Specify whether you want Amazon Route 53 to invert the status of a health
	// check, for example, to consider a health check unhealthy when it otherwise
	// would be considered healthy.
	Inverted *bool `type:"boolean"`

	// Specify whether you want Amazon Route 53 to measure the latency between health
	// checkers in multiple AWS regions and your endpoint, and to display CloudWatch
	// latency graphs on the Health Checks page in the Route 53 console.
	//
	// You can't change the value of MeasureLatency after you create a health check.
	MeasureLatency *bool `type:"boolean"`

	// The port on the endpoint on which you want Amazon Route 53 to perform health
	// checks. Specify a value for Port only when you specify a value for IPAddress.
	Port *int64 `min:"1" type:"integer"`

	// A complex type that contains one Region element for each region from which
	// you want Amazon Route 53 health checkers to check the specified endpoint.
	//
	// If you don't specify any regions, Route 53 health checkers automatically
	// performs checks from all of the regions that are listed under Valid Values.
	//
	// If you update a health check to remove a region that has been performing
	// health checks, Route 53 will briefly continue to perform checks from that
	// region to ensure that some health checkers are always checking the endpoint
	// (for example, if you replace three regions with four different regions).
	Regions []HealthCheckRegion `locationNameList:"Region" min:"3" type:"list"`

	// The number of seconds between the time that Amazon Route 53 gets a response
	// from your endpoint and the time that it sends the next health check request.
	// Each Route 53 health checker makes requests at this interval.
	//
	// You can't change the value of RequestInterval after you create a health check.
	//
	// If you don't specify a value for RequestInterval, the default value is 30
	// seconds.
	RequestInterval *int64 `min:"10" type:"integer"`

	// The path, if any, that you want Amazon Route 53 to request when performing
	// health checks. The path can be any value for which your endpoint will return
	// an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example,
	// the file /docs/route53-health-check.html. You can also include query string
	// parameters, for example, /welcome.html?language=jp&login=y.
	ResourcePath *string `type:"string"`

	// If the value of Type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that
	// you want Amazon Route 53 to search for in the response body from the specified
	// resource. If the string appears in the response body, Route 53 considers
	// the resource healthy.
	//
	// Route 53 considers case when searching for SearchString in the response body.
	SearchString *string `type:"string"`

	// The type of health check that you want to create, which indicates how Amazon
	// Route 53 determines whether an endpoint is healthy.
	//
	// You can't change the value of Type after you create a health check.
	//
	// You can create the following types of health checks:
	//
	//    * HTTP: Route 53 tries to establish a TCP connection. If successful, Route
	//    53 submits an HTTP request and waits for an HTTP status code of 200 or
	//    greater and less than 400.
	//
	//    * HTTPS: Route 53 tries to establish a TCP connection. If successful,
	//    Route 53 submits an HTTPS request and waits for an HTTP status code of
	//    200 or greater and less than 400.
	//
	// If you specify HTTPS for the value of Type, the endpoint must support TLS
	//    v1.0 or later.
	//
	//    * HTTP_STR_MATCH: Route 53 tries to establish a TCP connection. If successful,
	//    Route 53 submits an HTTP request and searches the first 5,120 bytes of
	//    the response body for the string that you specify in SearchString.
	//
	//    * HTTPS_STR_MATCH: Route 53 tries to establish a TCP connection. If successful,
	//    Route 53 submits an HTTPS request and searches the first 5,120 bytes of
	//    the response body for the string that you specify in SearchString.
	//
	//    * TCP: Route 53 tries to establish a TCP connection.
	//
	//    * CLOUDWATCH_METRIC: The health check is associated with a CloudWatch
	//    alarm. If the state of the alarm is OK, the health check is considered
	//    healthy. If the state is ALARM, the health check is considered unhealthy.
	//    If CloudWatch doesn't have sufficient data to determine whether the state
	//    is OK or ALARM, the health check status depends on the setting for InsufficientDataHealthStatus:
	//    Healthy, Unhealthy, or LastKnownStatus.
	//
	//    * CALCULATED: For health checks that monitor the status of other health
	//    checks, Route 53 adds up the number of health checks that Route 53 health
	//    checkers consider to be healthy and compares that number with the value
	//    of HealthThreshold.
	//
	// For more information, see How Route 53 Determines Whether an Endpoint Is
	// Healthy (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html)
	// in the Amazon Route 53 Developer Guide.
	//
	// Type is a required field
	Type HealthCheckType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s HealthCheckConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HealthCheckConfig) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *HealthCheckConfig) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "HealthCheckConfig"}
	if s.FailureThreshold != nil && *s.FailureThreshold < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("FailureThreshold", 1))
	}
	if s.Port != nil && *s.Port < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Port", 1))
	}
	if s.Regions != nil && len(s.Regions) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("Regions", 3))
	}
	if s.RequestInterval != nil && *s.RequestInterval < 10 {
		invalidParams.Add(aws.NewErrParamMinValue("RequestInterval", 10))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}
	if s.AlarmIdentifier != nil {
		if err := s.AlarmIdentifier.Validate(); err != nil {
			invalidParams.AddNested("AlarmIdentifier", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HealthCheckConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.AlarmIdentifier != nil {
		v := s.AlarmIdentifier

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AlarmIdentifier", v, metadata)
	}
	if len(s.ChildHealthChecks) > 0 {
		v := s.ChildHealthChecks

		metadata := protocol.Metadata{ListLocationName: "ChildHealthCheck"}
		ls0 := e.List(protocol.BodyTarget, "ChildHealthChecks", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.Disabled != nil {
		v := *s.Disabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Disabled", protocol.BoolValue(v), metadata)
	}
	if s.EnableSNI != nil {
		v := *s.EnableSNI

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "EnableSNI", protocol.BoolValue(v), metadata)
	}
	if s.FailureThreshold != nil {
		v := *s.FailureThreshold

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FailureThreshold", protocol.Int64Value(v), metadata)
	}
	if s.FullyQualifiedDomainName != nil {
		v := *s.FullyQualifiedDomainName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FullyQualifiedDomainName", protocol.StringValue(v), metadata)
	}
	if s.HealthThreshold != nil {
		v := *s.HealthThreshold

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HealthThreshold", protocol.Int64Value(v), metadata)
	}
	if s.IPAddress != nil {
		v := *s.IPAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IPAddress", protocol.StringValue(v), metadata)
	}
	if len(s.InsufficientDataHealthStatus) > 0 {
		v := s.InsufficientDataHealthStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "InsufficientDataHealthStatus", v, metadata)
	}
	if s.Inverted != nil {
		v := *s.Inverted

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Inverted", protocol.BoolValue(v), metadata)
	}
	if s.MeasureLatency != nil {
		v := *s.MeasureLatency

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MeasureLatency", protocol.BoolValue(v), metadata)
	}
	if s.Port != nil {
		v := *s.Port

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Port", protocol.Int64Value(v), metadata)
	}
	if len(s.Regions) > 0 {
		v := s.Regions

		metadata := protocol.Metadata{ListLocationName: "Region"}
		ls0 := e.List(protocol.BodyTarget, "Regions", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.RequestInterval != nil {
		v := *s.RequestInterval

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RequestInterval", protocol.Int64Value(v), metadata)
	}
	if s.ResourcePath != nil {
		v := *s.ResourcePath

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourcePath", protocol.StringValue(v), metadata)
	}
	if s.SearchString != nil {
		v := *s.SearchString

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SearchString", protocol.StringValue(v), metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	return nil
}

// A complex type that contains the last failure reason as reported by one Amazon
// Route 53 health checker.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/HealthCheckObservation
type HealthCheckObservation struct {
	_ struct{} `type:"structure"`

	// The IP address of the Amazon Route 53 health checker that provided the failure
	// reason in StatusReport.
	IPAddress *string `type:"string"`

	// The region of the Amazon Route 53 health checker that provided the status
	// in StatusReport.
	Region HealthCheckRegion `min:"1" type:"string" enum:"true"`

	// A complex type that contains the last failure reason as reported by one Amazon
	// Route 53 health checker and the time of the failed health check.
	StatusReport *StatusReport `type:"structure"`
}

// String returns the string representation
func (s HealthCheckObservation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HealthCheckObservation) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HealthCheckObservation) MarshalFields(e protocol.FieldEncoder) error {
	if s.IPAddress != nil {
		v := *s.IPAddress

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IPAddress", protocol.StringValue(v), metadata)
	}
	if len(s.Region) > 0 {
		v := s.Region

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Region", v, metadata)
	}
	if s.StatusReport != nil {
		v := s.StatusReport

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "StatusReport", v, metadata)
	}
	return nil
}

// A complex type that contains general information about the hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/HostedZone
type HostedZone struct {
	_ struct{} `type:"structure"`

	// The value that you specified for CallerReference when you created the hosted
	// zone.
	//
	// CallerReference is a required field
	CallerReference *string `min:"1" type:"string" required:"true"`

	// A complex type that includes the Comment and PrivateZone elements. If you
	// omitted the HostedZoneConfig and Comment elements from the request, the Config
	// and Comment elements don't appear in the response.
	Config *HostedZoneConfig `type:"structure"`

	// The ID that Amazon Route 53 assigned to the hosted zone when you created
	// it.
	//
	// Id is a required field
	Id *string `type:"string" required:"true"`

	// If the hosted zone was created by another service, the service that created
	// the hosted zone. When a hosted zone is created by another service, you can't
	// edit or delete it using Route 53.
	LinkedService *LinkedService `type:"structure"`

	// The name of the domain. For public hosted zones, this is the name that you
	// have registered with your DNS registrar.
	//
	// For information about how to specify characters other than a-z, 0-9, and
	// - (hyphen) and how to specify internationalized domain names, see CreateHostedZone.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The number of resource record sets in the hosted zone.
	ResourceRecordSetCount *int64 `type:"long"`
}

// String returns the string representation
func (s HostedZone) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HostedZone) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HostedZone) MarshalFields(e protocol.FieldEncoder) error {
	if s.CallerReference != nil {
		v := *s.CallerReference

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CallerReference", protocol.StringValue(v), metadata)
	}
	if s.Config != nil {
		v := s.Config

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Config", v, metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.LinkedService != nil {
		v := s.LinkedService

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LinkedService", v, metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	if s.ResourceRecordSetCount != nil {
		v := *s.ResourceRecordSetCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceRecordSetCount", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A complex type that contains an optional comment about your hosted zone.
// If you don't want to specify a comment, omit both the HostedZoneConfig and
// Comment elements.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/HostedZoneConfig
type HostedZoneConfig struct {
	_ struct{} `type:"structure"`

	// Any comments that you want to include about the hosted zone.
	Comment *string `type:"string"`

	// A value that indicates whether this is a private hosted zone.
	PrivateZone *bool `type:"boolean"`
}

// String returns the string representation
func (s HostedZoneConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HostedZoneConfig) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HostedZoneConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.Comment != nil {
		v := *s.Comment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
	}
	if s.PrivateZone != nil {
		v := *s.PrivateZone

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "PrivateZone", protocol.BoolValue(v), metadata)
	}
	return nil
}

// A complex type that contains the type of limit that you specified in the
// request and the current value for that limit.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/HostedZoneLimit
type HostedZoneLimit struct {
	_ struct{} `type:"structure"`

	// The limit that you requested. Valid values include the following:
	//
	//    * MAX_RRSETS_BY_ZONE: The maximum number of records that you can create
	//    in the specified hosted zone.
	//
	//    * MAX_VPCS_ASSOCIATED_BY_ZONE: The maximum number of Amazon VPCs that
	//    you can associate with the specified private hosted zone.
	//
	// Type is a required field
	Type HostedZoneLimitType `type:"string" required:"true" enum:"true"`

	// The current value for the limit that is specified by Type.
	//
	// Value is a required field
	Value *int64 `min:"1" type:"long" required:"true"`
}

// String returns the string representation
func (s HostedZoneLimit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s HostedZoneLimit) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s HostedZoneLimit) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.Int64Value(v), metadata)
	}
	return nil
}

// If a health check or hosted zone was created by another service, LinkedService
// is a complex type that describes the service that created the resource. When
// a resource is created by another service, you can't edit or delete it using
// Amazon Route 53.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/LinkedService
type LinkedService struct {
	_ struct{} `type:"structure"`

	// If the health check or hosted zone was created by another service, an optional
	// description that can be provided by the other service. When a resource is
	// created by another service, you can't edit or delete it using Amazon Route
	// 53.
	Description *string `type:"string"`

	// If the health check or hosted zone was created by another service, the service
	// that created the resource. When a resource is created by another service,
	// you can't edit or delete it using Amazon Route 53.
	ServicePrincipal *string `type:"string"`
}

// String returns the string representation
func (s LinkedService) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s LinkedService) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LinkedService) MarshalFields(e protocol.FieldEncoder) error {
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.StringValue(v), metadata)
	}
	if s.ServicePrincipal != nil {
		v := *s.ServicePrincipal

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ServicePrincipal", protocol.StringValue(v), metadata)
	}
	return nil
}

// A request to get a list of geographic locations that Amazon Route 53 supports
// for geolocation resource record sets.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListGeoLocationsRequest
type ListGeoLocationsInput struct {
	_ struct{} `type:"structure"`

	// (Optional) The maximum number of geolocations to be included in the response
	// body for this request. If more than maxitems geolocations remain to be listed,
	// then the value of the IsTruncated element in the response is true.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`

	// The code for the continent with which you want to start listing locations
	// that Amazon Route 53 supports for geolocation. If Route 53 has already returned
	// a page or more of results, if IsTruncated is true, and if NextContinentCode
	// from the previous response has a value, enter that value in startcontinentcode
	// to return the next page of results.
	//
	// Include startcontinentcode only if you want to list continents. Don't include
	// startcontinentcode when you're listing countries or countries with their
	// subdivisions.
	StartContinentCode *string `location:"querystring" locationName:"startcontinentcode" min:"2" type:"string"`

	// The code for the country with which you want to start listing locations that
	// Amazon Route 53 supports for geolocation. If Route 53 has already returned
	// a page or more of results, if IsTruncated is true, and if NextCountryCode
	// from the previous response has a value, enter that value in startcountrycode
	// to return the next page of results.
	//
	// Route 53 uses the two-letter country codes that are specified in ISO standard
	// 3166-1 alpha-2 (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
	StartCountryCode *string `location:"querystring" locationName:"startcountrycode" min:"1" type:"string"`

	// The code for the subdivision (for example, state or province) with which
	// you want to start listing locations that Amazon Route 53 supports for geolocation.
	// If Route 53 has already returned a page or more of results, if IsTruncated
	// is true, and if NextSubdivisionCode from the previous response has a value,
	// enter that value in startsubdivisioncode to return the next page of results.
	//
	// To list subdivisions of a country, you must include both startcountrycode
	// and startsubdivisioncode.
	StartSubdivisionCode *string `location:"querystring" locationName:"startsubdivisioncode" min:"1" type:"string"`
}

// String returns the string representation
func (s ListGeoLocationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListGeoLocationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListGeoLocationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListGeoLocationsInput"}
	if s.StartContinentCode != nil && len(*s.StartContinentCode) < 2 {
		invalidParams.Add(aws.NewErrParamMinLen("StartContinentCode", 2))
	}
	if s.StartCountryCode != nil && len(*s.StartCountryCode) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StartCountryCode", 1))
	}
	if s.StartSubdivisionCode != nil && len(*s.StartSubdivisionCode) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StartSubdivisionCode", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListGeoLocationsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	if s.StartContinentCode != nil {
		v := *s.StartContinentCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "startcontinentcode", protocol.StringValue(v), metadata)
	}
	if s.StartCountryCode != nil {
		v := *s.StartCountryCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "startcountrycode", protocol.StringValue(v), metadata)
	}
	if s.StartSubdivisionCode != nil {
		v := *s.StartSubdivisionCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "startsubdivisioncode", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type containing the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListGeoLocationsResponse
type ListGeoLocationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains one GeoLocationDetails element for each location
	// that Amazon Route 53 supports for geolocation.
	//
	// GeoLocationDetailsList is a required field
	GeoLocationDetailsList []GeoLocationDetails `locationNameList:"GeoLocationDetails" type:"list" required:"true"`

	// A value that indicates whether more locations remain to be listed after the
	// last location in this response. If so, the value of IsTruncated is true.
	// To get more values, submit another request and include the values of NextContinentCode,
	// NextCountryCode, and NextSubdivisionCode in the startcontinentcode, startcountrycode,
	// and startsubdivisioncode, as applicable.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// The value that you specified for MaxItems in the request.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If IsTruncated is true, you can make a follow-up request to display more
	// locations. Enter the value of NextContinentCode in the startcontinentcode
	// parameter in another ListGeoLocations request.
	NextContinentCode *string `min:"2" type:"string"`

	// If IsTruncated is true, you can make a follow-up request to display more
	// locations. Enter the value of NextCountryCode in the startcountrycode parameter
	// in another ListGeoLocations request.
	NextCountryCode *string `min:"1" type:"string"`

	// If IsTruncated is true, you can make a follow-up request to display more
	// locations. Enter the value of NextSubdivisionCode in the startsubdivisioncode
	// parameter in another ListGeoLocations request.
	NextSubdivisionCode *string `min:"1" type:"string"`
}

// String returns the string representation
func (s ListGeoLocationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListGeoLocationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListGeoLocationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListGeoLocationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.GeoLocationDetailsList) > 0 {
		v := s.GeoLocationDetailsList

		metadata := protocol.Metadata{ListLocationName: "GeoLocationDetails"}
		ls0 := e.List(protocol.BodyTarget, "GeoLocationDetailsList", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.NextContinentCode != nil {
		v := *s.NextContinentCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextContinentCode", protocol.StringValue(v), metadata)
	}
	if s.NextCountryCode != nil {
		v := *s.NextCountryCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextCountryCode", protocol.StringValue(v), metadata)
	}
	if s.NextSubdivisionCode != nil {
		v := *s.NextSubdivisionCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextSubdivisionCode", protocol.StringValue(v), metadata)
	}
	return nil
}

// A request to retrieve a list of the health checks that are associated with
// the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHealthChecksRequest
type ListHealthChecksInput struct {
	_ struct{} `type:"structure"`

	// If the value of IsTruncated in the previous response was true, you have more
	// health checks. To get another group, submit another ListHealthChecks request.
	//
	// For the value of marker, specify the value of NextMarker from the previous
	// response, which is the ID of the first health check that Amazon Route 53
	// will return if you submit another request.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more health checks to get.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The maximum number of health checks that you want ListHealthChecks to return
	// in response to the current request. Amazon Route 53 returns a maximum of
	// 100 items. If you set MaxItems to a value greater than 100, Route 53 returns
	// only the first 100 health checks.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`
}

// String returns the string representation
func (s ListHealthChecksInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListHealthChecksInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListHealthChecksInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response to a ListHealthChecks request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHealthChecksResponse
type ListHealthChecksOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains one HealthCheck element for each health check
	// that is associated with the current AWS account.
	//
	// HealthChecks is a required field
	HealthChecks []HealthCheck `locationNameList:"HealthCheck" type:"list" required:"true"`

	// A flag that indicates whether there are more health checks to be listed.
	// If the response was truncated, you can get the next group of health checks
	// by submitting another ListHealthChecks request and specifying the value of
	// NextMarker in the marker parameter.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// For the second and subsequent calls to ListHealthChecks, Marker is the value
	// that you specified for the marker parameter in the previous request.
	//
	// Marker is a required field
	Marker *string `type:"string" required:"true"`

	// The value that you specified for the maxitems parameter in the call to ListHealthChecks
	// that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If IsTruncated is true, the value of NextMarker identifies the first health
	// check that Amazon Route 53 returns if you submit another ListHealthChecks
	// request and specify the value of NextMarker in the marker parameter.
	NextMarker *string `type:"string"`
}

// String returns the string representation
func (s ListHealthChecksOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListHealthChecksOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListHealthChecksOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListHealthChecksOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.HealthChecks) > 0 {
		v := s.HealthChecks

		metadata := protocol.Metadata{ListLocationName: "HealthCheck"}
		ls0 := e.List(protocol.BodyTarget, "HealthChecks", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextMarker", protocol.StringValue(v), metadata)
	}
	return nil
}

// Retrieves a list of the public and private hosted zones that are associated
// with the current AWS account in ASCII order by domain name.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHostedZonesByNameRequest
type ListHostedZonesByNameInput struct {
	_ struct{} `type:"structure"`

	// (Optional) For your first request to ListHostedZonesByName, include the dnsname
	// parameter only if you want to specify the name of the first hosted zone in
	// the response. If you don't include the dnsname parameter, Amazon Route 53
	// returns all of the hosted zones that were created by the current AWS account,
	// in ASCII order. For subsequent requests, include both dnsname and hostedzoneid
	// parameters. For dnsname, specify the value of NextDNSName from the previous
	// response.
	DNSName *string `location:"querystring" locationName:"dnsname" type:"string"`

	// (Optional) For your first request to ListHostedZonesByName, do not include
	// the hostedzoneid parameter.
	//
	// If you have more hosted zones than the value of maxitems, ListHostedZonesByName
	// returns only the first maxitems hosted zones. To get the next group of maxitems
	// hosted zones, submit another request to ListHostedZonesByName and include
	// both dnsname and hostedzoneid parameters. For the value of hostedzoneid,
	// specify the value of the NextHostedZoneId element from the previous response.
	HostedZoneId *string `location:"querystring" locationName:"hostedzoneid" type:"string"`

	// The maximum number of hosted zones to be included in the response body for
	// this request. If you have more than maxitems hosted zones, then the value
	// of the IsTruncated element in the response is true, and the values of NextDNSName
	// and NextHostedZoneId specify the first hosted zone in the next group of maxitems
	// hosted zones.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`
}

// String returns the string representation
func (s ListHostedZonesByNameInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListHostedZonesByNameInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListHostedZonesByNameInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DNSName != nil {
		v := *s.DNSName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "dnsname", protocol.StringValue(v), metadata)
	}
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "hostedzoneid", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHostedZonesByNameResponse
type ListHostedZonesByNameOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// For the second and subsequent calls to ListHostedZonesByName, DNSName is
	// the value that you specified for the dnsname parameter in the request that
	// produced the current response.
	DNSName *string `type:"string"`

	// The ID that Amazon Route 53 assigned to the hosted zone when you created
	// it.
	HostedZoneId *string `type:"string"`

	// A complex type that contains general information about the hosted zone.
	//
	// HostedZones is a required field
	HostedZones []HostedZone `locationNameList:"HostedZone" type:"list" required:"true"`

	// A flag that indicates whether there are more hosted zones to be listed. If
	// the response was truncated, you can get the next group of maxitems hosted
	// zones by calling ListHostedZonesByName again and specifying the values of
	// NextDNSName and NextHostedZoneId elements in the dnsname and hostedzoneid
	// parameters.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// The value that you specified for the maxitems parameter in the call to ListHostedZonesByName
	// that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If IsTruncated is true, the value of NextDNSName is the name of the first
	// hosted zone in the next group of maxitems hosted zones. Call ListHostedZonesByName
	// again and specify the value of NextDNSName and NextHostedZoneId in the dnsname
	// and hostedzoneid parameters, respectively.
	//
	// This element is present only if IsTruncated is true.
	NextDNSName *string `type:"string"`

	// If IsTruncated is true, the value of NextHostedZoneId identifies the first
	// hosted zone in the next group of maxitems hosted zones. Call ListHostedZonesByName
	// again and specify the value of NextDNSName and NextHostedZoneId in the dnsname
	// and hostedzoneid parameters, respectively.
	//
	// This element is present only if IsTruncated is true.
	NextHostedZoneId *string `type:"string"`
}

// String returns the string representation
func (s ListHostedZonesByNameOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListHostedZonesByNameOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListHostedZonesByNameOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListHostedZonesByNameOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.DNSName != nil {
		v := *s.DNSName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DNSName", protocol.StringValue(v), metadata)
	}
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
	}
	if len(s.HostedZones) > 0 {
		v := s.HostedZones

		metadata := protocol.Metadata{ListLocationName: "HostedZone"}
		ls0 := e.List(protocol.BodyTarget, "HostedZones", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.NextDNSName != nil {
		v := *s.NextDNSName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextDNSName", protocol.StringValue(v), metadata)
	}
	if s.NextHostedZoneId != nil {
		v := *s.NextHostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextHostedZoneId", protocol.StringValue(v), metadata)
	}
	return nil
}

// A request to retrieve a list of the public and private hosted zones that
// are associated with the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHostedZonesRequest
type ListHostedZonesInput struct {
	_ struct{} `type:"structure"`

	// If you're using reusable delegation sets and you want to list all of the
	// hosted zones that are associated with a reusable delegation set, specify
	// the ID of that reusable delegation set.
	DelegationSetId *string `location:"querystring" locationName:"delegationsetid" type:"string"`

	// If the value of IsTruncated in the previous response was true, you have more
	// hosted zones. To get more hosted zones, submit another ListHostedZones request.
	//
	// For the value of marker, specify the value of NextMarker from the previous
	// response, which is the ID of the first hosted zone that Amazon Route 53 will
	// return if you submit another request.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more hosted zones to get.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// (Optional) The maximum number of hosted zones that you want Amazon Route
	// 53 to return. If you have more than maxitems hosted zones, the value of IsTruncated
	// in the response is true, and the value of NextMarker is the hosted zone ID
	// of the first hosted zone that Route 53 will return if you submit another
	// request.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`
}

// String returns the string representation
func (s ListHostedZonesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListHostedZonesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListHostedZonesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.DelegationSetId != nil {
		v := *s.DelegationSetId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "delegationsetid", protocol.StringValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListHostedZonesResponse
type ListHostedZonesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains general information about the hosted zone.
	//
	// HostedZones is a required field
	HostedZones []HostedZone `locationNameList:"HostedZone" type:"list" required:"true"`

	// A flag indicating whether there are more hosted zones to be listed. If the
	// response was truncated, you can get more hosted zones by submitting another
	// ListHostedZones request and specifying the value of NextMarker in the marker
	// parameter.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// For the second and subsequent calls to ListHostedZones, Marker is the value
	// that you specified for the marker parameter in the request that produced
	// the current response.
	//
	// Marker is a required field
	Marker *string `type:"string" required:"true"`

	// The value that you specified for the maxitems parameter in the call to ListHostedZones
	// that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If IsTruncated is true, the value of NextMarker identifies the first hosted
	// zone in the next group of hosted zones. Submit another ListHostedZones request,
	// and specify the value of NextMarker from the response in the marker parameter.
	//
	// This element is present only if IsTruncated is true.
	NextMarker *string `type:"string"`
}

// String returns the string representation
func (s ListHostedZonesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListHostedZonesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListHostedZonesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListHostedZonesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.HostedZones) > 0 {
		v := s.HostedZones

		metadata := protocol.Metadata{ListLocationName: "HostedZone"}
		ls0 := e.List(protocol.BodyTarget, "HostedZones", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextMarker", protocol.StringValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListQueryLoggingConfigsRequest
type ListQueryLoggingConfigsInput struct {
	_ struct{} `type:"structure"`

	// (Optional) If you want to list the query logging configuration that is associated
	// with a hosted zone, specify the ID in HostedZoneId.
	//
	// If you don't specify a hosted zone ID, ListQueryLoggingConfigs returns all
	// of the configurations that are associated with the current AWS account.
	HostedZoneId *string `location:"querystring" locationName:"hostedzoneid" type:"string"`

	// (Optional) The maximum number of query logging configurations that you want
	// Amazon Route 53 to return in response to the current request. If the current
	// AWS account has more than MaxResults configurations, use the value of ListQueryLoggingConfigsResponse$NextToken
	// in the response to get the next page of results.
	//
	// If you don't specify a value for MaxResults, Route 53 returns up to 100 configurations.
	MaxResults *string `location:"querystring" locationName:"maxresults" type:"string"`

	// (Optional) If the current AWS account has more than MaxResults query logging
	// configurations, use NextToken to get the second and subsequent pages of results.
	//
	// For the first ListQueryLoggingConfigs request, omit this value.
	//
	// For the second and subsequent requests, get the value of NextToken from the
	// previous response and specify that value for NextToken in the request.
	NextToken *string `location:"querystring" locationName:"nexttoken" type:"string"`
}

// String returns the string representation
func (s ListQueryLoggingConfigsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListQueryLoggingConfigsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListQueryLoggingConfigsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "hostedzoneid", protocol.StringValue(v), metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxresults", protocol.StringValue(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nexttoken", protocol.StringValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListQueryLoggingConfigsResponse
type ListQueryLoggingConfigsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If a response includes the last of the query logging configurations that
	// are associated with the current AWS account, NextToken doesn't appear in
	// the response.
	//
	// If a response doesn't include the last of the configurations, you can get
	// more configurations by submitting another ListQueryLoggingConfigs request.
	// Get the value of NextToken that Amazon Route 53 returned in the previous
	// response and include it in NextToken in the next request.
	NextToken *string `type:"string"`

	// An array that contains one QueryLoggingConfig element for each configuration
	// for DNS query logging that is associated with the current AWS account.
	//
	// QueryLoggingConfigs is a required field
	QueryLoggingConfigs []QueryLoggingConfig `locationNameList:"QueryLoggingConfig" type:"list" required:"true"`
}

// String returns the string representation
func (s ListQueryLoggingConfigsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListQueryLoggingConfigsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListQueryLoggingConfigsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListQueryLoggingConfigsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.StringValue(v), metadata)
	}
	if len(s.QueryLoggingConfigs) > 0 {
		v := s.QueryLoggingConfigs

		metadata := protocol.Metadata{ListLocationName: "QueryLoggingConfig"}
		ls0 := e.List(protocol.BodyTarget, "QueryLoggingConfigs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A request for the resource record sets that are associated with a specified
// hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListResourceRecordSetsRequest
type ListResourceRecordSetsInput struct {
	_ struct{} `type:"structure"`

	// The ID of the hosted zone that contains the resource record sets that you
	// want to list.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"uri" locationName:"Id" type:"string" required:"true"`

	// (Optional) The maximum number of resource records sets to include in the
	// response body for this request. If the response includes more than maxitems
	// resource record sets, the value of the IsTruncated element in the response
	// is true, and the values of the NextRecordName and NextRecordType elements
	// in the response identify the first resource record set in the next group
	// of maxitems resource record sets.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`

	// Weighted resource record sets only: If results were truncated for a given
	// DNS name and type, specify the value of NextRecordIdentifier from the previous
	// response to get the next resource record set that has the current DNS name
	// and type.
	StartRecordIdentifier *string `location:"querystring" locationName:"identifier" min:"1" type:"string"`

	// The first name in the lexicographic ordering of resource record sets that
	// you want to list.
	StartRecordName *string `location:"querystring" locationName:"name" type:"string"`

	// The type of resource record set to begin the record listing from.
	//
	// Valid values for basic resource record sets: A | AAAA | CAA | CNAME | MX
	// | NAPTR | NS | PTR | SOA | SPF | SRV | TXT
	//
	// Values for weighted, latency, geolocation, and failover resource record sets:
	// A | AAAA | CAA | CNAME | MX | NAPTR | PTR | SPF | SRV | TXT
	//
	// Values for alias resource record sets:
	//
	//    * CloudFront distribution: A or AAAA
	//
	//    * Elastic Beanstalk environment that has a regionalized subdomain: A
	//
	//    * ELB load balancer: A | AAAA
	//
	//    * Amazon S3 bucket: A
	//
	//    * Another resource record set in this hosted zone: The type of the resource
	//    record set that the alias references.
	//
	// Constraint: Specifying type without specifying name returns an InvalidInput
	// error.
	StartRecordType RRType `location:"querystring" locationName:"type" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListResourceRecordSetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListResourceRecordSetsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListResourceRecordSetsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListResourceRecordSetsInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}
	if s.StartRecordIdentifier != nil && len(*s.StartRecordIdentifier) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("StartRecordIdentifier", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListResourceRecordSetsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	if s.StartRecordIdentifier != nil {
		v := *s.StartRecordIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "identifier", protocol.StringValue(v), metadata)
	}
	if s.StartRecordName != nil {
		v := *s.StartRecordName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "name", protocol.StringValue(v), metadata)
	}
	if len(s.StartRecordType) > 0 {
		v := s.StartRecordType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "type", v, metadata)
	}
	return nil
}

// A complex type that contains list information for the resource record set.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListResourceRecordSetsResponse
type ListResourceRecordSetsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A flag that indicates whether more resource record sets remain to be listed.
	// If your results were truncated, you can make a follow-up pagination request
	// by using the NextRecordName element.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// The maximum number of records you requested.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// Resource record sets that have a routing policy other than simple: If results
	// were truncated for a given DNS name and type, the value of SetIdentifier
	// for the next resource record set that has the current DNS name and type.
	//
	// For information about routing policies, see Choosing a Routing Policy (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html)
	// in the Amazon Route 53 Developer Guide.
	NextRecordIdentifier *string `min:"1" type:"string"`

	// If the results were truncated, the name of the next record in the list.
	//
	// This element is present only if IsTruncated is true.
	NextRecordName *string `type:"string"`

	// If the results were truncated, the type of the next record in the list.
	//
	// This element is present only if IsTruncated is true.
	NextRecordType RRType `type:"string" enum:"true"`

	// Information about multiple resource record sets.
	//
	// ResourceRecordSets is a required field
	ResourceRecordSets []ResourceRecordSet `locationNameList:"ResourceRecordSet" type:"list" required:"true"`
}

// String returns the string representation
func (s ListResourceRecordSetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListResourceRecordSetsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListResourceRecordSetsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListResourceRecordSetsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.NextRecordIdentifier != nil {
		v := *s.NextRecordIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextRecordIdentifier", protocol.StringValue(v), metadata)
	}
	if s.NextRecordName != nil {
		v := *s.NextRecordName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextRecordName", protocol.StringValue(v), metadata)
	}
	if len(s.NextRecordType) > 0 {
		v := s.NextRecordType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextRecordType", v, metadata)
	}
	if len(s.ResourceRecordSets) > 0 {
		v := s.ResourceRecordSets

		metadata := protocol.Metadata{ListLocationName: "ResourceRecordSet"}
		ls0 := e.List(protocol.BodyTarget, "ResourceRecordSets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A request to get a list of the reusable delegation sets that are associated
// with the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListReusableDelegationSetsRequest
type ListReusableDelegationSetsInput struct {
	_ struct{} `type:"structure"`

	// If the value of IsTruncated in the previous response was true, you have more
	// reusable delegation sets. To get another group, submit another ListReusableDelegationSets
	// request.
	//
	// For the value of marker, specify the value of NextMarker from the previous
	// response, which is the ID of the first reusable delegation set that Amazon
	// Route 53 will return if you submit another request.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more reusable delegation sets to get.
	Marker *string `location:"querystring" locationName:"marker" type:"string"`

	// The number of reusable delegation sets that you want Amazon Route 53 to return
	// in the response to this request. If you specify a value greater than 100,
	// Route 53 returns only the first 100 reusable delegation sets.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`
}

// String returns the string representation
func (s ListReusableDelegationSetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListReusableDelegationSetsInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListReusableDelegationSetsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "marker", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the reusable delegation sets
// that are associated with the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListReusableDelegationSetsResponse
type ListReusableDelegationSetsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains one DelegationSet element for each reusable
	// delegation set that was created by the current AWS account.
	//
	// DelegationSets is a required field
	DelegationSets []DelegationSet `locationNameList:"DelegationSet" type:"list" required:"true"`

	// A flag that indicates whether there are more reusable delegation sets to
	// be listed.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// For the second and subsequent calls to ListReusableDelegationSets, Marker
	// is the value that you specified for the marker parameter in the request that
	// produced the current response.
	//
	// Marker is a required field
	Marker *string `type:"string" required:"true"`

	// The value that you specified for the maxitems parameter in the call to ListReusableDelegationSets
	// that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If IsTruncated is true, the value of NextMarker identifies the next reusable
	// delegation set that Amazon Route 53 will return if you submit another ListReusableDelegationSets
	// request and specify the value of NextMarker in the marker parameter.
	NextMarker *string `type:"string"`
}

// String returns the string representation
func (s ListReusableDelegationSetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListReusableDelegationSetsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListReusableDelegationSetsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListReusableDelegationSetsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.DelegationSets) > 0 {
		v := s.DelegationSets

		metadata := protocol.Metadata{ListLocationName: "DelegationSet"}
		ls0 := e.List(protocol.BodyTarget, "DelegationSets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.Marker != nil {
		v := *s.Marker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Marker", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.NextMarker != nil {
		v := *s.NextMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextMarker", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type containing information about a request for a list of the tags
// that are associated with an individual resource.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTagsForResourceRequest
type ListTagsForResourceInput struct {
	_ struct{} `type:"structure"`

	// The ID of the resource for which you want to retrieve tags.
	//
	// ResourceId is a required field
	ResourceId *string `location:"uri" locationName:"ResourceId" type:"string" required:"true"`

	// The type of the resource.
	//
	//    * The resource type for health checks is healthcheck.
	//
	//    * The resource type for hosted zones is hostedzone.
	//
	// ResourceType is a required field
	ResourceType TagResourceType `location:"uri" locationName:"ResourceType" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s ListTagsForResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsForResourceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTagsForResourceInput"}

	if s.ResourceId == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceId"))
	}
	if len(s.ResourceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResourceType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsForResourceInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceId", protocol.StringValue(v), metadata)
	}
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceType", v, metadata)
	}
	return nil
}

// A complex type that contains information about the health checks or hosted
// zones for which you want to list tags.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTagsForResourceResponse
type ListTagsForResourceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A ResourceTagSet containing tags associated with the specified resource.
	//
	// ResourceTagSet is a required field
	ResourceTagSet *ResourceTagSet `type:"structure" required:"true"`
}

// String returns the string representation
func (s ListTagsForResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForResourceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTagsForResourceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsForResourceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.ResourceTagSet != nil {
		v := s.ResourceTagSet

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ResourceTagSet", v, metadata)
	}
	return nil
}

// A complex type that contains information about the health checks or hosted
// zones for which you want to list tags.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTagsForResourcesRequest
type ListTagsForResourcesInput struct {
	_ struct{} `locationName:"ListTagsForResourcesRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// A complex type that contains the ResourceId element for each resource for
	// which you want to get a list of tags.
	//
	// ResourceIds is a required field
	ResourceIds []string `locationNameList:"ResourceId" min:"1" type:"list" required:"true"`

	// The type of the resources.
	//
	//    * The resource type for health checks is healthcheck.
	//
	//    * The resource type for hosted zones is hostedzone.
	//
	// ResourceType is a required field
	ResourceType TagResourceType `location:"uri" locationName:"ResourceType" type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s ListTagsForResourcesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForResourcesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsForResourcesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTagsForResourcesInput"}

	if s.ResourceIds == nil {
		invalidParams.Add(aws.NewErrParamRequired("ResourceIds"))
	}
	if s.ResourceIds != nil && len(s.ResourceIds) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceIds", 1))
	}
	if len(s.ResourceType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("ResourceType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsForResourcesInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "ListTagsForResourcesRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if len(s.ResourceIds) > 0 {
			v := s.ResourceIds

			metadata := protocol.Metadata{ListLocationName: "ResourceId"}
			ls0 := e.List(protocol.BodyTarget, "ResourceIds", metadata)
			ls0.Start()
			for _, v1 := range v {
				ls0.ListAddValue(protocol.StringValue(v1))
			}
			ls0.End()

		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "ResourceType", v, metadata)
	}
	return nil
}

// A complex type containing tags for the specified resources.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTagsForResourcesResponse
type ListTagsForResourcesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A list of ResourceTagSets containing tags associated with the specified resources.
	//
	// ResourceTagSets is a required field
	ResourceTagSets []ResourceTagSet `locationNameList:"ResourceTagSet" type:"list" required:"true"`
}

// String returns the string representation
func (s ListTagsForResourcesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForResourcesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTagsForResourcesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTagsForResourcesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.ResourceTagSets) > 0 {
		v := s.ResourceTagSets

		metadata := protocol.Metadata{ListLocationName: "ResourceTagSet"}
		ls0 := e.List(protocol.BodyTarget, "ResourceTagSets", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A complex type that contains the information about the request to list the
// traffic policies that are associated with the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPoliciesRequest
type ListTrafficPoliciesInput struct {
	_ struct{} `type:"structure"`

	// (Optional) The maximum number of traffic policies that you want Amazon Route
	// 53 to return in response to this request. If you have more than MaxItems
	// traffic policies, the value of IsTruncated in the response is true, and the
	// value of TrafficPolicyIdMarker is the ID of the first traffic policy that
	// Route 53 will return if you submit another request.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`

	// (Conditional) For your first request to ListTrafficPolicies, don't include
	// the TrafficPolicyIdMarker parameter.
	//
	// If you have more traffic policies than the value of MaxItems, ListTrafficPolicies
	// returns only the first MaxItems traffic policies. To get the next group of
	// policies, submit another request to ListTrafficPolicies. For the value of
	// TrafficPolicyIdMarker, specify the value of TrafficPolicyIdMarker that was
	// returned in the previous response.
	TrafficPolicyIdMarker *string `location:"querystring" locationName:"trafficpolicyid" min:"1" type:"string"`
}

// String returns the string representation
func (s ListTrafficPoliciesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPoliciesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTrafficPoliciesInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTrafficPoliciesInput"}
	if s.TrafficPolicyIdMarker != nil && len(*s.TrafficPolicyIdMarker) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TrafficPolicyIdMarker", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPoliciesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyIdMarker != nil {
		v := *s.TrafficPolicyIdMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "trafficpolicyid", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPoliciesResponse
type ListTrafficPoliciesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A flag that indicates whether there are more traffic policies to be listed.
	// If the response was truncated, you can get the next group of traffic policies
	// by submitting another ListTrafficPolicies request and specifying the value
	// of TrafficPolicyIdMarker in the TrafficPolicyIdMarker request parameter.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// The value that you specified for the MaxItems parameter in the ListTrafficPolicies
	// request that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If the value of IsTruncated is true, TrafficPolicyIdMarker is the ID of the
	// first traffic policy in the next group of MaxItems traffic policies.
	//
	// TrafficPolicyIdMarker is a required field
	TrafficPolicyIdMarker *string `min:"1" type:"string" required:"true"`

	// A list that contains one TrafficPolicySummary element for each traffic policy
	// that was created by the current AWS account.
	//
	// TrafficPolicySummaries is a required field
	TrafficPolicySummaries []TrafficPolicySummary `locationNameList:"TrafficPolicySummary" type:"list" required:"true"`
}

// String returns the string representation
func (s ListTrafficPoliciesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPoliciesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTrafficPoliciesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPoliciesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyIdMarker != nil {
		v := *s.TrafficPolicyIdMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyIdMarker", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicySummaries) > 0 {
		v := s.TrafficPolicySummaries

		metadata := protocol.Metadata{ListLocationName: "TrafficPolicySummary"}
		ls0 := e.List(protocol.BodyTarget, "TrafficPolicySummaries", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A request for the traffic policy instances that you created in a specified
// hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstancesByHostedZoneRequest
type ListTrafficPolicyInstancesByHostedZoneInput struct {
	_ struct{} `type:"structure"`

	// The ID of the hosted zone that you want to list traffic policy instances
	// for.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"querystring" locationName:"id" type:"string" required:"true"`

	// The maximum number of traffic policy instances to be included in the response
	// body for this request. If you have more than MaxItems traffic policy instances,
	// the value of the IsTruncated element in the response is true, and the values
	// of HostedZoneIdMarker, TrafficPolicyInstanceNameMarker, and TrafficPolicyInstanceTypeMarker
	// represent the first traffic policy instance that Amazon Route 53 will return
	// if you submit another request.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`

	// If the value of IsTruncated in the previous response is true, you have more
	// traffic policy instances. To get more traffic policy instances, submit another
	// ListTrafficPolicyInstances request. For the value of trafficpolicyinstancename,
	// specify the value of TrafficPolicyInstanceNameMarker from the previous response,
	// which is the name of the first traffic policy instance in the next group
	// of traffic policy instances.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more traffic policy instances to get.
	TrafficPolicyInstanceNameMarker *string `location:"querystring" locationName:"trafficpolicyinstancename" type:"string"`

	// If the value of IsTruncated in the previous response is true, you have more
	// traffic policy instances. To get more traffic policy instances, submit another
	// ListTrafficPolicyInstances request. For the value of trafficpolicyinstancetype,
	// specify the value of TrafficPolicyInstanceTypeMarker from the previous response,
	// which is the type of the first traffic policy instance in the next group
	// of traffic policy instances.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more traffic policy instances to get.
	TrafficPolicyInstanceTypeMarker RRType `location:"querystring" locationName:"trafficpolicyinstancetype" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListTrafficPolicyInstancesByHostedZoneInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPolicyInstancesByHostedZoneInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTrafficPolicyInstancesByHostedZoneInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTrafficPolicyInstancesByHostedZoneInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPolicyInstancesByHostedZoneInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "id", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyInstanceNameMarker != nil {
		v := *s.TrafficPolicyInstanceNameMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "trafficpolicyinstancename", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicyInstanceTypeMarker) > 0 {
		v := s.TrafficPolicyInstanceTypeMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "trafficpolicyinstancetype", v, metadata)
	}
	return nil
}

// A complex type that contains the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstancesByHostedZoneResponse
type ListTrafficPolicyInstancesByHostedZoneOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A flag that indicates whether there are more traffic policy instances to
	// be listed. If the response was truncated, you can get the next group of traffic
	// policy instances by submitting another ListTrafficPolicyInstancesByHostedZone
	// request and specifying the values of HostedZoneIdMarker, TrafficPolicyInstanceNameMarker,
	// and TrafficPolicyInstanceTypeMarker in the corresponding request parameters.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// The value that you specified for the MaxItems parameter in the ListTrafficPolicyInstancesByHostedZone
	// request that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If IsTruncated is true, TrafficPolicyInstanceNameMarker is the name of the
	// first traffic policy instance in the next group of traffic policy instances.
	TrafficPolicyInstanceNameMarker *string `type:"string"`

	// If IsTruncated is true, TrafficPolicyInstanceTypeMarker is the DNS type of
	// the resource record sets that are associated with the first traffic policy
	// instance in the next group of traffic policy instances.
	TrafficPolicyInstanceTypeMarker RRType `type:"string" enum:"true"`

	// A list that contains one TrafficPolicyInstance element for each traffic policy
	// instance that matches the elements in the request.
	//
	// TrafficPolicyInstances is a required field
	TrafficPolicyInstances []TrafficPolicyInstance `locationNameList:"TrafficPolicyInstance" type:"list" required:"true"`
}

// String returns the string representation
func (s ListTrafficPolicyInstancesByHostedZoneOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPolicyInstancesByHostedZoneOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTrafficPolicyInstancesByHostedZoneOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPolicyInstancesByHostedZoneOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyInstanceNameMarker != nil {
		v := *s.TrafficPolicyInstanceNameMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyInstanceNameMarker", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicyInstanceTypeMarker) > 0 {
		v := s.TrafficPolicyInstanceTypeMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyInstanceTypeMarker", v, metadata)
	}
	if len(s.TrafficPolicyInstances) > 0 {
		v := s.TrafficPolicyInstances

		metadata := protocol.Metadata{ListLocationName: "TrafficPolicyInstance"}
		ls0 := e.List(protocol.BodyTarget, "TrafficPolicyInstances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A complex type that contains the information about the request to list your
// traffic policy instances.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstancesByPolicyRequest
type ListTrafficPolicyInstancesByPolicyInput struct {
	_ struct{} `type:"structure"`

	// If the value of IsTruncated in the previous response was true, you have more
	// traffic policy instances. To get more traffic policy instances, submit another
	// ListTrafficPolicyInstancesByPolicy request.
	//
	// For the value of hostedzoneid, specify the value of HostedZoneIdMarker from
	// the previous response, which is the hosted zone ID of the first traffic policy
	// instance that Amazon Route 53 will return if you submit another request.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more traffic policy instances to get.
	HostedZoneIdMarker *string `location:"querystring" locationName:"hostedzoneid" type:"string"`

	// The maximum number of traffic policy instances to be included in the response
	// body for this request. If you have more than MaxItems traffic policy instances,
	// the value of the IsTruncated element in the response is true, and the values
	// of HostedZoneIdMarker, TrafficPolicyInstanceNameMarker, and TrafficPolicyInstanceTypeMarker
	// represent the first traffic policy instance that Amazon Route 53 will return
	// if you submit another request.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`

	// The ID of the traffic policy for which you want to list traffic policy instances.
	//
	// TrafficPolicyId is a required field
	TrafficPolicyId *string `location:"querystring" locationName:"id" min:"1" type:"string" required:"true"`

	// If the value of IsTruncated in the previous response was true, you have more
	// traffic policy instances. To get more traffic policy instances, submit another
	// ListTrafficPolicyInstancesByPolicy request.
	//
	// For the value of trafficpolicyinstancename, specify the value of TrafficPolicyInstanceNameMarker
	// from the previous response, which is the name of the first traffic policy
	// instance that Amazon Route 53 will return if you submit another request.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more traffic policy instances to get.
	TrafficPolicyInstanceNameMarker *string `location:"querystring" locationName:"trafficpolicyinstancename" type:"string"`

	// If the value of IsTruncated in the previous response was true, you have more
	// traffic policy instances. To get more traffic policy instances, submit another
	// ListTrafficPolicyInstancesByPolicy request.
	//
	// For the value of trafficpolicyinstancetype, specify the value of TrafficPolicyInstanceTypeMarker
	// from the previous response, which is the name of the first traffic policy
	// instance that Amazon Route 53 will return if you submit another request.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more traffic policy instances to get.
	TrafficPolicyInstanceTypeMarker RRType `location:"querystring" locationName:"trafficpolicyinstancetype" type:"string" enum:"true"`

	// The version of the traffic policy for which you want to list traffic policy
	// instances. The version must be associated with the traffic policy that is
	// specified by TrafficPolicyId.
	//
	// TrafficPolicyVersion is a required field
	TrafficPolicyVersion *int64 `location:"querystring" locationName:"version" min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s ListTrafficPolicyInstancesByPolicyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPolicyInstancesByPolicyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTrafficPolicyInstancesByPolicyInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTrafficPolicyInstancesByPolicyInput"}

	if s.TrafficPolicyId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TrafficPolicyId"))
	}
	if s.TrafficPolicyId != nil && len(*s.TrafficPolicyId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TrafficPolicyId", 1))
	}

	if s.TrafficPolicyVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("TrafficPolicyVersion"))
	}
	if s.TrafficPolicyVersion != nil && *s.TrafficPolicyVersion < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("TrafficPolicyVersion", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPolicyInstancesByPolicyInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HostedZoneIdMarker != nil {
		v := *s.HostedZoneIdMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "hostedzoneid", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyId != nil {
		v := *s.TrafficPolicyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "id", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyInstanceNameMarker != nil {
		v := *s.TrafficPolicyInstanceNameMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "trafficpolicyinstancename", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicyInstanceTypeMarker) > 0 {
		v := s.TrafficPolicyInstanceTypeMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "trafficpolicyinstancetype", v, metadata)
	}
	if s.TrafficPolicyVersion != nil {
		v := *s.TrafficPolicyVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "version", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstancesByPolicyResponse
type ListTrafficPolicyInstancesByPolicyOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If IsTruncated is true, HostedZoneIdMarker is the ID of the hosted zone of
	// the first traffic policy instance in the next group of traffic policy instances.
	HostedZoneIdMarker *string `type:"string"`

	// A flag that indicates whether there are more traffic policy instances to
	// be listed. If the response was truncated, you can get the next group of traffic
	// policy instances by calling ListTrafficPolicyInstancesByPolicy again and
	// specifying the values of the HostedZoneIdMarker, TrafficPolicyInstanceNameMarker,
	// and TrafficPolicyInstanceTypeMarker elements in the corresponding request
	// parameters.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// The value that you specified for the MaxItems parameter in the call to ListTrafficPolicyInstancesByPolicy
	// that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If IsTruncated is true, TrafficPolicyInstanceNameMarker is the name of the
	// first traffic policy instance in the next group of MaxItems traffic policy
	// instances.
	TrafficPolicyInstanceNameMarker *string `type:"string"`

	// If IsTruncated is true, TrafficPolicyInstanceTypeMarker is the DNS type of
	// the resource record sets that are associated with the first traffic policy
	// instance in the next group of MaxItems traffic policy instances.
	TrafficPolicyInstanceTypeMarker RRType `type:"string" enum:"true"`

	// A list that contains one TrafficPolicyInstance element for each traffic policy
	// instance that matches the elements in the request.
	//
	// TrafficPolicyInstances is a required field
	TrafficPolicyInstances []TrafficPolicyInstance `locationNameList:"TrafficPolicyInstance" type:"list" required:"true"`
}

// String returns the string representation
func (s ListTrafficPolicyInstancesByPolicyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPolicyInstancesByPolicyOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTrafficPolicyInstancesByPolicyOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPolicyInstancesByPolicyOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostedZoneIdMarker != nil {
		v := *s.HostedZoneIdMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneIdMarker", protocol.StringValue(v), metadata)
	}
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyInstanceNameMarker != nil {
		v := *s.TrafficPolicyInstanceNameMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyInstanceNameMarker", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicyInstanceTypeMarker) > 0 {
		v := s.TrafficPolicyInstanceTypeMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyInstanceTypeMarker", v, metadata)
	}
	if len(s.TrafficPolicyInstances) > 0 {
		v := s.TrafficPolicyInstances

		metadata := protocol.Metadata{ListLocationName: "TrafficPolicyInstance"}
		ls0 := e.List(protocol.BodyTarget, "TrafficPolicyInstances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A request to get information about the traffic policy instances that you
// created by using the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstancesRequest
type ListTrafficPolicyInstancesInput struct {
	_ struct{} `type:"structure"`

	// If the value of IsTruncated in the previous response was true, you have more
	// traffic policy instances. To get more traffic policy instances, submit another
	// ListTrafficPolicyInstances request. For the value of HostedZoneId, specify
	// the value of HostedZoneIdMarker from the previous response, which is the
	// hosted zone ID of the first traffic policy instance in the next group of
	// traffic policy instances.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more traffic policy instances to get.
	HostedZoneIdMarker *string `location:"querystring" locationName:"hostedzoneid" type:"string"`

	// The maximum number of traffic policy instances that you want Amazon Route
	// 53 to return in response to a ListTrafficPolicyInstances request. If you
	// have more than MaxItems traffic policy instances, the value of the IsTruncated
	// element in the response is true, and the values of HostedZoneIdMarker, TrafficPolicyInstanceNameMarker,
	// and TrafficPolicyInstanceTypeMarker represent the first traffic policy instance
	// in the next group of MaxItems traffic policy instances.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`

	// If the value of IsTruncated in the previous response was true, you have more
	// traffic policy instances. To get more traffic policy instances, submit another
	// ListTrafficPolicyInstances request. For the value of trafficpolicyinstancename,
	// specify the value of TrafficPolicyInstanceNameMarker from the previous response,
	// which is the name of the first traffic policy instance in the next group
	// of traffic policy instances.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more traffic policy instances to get.
	TrafficPolicyInstanceNameMarker *string `location:"querystring" locationName:"trafficpolicyinstancename" type:"string"`

	// If the value of IsTruncated in the previous response was true, you have more
	// traffic policy instances. To get more traffic policy instances, submit another
	// ListTrafficPolicyInstances request. For the value of trafficpolicyinstancetype,
	// specify the value of TrafficPolicyInstanceTypeMarker from the previous response,
	// which is the type of the first traffic policy instance in the next group
	// of traffic policy instances.
	//
	// If the value of IsTruncated in the previous response was false, there are
	// no more traffic policy instances to get.
	TrafficPolicyInstanceTypeMarker RRType `location:"querystring" locationName:"trafficpolicyinstancetype" type:"string" enum:"true"`
}

// String returns the string representation
func (s ListTrafficPolicyInstancesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPolicyInstancesInput) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPolicyInstancesInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HostedZoneIdMarker != nil {
		v := *s.HostedZoneIdMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "hostedzoneid", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyInstanceNameMarker != nil {
		v := *s.TrafficPolicyInstanceNameMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "trafficpolicyinstancename", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicyInstanceTypeMarker) > 0 {
		v := s.TrafficPolicyInstanceTypeMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "trafficpolicyinstancetype", v, metadata)
	}
	return nil
}

// A complex type that contains the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyInstancesResponse
type ListTrafficPolicyInstancesOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// If IsTruncated is true, HostedZoneIdMarker is the ID of the hosted zone of
	// the first traffic policy instance that Route 53 will return if you submit
	// another ListTrafficPolicyInstances request.
	HostedZoneIdMarker *string `type:"string"`

	// A flag that indicates whether there are more traffic policy instances to
	// be listed. If the response was truncated, you can get more traffic policy
	// instances by calling ListTrafficPolicyInstances again and specifying the
	// values of the HostedZoneIdMarker, TrafficPolicyInstanceNameMarker, and TrafficPolicyInstanceTypeMarker
	// in the corresponding request parameters.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// The value that you specified for the MaxItems parameter in the call to ListTrafficPolicyInstances
	// that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// If IsTruncated is true, TrafficPolicyInstanceNameMarker is the name of the
	// first traffic policy instance that Route 53 will return if you submit another
	// ListTrafficPolicyInstances request.
	TrafficPolicyInstanceNameMarker *string `type:"string"`

	// If IsTruncated is true, TrafficPolicyInstanceTypeMarker is the DNS type of
	// the resource record sets that are associated with the first traffic policy
	// instance that Amazon Route 53 will return if you submit another ListTrafficPolicyInstances
	// request.
	TrafficPolicyInstanceTypeMarker RRType `type:"string" enum:"true"`

	// A list that contains one TrafficPolicyInstance element for each traffic policy
	// instance that matches the elements in the request.
	//
	// TrafficPolicyInstances is a required field
	TrafficPolicyInstances []TrafficPolicyInstance `locationNameList:"TrafficPolicyInstance" type:"list" required:"true"`
}

// String returns the string representation
func (s ListTrafficPolicyInstancesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPolicyInstancesOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTrafficPolicyInstancesOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPolicyInstancesOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostedZoneIdMarker != nil {
		v := *s.HostedZoneIdMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneIdMarker", protocol.StringValue(v), metadata)
	}
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyInstanceNameMarker != nil {
		v := *s.TrafficPolicyInstanceNameMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyInstanceNameMarker", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicyInstanceTypeMarker) > 0 {
		v := s.TrafficPolicyInstanceTypeMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyInstanceTypeMarker", v, metadata)
	}
	if len(s.TrafficPolicyInstances) > 0 {
		v := s.TrafficPolicyInstances

		metadata := protocol.Metadata{ListLocationName: "TrafficPolicyInstance"}
		ls0 := e.List(protocol.BodyTarget, "TrafficPolicyInstances", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A complex type that contains the information about the request to list your
// traffic policies.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyVersionsRequest
type ListTrafficPolicyVersionsInput struct {
	_ struct{} `type:"structure"`

	// Specify the value of Id of the traffic policy for which you want to list
	// all versions.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`

	// The maximum number of traffic policy versions that you want Amazon Route
	// 53 to include in the response body for this request. If the specified traffic
	// policy has more than MaxItems versions, the value of IsTruncated in the response
	// is true, and the value of the TrafficPolicyVersionMarker element is the ID
	// of the first version that Route 53 will return if you submit another request.
	MaxItems *string `location:"querystring" locationName:"maxitems" type:"string"`

	// For your first request to ListTrafficPolicyVersions, don't include the TrafficPolicyVersionMarker
	// parameter.
	//
	// If you have more traffic policy versions than the value of MaxItems, ListTrafficPolicyVersions
	// returns only the first group of MaxItems versions. To get more traffic policy
	// versions, submit another ListTrafficPolicyVersions request. For the value
	// of TrafficPolicyVersionMarker, specify the value of TrafficPolicyVersionMarker
	// in the previous response.
	TrafficPolicyVersionMarker *string `location:"querystring" locationName:"trafficpolicyversion" type:"string"`
}

// String returns the string representation
func (s ListTrafficPolicyVersionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPolicyVersionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTrafficPolicyVersionsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListTrafficPolicyVersionsInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPolicyVersionsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxitems", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyVersionMarker != nil {
		v := *s.TrafficPolicyVersionMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "trafficpolicyversion", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListTrafficPolicyVersionsResponse
type ListTrafficPolicyVersionsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A flag that indicates whether there are more traffic policies to be listed.
	// If the response was truncated, you can get the next group of traffic policies
	// by submitting another ListTrafficPolicyVersions request and specifying the
	// value of NextMarker in the marker parameter.
	//
	// IsTruncated is a required field
	IsTruncated *bool `type:"boolean" required:"true"`

	// The value that you specified for the maxitems parameter in the ListTrafficPolicyVersions
	// request that produced the current response.
	//
	// MaxItems is a required field
	MaxItems *string `type:"string" required:"true"`

	// A list that contains one TrafficPolicy element for each traffic policy version
	// that is associated with the specified traffic policy.
	//
	// TrafficPolicies is a required field
	TrafficPolicies []TrafficPolicy `locationNameList:"TrafficPolicy" type:"list" required:"true"`

	// If IsTruncated is true, the value of TrafficPolicyVersionMarker identifies
	// the first traffic policy that Amazon Route 53 will return if you submit another
	// request. Call ListTrafficPolicyVersions again and specify the value of TrafficPolicyVersionMarker
	// in the TrafficPolicyVersionMarker request parameter.
	//
	// This element is present only if IsTruncated is true.
	//
	// TrafficPolicyVersionMarker is a required field
	TrafficPolicyVersionMarker *string `type:"string" required:"true"`
}

// String returns the string representation
func (s ListTrafficPolicyVersionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTrafficPolicyVersionsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListTrafficPolicyVersionsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListTrafficPolicyVersionsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.IsTruncated != nil {
		v := *s.IsTruncated

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IsTruncated", protocol.BoolValue(v), metadata)
	}
	if s.MaxItems != nil {
		v := *s.MaxItems

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MaxItems", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicies) > 0 {
		v := s.TrafficPolicies

		metadata := protocol.Metadata{ListLocationName: "TrafficPolicy"}
		ls0 := e.List(protocol.BodyTarget, "TrafficPolicies", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.TrafficPolicyVersionMarker != nil {
		v := *s.TrafficPolicyVersionMarker

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyVersionMarker", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about that can be associated with
// your hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListVPCAssociationAuthorizationsRequest
type ListVPCAssociationAuthorizationsInput struct {
	_ struct{} `type:"structure"`

	// The ID of the hosted zone for which you want a list of VPCs that can be associated
	// with the hosted zone.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"uri" locationName:"Id" type:"string" required:"true"`

	// Optional: An integer that specifies the maximum number of VPCs that you want
	// Amazon Route 53 to return. If you don't specify a value for MaxResults, Route
	// 53 returns up to 50 VPCs per page.
	MaxResults *string `location:"querystring" locationName:"maxresults" type:"string"`

	// Optional: If a response includes a NextToken element, there are more VPCs
	// that can be associated with the specified hosted zone. To get the next page
	// of results, submit another request, and include the value of NextToken from
	// the response in the nexttoken parameter in another ListVPCAssociationAuthorizations
	// request.
	NextToken *string `location:"querystring" locationName:"nexttoken" type:"string"`
}

// String returns the string representation
func (s ListVPCAssociationAuthorizationsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListVPCAssociationAuthorizationsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListVPCAssociationAuthorizationsInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ListVPCAssociationAuthorizationsInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListVPCAssociationAuthorizationsInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.MaxResults != nil {
		v := *s.MaxResults

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "maxresults", protocol.StringValue(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "nexttoken", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ListVPCAssociationAuthorizationsResponse
type ListVPCAssociationAuthorizationsOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The ID of the hosted zone that you can associate the listed VPCs with.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `type:"string" required:"true"`

	// When the response includes a NextToken element, there are more VPCs that
	// can be associated with the specified hosted zone. To get the next page of
	// VPCs, submit another ListVPCAssociationAuthorizations request, and include
	// the value of the NextToken element from the response in the nexttoken request
	// parameter.
	NextToken *string `type:"string"`

	// The list of VPCs that are authorized to be associated with the specified
	// hosted zone.
	//
	// VPCs is a required field
	VPCs []VPC `locationNameList:"VPC" min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s ListVPCAssociationAuthorizationsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListVPCAssociationAuthorizationsOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s ListVPCAssociationAuthorizationsOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ListVPCAssociationAuthorizationsOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
	}
	if s.NextToken != nil {
		v := *s.NextToken

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NextToken", protocol.StringValue(v), metadata)
	}
	if len(s.VPCs) > 0 {
		v := s.VPCs

		metadata := protocol.Metadata{ListLocationName: "VPC"}
		ls0 := e.List(protocol.BodyTarget, "VPCs", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A complex type that contains information about a configuration for DNS query
// logging.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/QueryLoggingConfig
type QueryLoggingConfig struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon
	// Route 53 is publishing logs to.
	//
	// CloudWatchLogsLogGroupArn is a required field
	CloudWatchLogsLogGroupArn *string `type:"string" required:"true"`

	// The ID of the hosted zone that CloudWatch Logs is logging queries for.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `type:"string" required:"true"`

	// The ID for a configuration for DNS query logging.
	//
	// Id is a required field
	Id *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s QueryLoggingConfig) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s QueryLoggingConfig) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s QueryLoggingConfig) MarshalFields(e protocol.FieldEncoder) error {
	if s.CloudWatchLogsLogGroupArn != nil {
		v := *s.CloudWatchLogsLogGroupArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CloudWatchLogsLogGroupArn", protocol.StringValue(v), metadata)
	}
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// Information specific to the resource record.
//
// If you're creating an alias resource record set, omit ResourceRecord.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ResourceRecord
type ResourceRecord struct {
	_ struct{} `type:"structure"`

	// The current or new DNS record value, not to exceed 4,000 characters. In the
	// case of a DELETE action, if the current value does not match the actual value,
	// an error is returned. For descriptions about how to format Value for different
	// record types, see Supported DNS Resource Record Types (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html)
	// in the Amazon Route 53 Developer Guide.
	//
	// You can specify more than one value for all record types except CNAME and
	// SOA.
	//
	// If you're creating an alias resource record set, omit Value.
	//
	// Value is a required field
	Value *string `type:"string" required:"true"`
}

// String returns the string representation
func (s ResourceRecord) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourceRecord) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ResourceRecord) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ResourceRecord"}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourceRecord) MarshalFields(e protocol.FieldEncoder) error {
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.StringValue(v), metadata)
	}
	return nil
}

// Information about the resource record set to create or delete.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ResourceRecordSet
type ResourceRecordSet struct {
	_ struct{} `type:"structure"`

	// Alias resource record sets only: Information about the CloudFront distribution,
	// AWS Elastic Beanstalk environment, ELB load balancer, Amazon S3 bucket, or
	// Amazon Route 53 resource record set to which you're redirecting queries.
	// The AWS Elastic Beanstalk environment must have a regionalized subdomain.
	//
	// If you're creating resource records sets for a private hosted zone, note
	// the following:
	//
	//    * You can't create alias resource record sets for CloudFront distributions
	//    in a private hosted zone.
	//
	//    * Creating geolocation alias resource record sets or latency alias resource
	//    record sets in a private hosted zone is unsupported.
	//
	//    * For information about creating failover resource record sets in a private
	//    hosted zone, see Configuring Failover in a Private Hosted Zone (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html)
	//    in the Amazon Route 53 Developer Guide.
	AliasTarget *AliasTarget `type:"structure"`

	// Failover resource record sets only: To configure failover, you add the Failover
	// element to two resource record sets. For one resource record set, you specify
	// PRIMARY as the value for Failover; for the other resource record set, you
	// specify SECONDARY. In addition, you include the HealthCheckId element and
	// specify the health check that you want Amazon Route 53 to perform for each
	// resource record set.
	//
	// Except where noted, the following failover behaviors assume that you have
	// included the HealthCheckId element in both resource record sets:
	//
	//    * When the primary resource record set is healthy, Route 53 responds to
	//    DNS queries with the applicable value from the primary resource record
	//    set regardless of the health of the secondary resource record set.
	//
	//    * When the primary resource record set is unhealthy and the secondary
	//    resource record set is healthy, Route 53 responds to DNS queries with
	//    the applicable value from the secondary resource record set.
	//
	//    * When the secondary resource record set is unhealthy, Route 53 responds
	//    to DNS queries with the applicable value from the primary resource record
	//    set regardless of the health of the primary resource record set.
	//
	//    * If you omit the HealthCheckId element for the secondary resource record
	//    set, and if the primary resource record set is unhealthy, Route 53 always
	//    responds to DNS queries with the applicable value from the secondary resource
	//    record set. This is true regardless of the health of the associated endpoint.
	//
	// You can't create non-failover resource record sets that have the same values
	// for the Name and Type elements as failover resource record sets.
	//
	// For failover alias resource record sets, you must also include the EvaluateTargetHealth
	// element and set the value to true.
	//
	// For more information about configuring failover for Route 53, see the following
	// topics in the Amazon Route 53 Developer Guide:
	//
	//    * Route 53 Health Checks and DNS Failover (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html)
	//
	//    * Configuring Failover in a Private Hosted Zone (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html)
	Failover ResourceRecordSetFailover `type:"string" enum:"true"`

	// Geolocation resource record sets only: A complex type that lets you control
	// how Amazon Route 53 responds to DNS queries based on the geographic origin
	// of the query. For example, if you want all queries from Africa to be routed
	// to a web server with an IP address of 192.0.2.111, create a resource record
	// set with a Type of A and a ContinentCode of AF.
	//
	// Creating geolocation and geolocation alias resource record sets in private
	// hosted zones is not supported.
	//
	// If you create separate resource record sets for overlapping geographic regions
	// (for example, one resource record set for a continent and one for a country
	// on the same continent), priority goes to the smallest geographic region.
	// This allows you to route most queries for a continent to one resource and
	// to route queries for a country on that continent to a different resource.
	//
	// You can't create two geolocation resource record sets that specify the same
	// geographic location.
	//
	// The value * in the CountryCode element matches all geographic locations that
	// aren't specified in other geolocation resource record sets that have the
	// same values for the Name and Type elements.
	//
	// Geolocation works by mapping IP addresses to locations. However, some IP
	// addresses aren't mapped to geographic locations, so even if you create geolocation
	// resource record sets that cover all seven continents, Route 53 will receive
	// some DNS queries from locations that it can't identify. We recommend that
	// you create a resource record set for which the value of CountryCode is *,
	// which handles both queries that come from locations for which you haven't
	// created geolocation resource record sets and queries from IP addresses that
	// aren't mapped to a location. If you don't create a * resource record set,
	// Route 53 returns a "no answer" response for queries from those locations.
	//
	// You can't create non-geolocation resource record sets that have the same
	// values for the Name and Type elements as geolocation resource record sets.
	GeoLocation *GeoLocation `type:"structure"`

	// If you want Amazon Route 53 to return this resource record set in response
	// to a DNS query only when the status of a health check is healthy, include
	// the HealthCheckId element and specify the ID of the applicable health check.
	//
	// Route 53 determines whether a resource record set is healthy based on one
	// of the following:
	//
	//    * By periodically sending a request to the endpoint that is specified
	//    in the health check
	//
	//    * By aggregating the status of a specified group of health checks (calculated
	//    health checks)
	//
	//    * By determining the current state of a CloudWatch alarm (CloudWatch metric
	//    health checks)
	//
	// Route 53 doesn't check the health of the endpoint that is specified in the
	// resource record set, for example, the endpoint specified by the IP address
	// in the Value element. When you add a HealthCheckId element to a resource
	// record set, Route 53 checks the health of the endpoint that you specified
	// in the health check.
	//
	// For more information, see the following topics in the Amazon Route 53 Developer
	// Guide:
	//
	//    * How Amazon Route 53 Determines Whether an Endpoint Is Healthy (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html)
	//
	//    * Route 53 Health Checks and DNS Failover (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover.html)
	//
	//    * Configuring Failover in a Private Hosted Zone (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html)
	//
	// When to Specify HealthCheckId
	//
	// Specifying a value for HealthCheckId is useful only when Route 53 is choosing
	// between two or more resource record sets to respond to a DNS query, and you
	// want Route 53 to base the choice in part on the status of a health check.
	// Configuring health checks makes sense only in the following configurations:
	//
	//    * Non-alias resource record sets: You're checking the health of a group
	//    of non-alias resource record sets that have the same routing policy, name,
	//    and type (such as multiple weighted records named www.example.com with
	//    a type of A) and you specify health check IDs for all the resource record
	//    sets.
	//
	// If the health check status for a resource record set is healthy, Route 53
	//    includes the record among the records that it responds to DNS queries
	//    with.
	//
	// If the health check status for a resource record set is unhealthy, Route
	//    53 stops responding to DNS queries using the value for that resource record
	//    set.
	//
	// If the health check status for all resource record sets in the group is unhealthy,
	//    Route 53 considers all resource record sets in the group healthy and responds
	//    to DNS queries accordingly.
	//
	//    * Alias resource record sets: You specify the following settings:
	//
	// You set EvaluateTargetHealth to true for an alias resource record set in
	//    a group of resource record sets that have the same routing policy, name,
	//    and type (such as multiple weighted records named www.example.com with
	//    a type of A).
	//
	// You configure the alias resource record set to route traffic to a non-alias
	//    resource record set in the same hosted zone.
	//
	// You specify a health check ID for the non-alias resource record set.
	//
	// If the health check status is healthy, Route 53 considers the alias resource
	//    record set to be healthy and includes the alias record among the records
	//    that it responds to DNS queries with.
	//
	// If the health check status is unhealthy, Route 53 stops responding to DNS
	//    queries using the alias resource record set.
	//
	// The alias resource record set can also route traffic to a group of non-alias
	//    resource record sets that have the same routing policy, name, and type.
	//    In that configuration, associate health checks with all of the resource
	//    record sets in the group of non-alias resource record sets.
	//
	// Geolocation Routing
	//
	// For geolocation resource record sets, if an endpoint is unhealthy, Route
	// 53 looks for a resource record set for the larger, associated geographic
	// region. For example, suppose you have resource record sets for a state in
	// the United States, for the entire United States, for North America, and a
	// resource record set that has * for CountryCode is *, which applies to all
	// locations. If the endpoint for the state resource record set is unhealthy,
	// Route 53 checks for healthy resource record sets in the following order until
	// it finds a resource record set for which the endpoint is healthy:
	//
	//    * The United States
	//
	//    * North America
	//
	//    * The default resource record set
	//
	// Specifying the Health Check Endpoint by Domain Name
	//
	// If your health checks specify the endpoint only by domain name, we recommend
	// that you create a separate health check for each endpoint. For example, create
	// a health check for each HTTP server that is serving content for www.example.com.
	// For the value of FullyQualifiedDomainName, specify the domain name of the
	// server (such as us-east-2-www.example.com), not the name of the resource
	// record sets (www.example.com).
	//
	// Health check results will be unpredictable if you do the following:
	//
	// Create a health check that has the same value for FullyQualifiedDomainName
	// as the name of a resource record set.
	//
	// Associate that health check with the resource record set.
	HealthCheckId *string `type:"string"`

	// Multivalue answer resource record sets only: To route traffic approximately
	// randomly to multiple resources, such as web servers, create one multivalue
	// answer record for each resource and specify true for MultiValueAnswer. Note
	// the following:
	//
	//    * If you associate a health check with a multivalue answer resource record
	//    set, Amazon Route 53 responds to DNS queries with the corresponding IP
	//    address only when the health check is healthy.
	//
	//    * If you don't associate a health check with a multivalue answer record,
	//    Route 53 always considers the record to be healthy.
	//
	//    * Route 53 responds to DNS queries with up to eight healthy records; if
	//    you have eight or fewer healthy records, Route 53 responds to all DNS
	//    queries with all the healthy records.
	//
	//    * If you have more than eight healthy records, Route 53 responds to different
	//    DNS resolvers with different combinations of healthy records.
	//
	//    * When all records are unhealthy, Route 53 responds to DNS queries with
	//    up to eight unhealthy records.
	//
	//    * If a resource becomes unavailable after a resolver caches a response,
	//    client software typically tries another of the IP addresses in the response.
	//
	// You can't create multivalue answer alias records.
	MultiValueAnswer *bool `type:"boolean"`

	// For ChangeResourceRecordSets requests, the name of the record that you want
	// to create, update, or delete. For ListResourceRecordSets responses, the name
	// of a record in the specified hosted zone.
	//
	// ChangeResourceRecordSets Only
	//
	// Enter a fully qualified domain name, for example, www.example.com. You can
	// optionally include a trailing dot. If you omit the trailing dot, Amazon Route
	// 53 assumes that the domain name that you specify is fully qualified. This
	// means that Route 53 treats www.example.com (without a trailing dot) and www.example.com.
	// (with a trailing dot) as identical.
	//
	// For information about how to specify characters other than a-z, 0-9, and
	// - (hyphen) and how to specify internationalized domain names, see DNS Domain
	// Name Format (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html)
	// in the Amazon Route 53 Developer Guide.
	//
	// You can use the asterisk (*) wildcard to replace the leftmost label in a
	// domain name, for example, *.example.com. Note the following:
	//
	//    * The * must replace the entire label. For example, you can't specify
	//    *prod.example.com or prod*.example.com.
	//
	//    * The * can't replace any of the middle labels, for example, marketing.*.example.com.
	//
	//    * If you include * in any position other than the leftmost label in a
	//    domain name, DNS treats it as an * character (ASCII 42), not as a wildcard.
	//
	// You can't use the * wildcard for resource records sets that have a type of
	//    NS.
	//
	// You can use the * wildcard as the leftmost label in a domain name, for example,
	// *.example.com. You can't use an * for one of the middle labels, for example,
	// marketing.*.example.com. In addition, the * must replace the entire label;
	// for example, you can't specify prod*.example.com.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// Latency-based resource record sets only: The Amazon EC2 Region where you
	// created the resource that this resource record set refers to. The resource
	// typically is an AWS resource, such as an EC2 instance or an ELB load balancer,
	// and is referred to by an IP address or a DNS domain name, depending on the
	// record type.
	//
	// Creating latency and latency alias resource record sets in private hosted
	// zones is not supported.
	//
	// When Amazon Route 53 receives a DNS query for a domain name and type for
	// which you have created latency resource record sets, Route 53 selects the
	// latency resource record set that has the lowest latency between the end user
	// and the associated Amazon EC2 Region. Route 53 then returns the value that
	// is associated with the selected resource record set.
	//
	// Note the following:
	//
	//    * You can only specify one ResourceRecord per latency resource record
	//    set.
	//
	//    * You can only create one latency resource record set for each Amazon
	//    EC2 Region.
	//
	//    * You aren't required to create latency resource record sets for all Amazon
	//    EC2 Regions. Route 53 will choose the region with the best latency from
	//    among the regions that you create latency resource record sets for.
	//
	//    * You can't create non-latency resource record sets that have the same
	//    values for the Name and Type elements as latency resource record sets.
	Region ResourceRecordSetRegion `min:"1" type:"string" enum:"true"`

	// Information about the resource records to act upon.
	//
	// If you're creating an alias resource record set, omit ResourceRecords.
	ResourceRecords []ResourceRecord `locationNameList:"ResourceRecord" min:"1" type:"list"`

	// Resource record sets that have a routing policy other than simple: An identifier
	// that differentiates among multiple resource record sets that have the same
	// combination of name and type, such as multiple weighted resource record sets
	// named acme.example.com that have a type of A. In a group of resource record
	// sets that have the same name and type, the value of SetIdentifier must be
	// unique for each resource record set.
	//
	// For information about routing policies, see Choosing a Routing Policy (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html)
	// in the Amazon Route 53 Developer Guide.
	SetIdentifier *string `min:"1" type:"string"`

	// The resource record cache time to live (TTL), in seconds. Note the following:
	//
	//    * If you're creating or updating an alias resource record set, omit TTL.
	//    Amazon Route 53 uses the value of TTL for the alias target.
	//
	//    * If you're associating this resource record set with a health check (if
	//    you're adding a HealthCheckId element), we recommend that you specify
	//    a TTL of 60 seconds or less so clients respond quickly to changes in health
	//    status.
	//
	//    * All of the resource record sets in a group of weighted resource record
	//    sets must have the same value for TTL.
	//
	//    * If a group of weighted resource record sets includes one or more weighted
	//    alias resource record sets for which the alias target is an ELB load balancer,
	//    we recommend that you specify a TTL of 60 seconds for all of the non-alias
	//    weighted resource record sets that have the same name and type. Values
	//    other than 60 seconds (the TTL for load balancers) will change the effect
	//    of the values that you specify for Weight.
	TTL *int64 `type:"long"`

	// When you create a traffic policy instance, Amazon Route 53 automatically
	// creates a resource record set. TrafficPolicyInstanceId is the ID of the traffic
	// policy instance that Route 53 created this resource record set for.
	//
	// To delete the resource record set that is associated with a traffic policy
	// instance, use DeleteTrafficPolicyInstance. Route 53 will delete the resource
	// record set automatically. If you delete the resource record set by using
	// ChangeResourceRecordSets, Route 53 doesn't automatically delete the traffic
	// policy instance, and you'll continue to be charged for it even though it's
	// no longer in use.
	TrafficPolicyInstanceId *string `min:"1" type:"string"`

	// The DNS record type. For information about different record types and how
	// data is encoded for them, see Supported DNS Resource Record Types (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/ResourceRecordTypes.html)
	// in the Amazon Route 53 Developer Guide.
	//
	// Valid values for basic resource record sets: A | AAAA | CAA | CNAME | MX
	// | NAPTR | NS | PTR | SOA | SPF | SRV | TXT
	//
	// Values for weighted, latency, geolocation, and failover resource record sets:
	// A | AAAA | CAA | CNAME | MX | NAPTR | PTR | SPF | SRV | TXT. When creating
	// a group of weighted, latency, geolocation, or failover resource record sets,
	// specify the same value for all of the resource record sets in the group.
	//
	// Valid values for multivalue answer resource record sets: A | AAAA | MX |
	// NAPTR | PTR | SPF | SRV | TXT
	//
	// SPF records were formerly used to verify the identity of the sender of email
	// messages. However, we no longer recommend that you create resource record
	// sets for which the value of Type is SPF. RFC 7208, Sender Policy Framework
	// (SPF) for Authorizing Use of Domains in Email, Version 1, has been updated
	// to say, "...[I]ts existence and mechanism defined in [RFC4408] have led to
	// some interoperability issues. Accordingly, its use is no longer appropriate
	// for SPF version 1; implementations are not to use it." In RFC 7208, see section
	// 14.1, The SPF DNS Record Type (http://tools.ietf.org/html/rfc7208#section-14.1).
	//
	// Values for alias resource record sets:
	//
	//    * CloudFront distributions:A
	//
	// If IPv6 is enabled for the distribution, create two resource record sets
	//    to route traffic to your distribution, one with a value of A and one with
	//    a value of AAAA.
	//
	//    * AWS Elastic Beanstalk environment that has a regionalized subdomain:
	//    A
	//
	//    * ELB load balancers:A | AAAA
	//
	//    * Amazon S3 buckets:A
	//
	//    * Another resource record set in this hosted zone: Specify the type of
	//    the resource record set that you're creating the alias for. All values
	//    are supported except NS and SOA.
	//
	// If you're creating an alias record that has the same name as the hosted zone
	//    (known as the zone apex), you can't route traffic to a record for which
	//    the value of Type is CNAME. This is because the alias record must have
	//    the same type as the record you're routing traffic to, and creating a
	//    CNAME record for the zone apex isn't supported even for an alias record.
	//
	// Type is a required field
	Type RRType `type:"string" required:"true" enum:"true"`

	// Weighted resource record sets only: Among resource record sets that have
	// the same combination of DNS name and type, a value that determines the proportion
	// of DNS queries that Amazon Route 53 responds to using the current resource
	// record set. Route 53 calculates the sum of the weights for the resource record
	// sets that have the same combination of DNS name and type. Route 53 then responds
	// to queries based on the ratio of a resource's weight to the total. Note the
	// following:
	//
	//    * You must specify a value for the Weight element for every weighted resource
	//    record set.
	//
	//    * You can only specify one ResourceRecord per weighted resource record
	//    set.
	//
	//    * You can't create latency, failover, or geolocation resource record sets
	//    that have the same values for the Name and Type elements as weighted resource
	//    record sets.
	//
	//    * You can create a maximum of 100 weighted resource record sets that have
	//    the same values for the Name and Type elements.
	//
	//    * For weighted (but not weighted alias) resource record sets, if you set
	//    Weight to 0 for a resource record set, Route 53 never responds to queries
	//    with the applicable value for that resource record set. However, if you
	//    set Weight to 0 for all resource record sets that have the same combination
	//    of DNS name and type, traffic is routed to all resources with equal probability.
	//
	// The effect of setting Weight to 0 is different when you associate health
	//    checks with weighted resource record sets. For more information, see Options
	//    for Configuring Route 53 Active-Active and Active-Passive Failover (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-configuring-options.html)
	//    in the Amazon Route 53 Developer Guide.
	Weight *int64 `type:"long"`
}

// String returns the string representation
func (s ResourceRecordSet) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourceRecordSet) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ResourceRecordSet) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "ResourceRecordSet"}

	if s.Name == nil {
		invalidParams.Add(aws.NewErrParamRequired("Name"))
	}

	if s.ResourceRecords != nil && len(s.ResourceRecords) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ResourceRecords", 1))
	}
	if s.SetIdentifier != nil && len(*s.SetIdentifier) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SetIdentifier", 1))
	}
	if s.TrafficPolicyInstanceId != nil && len(*s.TrafficPolicyInstanceId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TrafficPolicyInstanceId", 1))
	}
	if len(s.Type) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Type"))
	}
	if s.AliasTarget != nil {
		if err := s.AliasTarget.Validate(); err != nil {
			invalidParams.AddNested("AliasTarget", err.(aws.ErrInvalidParams))
		}
	}
	if s.GeoLocation != nil {
		if err := s.GeoLocation.Validate(); err != nil {
			invalidParams.AddNested("GeoLocation", err.(aws.ErrInvalidParams))
		}
	}
	if s.ResourceRecords != nil {
		for i, v := range s.ResourceRecords {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ResourceRecords", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourceRecordSet) MarshalFields(e protocol.FieldEncoder) error {
	if s.AliasTarget != nil {
		v := s.AliasTarget

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AliasTarget", v, metadata)
	}
	if len(s.Failover) > 0 {
		v := s.Failover

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Failover", v, metadata)
	}
	if s.GeoLocation != nil {
		v := s.GeoLocation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "GeoLocation", v, metadata)
	}
	if s.HealthCheckId != nil {
		v := *s.HealthCheckId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HealthCheckId", protocol.StringValue(v), metadata)
	}
	if s.MultiValueAnswer != nil {
		v := *s.MultiValueAnswer

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MultiValueAnswer", protocol.BoolValue(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	if len(s.Region) > 0 {
		v := s.Region

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Region", v, metadata)
	}
	if len(s.ResourceRecords) > 0 {
		v := s.ResourceRecords

		metadata := protocol.Metadata{ListLocationName: "ResourceRecord"}
		ls0 := e.List(protocol.BodyTarget, "ResourceRecords", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.SetIdentifier != nil {
		v := *s.SetIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SetIdentifier", protocol.StringValue(v), metadata)
	}
	if s.TTL != nil {
		v := *s.TTL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TTL", protocol.Int64Value(v), metadata)
	}
	if s.TrafficPolicyInstanceId != nil {
		v := *s.TrafficPolicyInstanceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyInstanceId", protocol.StringValue(v), metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	if s.Weight != nil {
		v := *s.Weight

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Weight", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A complex type containing a resource and its associated tags.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ResourceTagSet
type ResourceTagSet struct {
	_ struct{} `type:"structure"`

	// The ID for the specified resource.
	ResourceId *string `type:"string"`

	// The type of the resource.
	//
	//    * The resource type for health checks is healthcheck.
	//
	//    * The resource type for hosted zones is hostedzone.
	ResourceType TagResourceType `type:"string" enum:"true"`

	// The tags associated with the specified resource.
	Tags []Tag `locationNameList:"Tag" min:"1" type:"list"`
}

// String returns the string representation
func (s ResourceTagSet) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourceTagSet) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ResourceTagSet) MarshalFields(e protocol.FieldEncoder) error {
	if s.ResourceId != nil {
		v := *s.ResourceId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceId", protocol.StringValue(v), metadata)
	}
	if len(s.ResourceType) > 0 {
		v := s.ResourceType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResourceType", v, metadata)
	}
	if len(s.Tags) > 0 {
		v := s.Tags

		metadata := protocol.Metadata{ListLocationName: "Tag"}
		ls0 := e.List(protocol.BodyTarget, "Tags", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}

// A complex type that contains the type of limit that you specified in the
// request and the current value for that limit.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/ReusableDelegationSetLimit
type ReusableDelegationSetLimit struct {
	_ struct{} `type:"structure"`

	// The limit that you requested: MAX_ZONES_BY_REUSABLE_DELEGATION_SET, the maximum
	// number of hosted zones that you can associate with the specified reusable
	// delegation set.
	//
	// Type is a required field
	Type ReusableDelegationSetLimitType `type:"string" required:"true" enum:"true"`

	// The current value for the MAX_ZONES_BY_REUSABLE_DELEGATION_SET limit.
	//
	// Value is a required field
	Value *int64 `min:"1" type:"long" required:"true"`
}

// String returns the string representation
func (s ReusableDelegationSetLimit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReusableDelegationSetLimit) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s ReusableDelegationSetLimit) MarshalFields(e protocol.FieldEncoder) error {
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A complex type that contains the status that one Amazon Route 53 health checker
// reports and the time of the health check.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/StatusReport
type StatusReport struct {
	_ struct{} `type:"structure"`

	// The date and time that the health checker performed the health check in ISO
	// 8601 format (https://en.wikipedia.org/wiki/ISO_8601) and Coordinated Universal
	// Time (UTC). For example, the value 2017-03-27T17:48:16.751Z represents March
	// 27, 2017 at 17:48:16.751 UTC.
	CheckedTime *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// A description of the status of the health check endpoint as reported by one
	// of the Amazon Route 53 health checkers.
	Status *string `type:"string"`
}

// String returns the string representation
func (s StatusReport) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s StatusReport) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s StatusReport) MarshalFields(e protocol.FieldEncoder) error {
	if s.CheckedTime != nil {
		v := *s.CheckedTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CheckedTime", protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormat}, metadata)
	}
	if s.Status != nil {
		v := *s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about a tag that you want to add
// or edit for the specified health check or hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/Tag
type Tag struct {
	_ struct{} `type:"structure"`

	// The value of Key depends on the operation that you want to perform:
	//
	//    * Add a tag to a health check or hosted zone: Key is the name that you
	//    want to give the new tag.
	//
	//    * Edit a tag: Key is the name of the tag that you want to change the Value
	//    for.
	//
	//    *  Delete a key: Key is the name of the tag you want to remove.
	//
	//    * Give a name to a health check: Edit the default Name tag. In the Amazon
	//    Route 53 console, the list of your health checks includes a Name column
	//    that lets you see the name that you've given to each health check.
	Key *string `type:"string"`

	// The value of Value depends on the operation that you want to perform:
	//
	//    * Add a tag to a health check or hosted zone: Value is the value that
	//    you want to give the new tag.
	//
	//    * Edit a tag: Value is the new value that you want to assign the tag.
	Value *string `type:"string"`
}

// String returns the string representation
func (s Tag) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Tag) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s Tag) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.StringValue(v), metadata)
	}
	return nil
}

// Gets the value that Amazon Route 53 returns in response to a DNS request
// for a specified record name and type. You can optionally specify the IP address
// of a DNS resolver, an EDNS0 client subnet IP address, and a subnet mask.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/TestDNSAnswerRequest
type TestDNSAnswerInput struct {
	_ struct{} `type:"structure"`

	// If the resolver that you specified for resolverip supports EDNS0, specify
	// the IPv4 or IPv6 address of a client in the applicable location, for example,
	// 192.0.2.44 or 2001:db8:85a3::8a2e:370:7334.
	EDNS0ClientSubnetIP *string `location:"querystring" locationName:"edns0clientsubnetip" type:"string"`

	// If you specify an IP address for edns0clientsubnetip, you can optionally
	// specify the number of bits of the IP address that you want the checking tool
	// to include in the DNS query. For example, if you specify 192.0.2.44 for edns0clientsubnetip
	// and 24 for edns0clientsubnetmask, the checking tool will simulate a request
	// from 192.0.2.0/24. The default value is 24 bits for IPv4 addresses and 64
	// bits for IPv6 addresses.
	//
	// The range of valid values depends on whether edns0clientsubnetip is an IPv4
	// or an IPv6 address:
	//
	//    * IPv4: Specify a value between 0 and 32
	//
	//    * IPv6: Specify a value between 0 and 128
	EDNS0ClientSubnetMask *string `location:"querystring" locationName:"edns0clientsubnetmask" type:"string"`

	// The ID of the hosted zone that you want Amazon Route 53 to simulate a query
	// for.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `location:"querystring" locationName:"hostedzoneid" type:"string" required:"true"`

	// The name of the resource record set that you want Amazon Route 53 to simulate
	// a query for.
	//
	// RecordName is a required field
	RecordName *string `location:"querystring" locationName:"recordname" type:"string" required:"true"`

	// The type of the resource record set.
	//
	// RecordType is a required field
	RecordType RRType `location:"querystring" locationName:"recordtype" type:"string" required:"true" enum:"true"`

	// If you want to simulate a request from a specific DNS resolver, specify the
	// IP address for that resolver. If you omit this value, TestDnsAnswer uses
	// the IP address of a DNS resolver in the AWS US East (N. Virginia) Region
	// (us-east-1).
	ResolverIP *string `location:"querystring" locationName:"resolverip" type:"string"`
}

// String returns the string representation
func (s TestDNSAnswerInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestDNSAnswerInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TestDNSAnswerInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "TestDNSAnswerInput"}

	if s.HostedZoneId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HostedZoneId"))
	}

	if s.RecordName == nil {
		invalidParams.Add(aws.NewErrParamRequired("RecordName"))
	}
	if len(s.RecordType) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("RecordType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestDNSAnswerInput) MarshalFields(e protocol.FieldEncoder) error {

	if s.EDNS0ClientSubnetIP != nil {
		v := *s.EDNS0ClientSubnetIP

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "edns0clientsubnetip", protocol.StringValue(v), metadata)
	}
	if s.EDNS0ClientSubnetMask != nil {
		v := *s.EDNS0ClientSubnetMask

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "edns0clientsubnetmask", protocol.StringValue(v), metadata)
	}
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "hostedzoneid", protocol.StringValue(v), metadata)
	}
	if s.RecordName != nil {
		v := *s.RecordName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "recordname", protocol.StringValue(v), metadata)
	}
	if len(s.RecordType) > 0 {
		v := s.RecordType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "recordtype", v, metadata)
	}
	if s.ResolverIP != nil {
		v := *s.ResolverIP

		metadata := protocol.Metadata{}
		e.SetValue(protocol.QueryTarget, "resolverip", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response to a TestDNSAnswer request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/TestDNSAnswerResponse
type TestDNSAnswerOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// The Amazon Route 53 name server used to respond to the request.
	//
	// Nameserver is a required field
	Nameserver *string `type:"string" required:"true"`

	// The protocol that Amazon Route 53 used to respond to the request, either
	// UDP or TCP.
	//
	// Protocol is a required field
	Protocol *string `type:"string" required:"true"`

	// A list that contains values that Amazon Route 53 returned for this resource
	// record set.
	//
	// RecordData is a required field
	RecordData []string `locationNameList:"RecordDataEntry" type:"list" required:"true"`

	// The name of the resource record set that you submitted a request for.
	//
	// RecordName is a required field
	RecordName *string `type:"string" required:"true"`

	// The type of the resource record set that you submitted a request for.
	//
	// RecordType is a required field
	RecordType RRType `type:"string" required:"true" enum:"true"`

	// A code that indicates whether the request is valid or not. The most common
	// response code is NOERROR, meaning that the request is valid. If the response
	// is not valid, Amazon Route 53 returns a response code that describes the
	// error. For a list of possible response codes, see DNS RCODES (http://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6)
	// on the IANA website.
	//
	// ResponseCode is a required field
	ResponseCode *string `type:"string" required:"true"`
}

// String returns the string representation
func (s TestDNSAnswerOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestDNSAnswerOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s TestDNSAnswerOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TestDNSAnswerOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.Nameserver != nil {
		v := *s.Nameserver

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Nameserver", protocol.StringValue(v), metadata)
	}
	if s.Protocol != nil {
		v := *s.Protocol

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Protocol", protocol.StringValue(v), metadata)
	}
	if len(s.RecordData) > 0 {
		v := s.RecordData

		metadata := protocol.Metadata{ListLocationName: "RecordDataEntry"}
		ls0 := e.List(protocol.BodyTarget, "RecordData", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if s.RecordName != nil {
		v := *s.RecordName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecordName", protocol.StringValue(v), metadata)
	}
	if len(s.RecordType) > 0 {
		v := s.RecordType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RecordType", v, metadata)
	}
	if s.ResponseCode != nil {
		v := *s.ResponseCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ResponseCode", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains settings for a traffic policy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/TrafficPolicy
type TrafficPolicy struct {
	_ struct{} `type:"structure"`

	// The comment that you specify in the CreateTrafficPolicy request, if any.
	Comment *string `type:"string"`

	// The definition of a traffic policy in JSON format. You specify the JSON document
	// to use for a new traffic policy in the CreateTrafficPolicy request. For more
	// information about the JSON format, see Traffic Policy Document Format (http://docs.aws.amazon.com/Route53/latest/APIReference/api-policies-traffic-policy-document-format.html).
	//
	// Document is a required field
	Document *string `type:"string" required:"true"`

	// The ID that Amazon Route 53 assigned to a traffic policy when you created
	// it.
	//
	// Id is a required field
	Id *string `min:"1" type:"string" required:"true"`

	// The name that you specified when you created the traffic policy.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The DNS type of the resource record sets that Amazon Route 53 creates when
	// you use a traffic policy to create a traffic policy instance.
	//
	// Type is a required field
	Type RRType `type:"string" required:"true" enum:"true"`

	// The version number that Amazon Route 53 assigns to a traffic policy. For
	// a new traffic policy, the value of Version is always 1.
	//
	// Version is a required field
	Version *int64 `min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s TrafficPolicy) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TrafficPolicy) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TrafficPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.Comment != nil {
		v := *s.Comment

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
	}
	if s.Document != nil {
		v := *s.Document

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Document", protocol.StringValue(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Version", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A complex type that contains settings for the new traffic policy instance.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/TrafficPolicyInstance
type TrafficPolicyInstance struct {
	_ struct{} `type:"structure"`

	// The ID of the hosted zone that Amazon Route 53 created resource record sets
	// in.
	//
	// HostedZoneId is a required field
	HostedZoneId *string `type:"string" required:"true"`

	// The ID that Amazon Route 53 assigned to the new traffic policy instance.
	//
	// Id is a required field
	Id *string `min:"1" type:"string" required:"true"`

	// If State is Failed, an explanation of the reason for the failure. If State
	// is another value, Message is empty.
	//
	// Message is a required field
	Message *string `type:"string" required:"true"`

	// The DNS name, such as www.example.com, for which Amazon Route 53 responds
	// to queries by using the resource record sets that are associated with this
	// traffic policy instance.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The value of State is one of the following values:
	//
	// AppliedAmazon Route 53 has finished creating resource record sets, and changes
	// have propagated to all Route 53 edge locations.
	//
	// CreatingRoute 53 is creating the resource record sets. Use GetTrafficPolicyInstance
	// to confirm that the CreateTrafficPolicyInstance request completed successfully.
	//
	// FailedRoute 53 wasn't able to create or update the resource record sets.
	// When the value of State is Failed, see Message for an explanation of what
	// caused the request to fail.
	//
	// State is a required field
	State *string `type:"string" required:"true"`

	// The TTL that Amazon Route 53 assigned to all of the resource record sets
	// that it created in the specified hosted zone.
	//
	// TTL is a required field
	TTL *int64 `type:"long" required:"true"`

	// The ID of the traffic policy that Amazon Route 53 used to create resource
	// record sets in the specified hosted zone.
	//
	// TrafficPolicyId is a required field
	TrafficPolicyId *string `min:"1" type:"string" required:"true"`

	// The DNS type that Amazon Route 53 assigned to all of the resource record
	// sets that it created for this traffic policy instance.
	//
	// TrafficPolicyType is a required field
	TrafficPolicyType RRType `type:"string" required:"true" enum:"true"`

	// The version of the traffic policy that Amazon Route 53 used to create resource
	// record sets in the specified hosted zone.
	//
	// TrafficPolicyVersion is a required field
	TrafficPolicyVersion *int64 `min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s TrafficPolicyInstance) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TrafficPolicyInstance) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TrafficPolicyInstance) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostedZoneId != nil {
		v := *s.HostedZoneId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HostedZoneId", protocol.StringValue(v), metadata)
	}
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.Message != nil {
		v := *s.Message

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Message", protocol.StringValue(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	if s.State != nil {
		v := *s.State

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "State", protocol.StringValue(v), metadata)
	}
	if s.TTL != nil {
		v := *s.TTL

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TTL", protocol.Int64Value(v), metadata)
	}
	if s.TrafficPolicyId != nil {
		v := *s.TrafficPolicyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyId", protocol.StringValue(v), metadata)
	}
	if len(s.TrafficPolicyType) > 0 {
		v := s.TrafficPolicyType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyType", v, metadata)
	}
	if s.TrafficPolicyVersion != nil {
		v := *s.TrafficPolicyVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyVersion", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A complex type that contains information about the latest version of one
// traffic policy that is associated with the current AWS account.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/TrafficPolicySummary
type TrafficPolicySummary struct {
	_ struct{} `type:"structure"`

	// The ID that Amazon Route 53 assigned to the traffic policy when you created
	// it.
	//
	// Id is a required field
	Id *string `min:"1" type:"string" required:"true"`

	// The version number of the latest version of the traffic policy.
	//
	// LatestVersion is a required field
	LatestVersion *int64 `min:"1" type:"integer" required:"true"`

	// The name that you specified for the traffic policy when you created it.
	//
	// Name is a required field
	Name *string `type:"string" required:"true"`

	// The number of traffic policies that are associated with the current AWS account.
	//
	// TrafficPolicyCount is a required field
	TrafficPolicyCount *int64 `min:"1" type:"integer" required:"true"`

	// The DNS type of the resource record sets that Amazon Route 53 creates when
	// you use a traffic policy to create a traffic policy instance.
	//
	// Type is a required field
	Type RRType `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s TrafficPolicySummary) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TrafficPolicySummary) GoString() string {
	return s.String()
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s TrafficPolicySummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.LatestVersion != nil {
		v := *s.LatestVersion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "LatestVersion", protocol.Int64Value(v), metadata)
	}
	if s.Name != nil {
		v := *s.Name

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Name", protocol.StringValue(v), metadata)
	}
	if s.TrafficPolicyCount != nil {
		v := *s.TrafficPolicyCount

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TrafficPolicyCount", protocol.Int64Value(v), metadata)
	}
	if len(s.Type) > 0 {
		v := s.Type

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Type", v, metadata)
	}
	return nil
}

// A complex type that contains information about a request to update a health
// check.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateHealthCheckRequest
type UpdateHealthCheckInput struct {
	_ struct{} `locationName:"UpdateHealthCheckRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// A complex type that identifies the CloudWatch alarm that you want Amazon
	// Route 53 health checkers to use to determine whether the specified health
	// check is healthy.
	AlarmIdentifier *AlarmIdentifier `type:"structure"`

	// A complex type that contains one ChildHealthCheck element for each health
	// check that you want to associate with a CALCULATED health check.
	ChildHealthChecks []string `locationNameList:"ChildHealthCheck" type:"list"`

	// Stops Route 53 from performing health checks. When you disable a health check,
	// here's what happens:
	//
	//    * Health checks that check the health of endpoints: Route 53 stops submitting
	//    requests to your application, server, or other resource.
	//
	//    * Calculated health checks: Route 53 stops aggregating the status of the
	//    referenced health checks.
	//
	//    * Health checks that monitor CloudWatch alarms: Route 53 stops monitoring
	//    the corresponding CloudWatch metrics.
	//
	// After you disable a health check, Route 53 considers the status of the health
	// check to always be healthy. If you configured DNS failover, Route 53 continues
	// to route traffic to the corresponding resources. If you want to stop routing
	// traffic to a resource, change the value of UpdateHealthCheckRequest$Inverted.
	//
	// Charges for a health check still apply when the health check is disabled.
	// For more information, see Amazon Route 53 Pricing (http://aws.amazon.com/route53/pricing/).
	Disabled *bool `type:"boolean"`

	// Specify whether you want Amazon Route 53 to send the value of FullyQualifiedDomainName
	// to the endpoint in the client_hello message during TLS negotiation. This
	// allows the endpoint to respond to HTTPS health check requests with the applicable
	// SSL/TLS certificate.
	//
	// Some endpoints require that HTTPS requests include the host name in the client_hello
	// message. If you don't enable SNI, the status of the health check will be
	// SSL alert handshake_failure. A health check can also have that status for
	// other reasons. If SNI is enabled and you're still getting the error, check
	// the SSL/TLS configuration on your endpoint and confirm that your certificate
	// is valid.
	//
	// The SSL/TLS certificate on your endpoint includes a domain name in the Common
	// Name field and possibly several more in the Subject Alternative Names field.
	// One of the domain names in the certificate should match the value that you
	// specify for FullyQualifiedDomainName. If the endpoint responds to the client_hello
	// message with a certificate that does not include the domain name that you
	// specified in FullyQualifiedDomainName, a health checker will retry the handshake.
	// In the second attempt, the health checker will omit FullyQualifiedDomainName
	// from the client_hello message.
	EnableSNI *bool `type:"boolean"`

	// The number of consecutive health checks that an endpoint must pass or fail
	// for Amazon Route 53 to change the current status of the endpoint from unhealthy
	// to healthy or vice versa. For more information, see How Amazon Route 53 Determines
	// Whether an Endpoint Is Healthy (http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html)
	// in the Amazon Route 53 Developer Guide.
	//
	// If you don't specify a value for FailureThreshold, the default value is three
	// health checks.
	FailureThreshold *int64 `min:"1" type:"integer"`

	// Amazon Route 53 behavior depends on whether you specify a value for IPAddress.
	//
	// If a health check already has a value for IPAddress, you can change the value.
	// However, you can't update an existing health check to add or remove the value
	// of IPAddress.
	//
	// If you specify a value forIPAddress:
	//
	// Route 53 sends health check requests to the specified IPv4 or IPv6 address
	// and passes the value of FullyQualifiedDomainName in the Host header for all
	// health checks except TCP health checks. This is typically the fully qualified
	// DNS name of the endpoint on which you want Route 53 to perform health checks.
	//
	// When Route 53 checks the health of an endpoint, here is how it constructs
	// the Host header:
	//
	//    * If you specify a value of 80 for Port and HTTP or HTTP_STR_MATCH for
	//    Type, Route 53 passes the value of FullyQualifiedDomainName to the endpoint
	//    in the Host header.
	//
	//    * If you specify a value of 443 for Port and HTTPS or HTTPS_STR_MATCH
	//    for Type, Route 53 passes the value of FullyQualifiedDomainName to the
	//    endpoint in the Host header.
	//
	//    * If you specify another value for Port and any value except TCP for Type,
	//    Route 53 passes FullyQualifiedDomainName:Port to the endpoint in the Host
	//    header.
	//
	// If you don't specify a value for FullyQualifiedDomainName, Route 53 substitutes
	// the value of IPAddress in the Host header in each of the above cases.
	//
	// If you don't specify a value forIPAddress:
	//
	// If you don't specify a value for IPAddress, Route 53 sends a DNS request
	// to the domain that you specify in FullyQualifiedDomainName at the interval
	// you specify in RequestInterval. Using an IPv4 address that is returned by
	// DNS, Route 53 then checks the health of the endpoint.
	//
	// If you don't specify a value for IPAddress, Route 53 uses only IPv4 to send
	// health checks to the endpoint. If there's no resource record set with a type
	// of A for the name that you specify for FullyQualifiedDomainName, the health
	// check fails with a "DNS resolution failed" error.
	//
	// If you want to check the health of weighted, latency, or failover resource
	// record sets and you choose to specify the endpoint only by FullyQualifiedDomainName,
	// we recommend that you create a separate health check for each endpoint. For
	// example, create a health check for each HTTP server that is serving content
	// for www.example.com. For the value of FullyQualifiedDomainName, specify the
	// domain name of the server (such as us-east-2-www.example.com), not the name
	// of the resource record sets (www.example.com).
	//
	// In this configuration, if the value of FullyQualifiedDomainName matches the
	// name of the resource record sets and you then associate the health check
	// with those resource record sets, health check results will be unpredictable.
	//
	// In addition, if the value of Type is HTTP, HTTPS, HTTP_STR_MATCH, or HTTPS_STR_MATCH,
	// Route 53 passes the value of FullyQualifiedDomainName in the Host header,
	// as it does when you specify a value for IPAddress. If the value of Type is
	// TCP, Route 53 doesn't pass a Host header.
	FullyQualifiedDomainName *string `type:"string"`

	// The ID for the health check for which you want detailed information. When
	// you created the health check, CreateHealthCheck returned the ID in the response,
	// in the HealthCheckId element.
	//
	// HealthCheckId is a required field
	HealthCheckId *string `location:"uri" locationName:"HealthCheckId" type:"string" required:"true"`

	// A sequential counter that Amazon Route 53 sets to 1 when you create a health
	// check and increments by 1 each time you update settings for the health check.
	//
	// We recommend that you use GetHealthCheck or ListHealthChecks to get the current
	// value of HealthCheckVersion for the health check that you want to update,
	// and that you include that value in your UpdateHealthCheck request. This prevents
	// Route 53 from overwriting an intervening update:
	//
	//    * If the value in the UpdateHealthCheck request matches the value of HealthCheckVersion
	//    in the health check, Route 53 updates the health check with the new settings.
	//
	//    * If the value of HealthCheckVersion in the health check is greater, the
	//    health check was changed after you got the version number. Route 53 does
	//    not update the health check, and it returns a HealthCheckVersionMismatch
	//    error.
	HealthCheckVersion *int64 `min:"1" type:"long"`

	// The number of child health checks that are associated with a CALCULATED health
	// that Amazon Route 53 must consider healthy for the CALCULATED health check
	// to be considered healthy. To specify the child health checks that you want
	// to associate with a CALCULATED health check, use the ChildHealthChecks and
	// ChildHealthCheck elements.
	//
	// Note the following:
	//
	//    * If you specify a number greater than the number of child health checks,
	//    Route 53 always considers this health check to be unhealthy.
	//
	//    * If you specify 0, Route 53 always considers this health check to be
	//    healthy.
	HealthThreshold *int64 `type:"integer"`

	// The IPv4 or IPv6 IP address for the endpoint that you want Amazon Route 53
	// to perform health checks on. If you don't specify a value for IPAddress,
	// Route 53 sends a DNS request to resolve the domain name that you specify
	// in FullyQualifiedDomainName at the interval that you specify in RequestInterval.
	// Using an IP address that is returned by DNS, Route 53 then checks the health
	// of the endpoint.
	//
	// Use one of the following formats for the value of IPAddress:
	//
	//    * IPv4 address: four values between 0 and 255, separated by periods (.),
	//    for example, 192.0.2.44.
	//
	//    * IPv6 address: eight groups of four hexadecimal values, separated by
	//    colons (:), for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345. You
	//    can also shorten IPv6 addresses as described in RFC 5952, for example,
	//    2001:db8:85a3::abcd:1:2345.
	//
	// If the endpoint is an EC2 instance, we recommend that you create an Elastic
	// IP address, associate it with your EC2 instance, and specify the Elastic
	// IP address for IPAddress. This ensures that the IP address of your instance
	// never changes. For more information, see the applicable documentation:
	//
	//    * Linux: Elastic IP Addresses (EIP) (http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html)
	//    in the Amazon EC2 User Guide for Linux Instances
	//
	//    * Windows: Elastic IP Addresses (EIP) (http://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-ip-addresses-eip.html)
	//    in the Amazon EC2 User Guide for Windows Instances
	//
	// If a health check already has a value for IPAddress, you can change the value.
	// However, you can't update an existing health check to add or remove the value
	// of IPAddress.
	//
	// For more information, see UpdateHealthCheckRequest$FullyQualifiedDomainName.
	//
	// Constraints: Route 53 can't check the health of endpoints for which the IP
	// address is in local, private, non-routable, or multicast ranges. For more
	// information about IP addresses for which you can't create health checks,
	// see the following documents:
	//
	//    * RFC 5735, Special Use IPv4 Addresses (https://tools.ietf.org/html/rfc5735)
	//
	//    * RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space (https://tools.ietf.org/html/rfc6598)
	//
	//    * RFC 5156, Special-Use IPv6 Addresses (https://tools.ietf.org/html/rfc5156)
	IPAddress *string `type:"string"`

	// When CloudWatch has insufficient data about the metric to determine the alarm
	// state, the status that you want Amazon Route 53 to assign to the health check:
	//
	//    * Healthy: Route 53 considers the health check to be healthy.
	//
	//    * Unhealthy: Route 53 considers the health check to be unhealthy.
	//
	//    * LastKnownStatus: Route 53 uses the status of the health check from the
	//    last time CloudWatch had sufficient data to determine the alarm state.
	//    For new health checks that have no last known status, the default status
	//    for the health check is healthy.
	InsufficientDataHealthStatus InsufficientDataHealthStatus `type:"string" enum:"true"`

	// Specify whether you want Amazon Route 53 to invert the status of a health
	// check, for example, to consider a health check unhealthy when it otherwise
	// would be considered healthy.
	Inverted *bool `type:"boolean"`

	// The port on the endpoint on which you want Amazon Route 53 to perform health
	// checks.
	Port *int64 `min:"1" type:"integer"`

	// A complex type that contains one Region element for each region that you
	// want Amazon Route 53 health checkers to check the specified endpoint from.
	Regions []HealthCheckRegion `locationNameList:"Region" min:"3" type:"list"`

	// A complex type that contains one ResettableElementName element for each element
	// that you want to reset to the default value. Valid values for ResettableElementName
	// include the following:
	//
	//    * ChildHealthChecks: Amazon Route 53 resets HealthCheckConfig$ChildHealthChecks
	//    to null.
	//
	//    * FullyQualifiedDomainName: Route 53 resets HealthCheckConfig$FullyQualifiedDomainName
	//    to null.
	//
	//    * Regions: Route 53 resets the HealthCheckConfig$Regions list to the default
	//    set of regions.
	//
	//    * ResourcePath: Route 53 resets HealthCheckConfig$ResourcePath to null.
	ResetElements []ResettableElementName `locationNameList:"ResettableElementName" type:"list"`

	// The path that you want Amazon Route 53 to request when performing health
	// checks. The path can be any value for which your endpoint will return an
	// HTTP status code of 2xx or 3xx when the endpoint is healthy, for example
	// the file /docs/route53-health-check.html. You can also include query string
	// parameters, for example, /welcome.html?language=jp&login=y.
	//
	// Specify this value only if you want to change it.
	ResourcePath *string `type:"string"`

	// If the value of Type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that
	// you want Amazon Route 53 to search for in the response body from the specified
	// resource. If the string appears in the response body, Route 53 considers
	// the resource healthy. (You can't change the value of Type when you update
	// a health check.)
	SearchString *string `type:"string"`
}

// String returns the string representation
func (s UpdateHealthCheckInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateHealthCheckInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateHealthCheckInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateHealthCheckInput"}
	if s.FailureThreshold != nil && *s.FailureThreshold < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("FailureThreshold", 1))
	}

	if s.HealthCheckId == nil {
		invalidParams.Add(aws.NewErrParamRequired("HealthCheckId"))
	}
	if s.HealthCheckVersion != nil && *s.HealthCheckVersion < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("HealthCheckVersion", 1))
	}
	if s.Port != nil && *s.Port < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Port", 1))
	}
	if s.Regions != nil && len(s.Regions) < 3 {
		invalidParams.Add(aws.NewErrParamMinLen("Regions", 3))
	}
	if s.AlarmIdentifier != nil {
		if err := s.AlarmIdentifier.Validate(); err != nil {
			invalidParams.AddNested("AlarmIdentifier", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateHealthCheckInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "UpdateHealthCheckRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.AlarmIdentifier != nil {
			v := s.AlarmIdentifier

			metadata := protocol.Metadata{}
			e.SetFields(protocol.BodyTarget, "AlarmIdentifier", v, metadata)
		}
		if len(s.ChildHealthChecks) > 0 {
			v := s.ChildHealthChecks

			metadata := protocol.Metadata{ListLocationName: "ChildHealthCheck"}
			ls0 := e.List(protocol.BodyTarget, "ChildHealthChecks", metadata)
			ls0.Start()
			for _, v1 := range v {
				ls0.ListAddValue(protocol.StringValue(v1))
			}
			ls0.End()

		}
		if s.Disabled != nil {
			v := *s.Disabled

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Disabled", protocol.BoolValue(v), metadata)
		}
		if s.EnableSNI != nil {
			v := *s.EnableSNI

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "EnableSNI", protocol.BoolValue(v), metadata)
		}
		if s.FailureThreshold != nil {
			v := *s.FailureThreshold

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "FailureThreshold", protocol.Int64Value(v), metadata)
		}
		if s.FullyQualifiedDomainName != nil {
			v := *s.FullyQualifiedDomainName

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "FullyQualifiedDomainName", protocol.StringValue(v), metadata)
		}
		if s.HealthCheckVersion != nil {
			v := *s.HealthCheckVersion

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "HealthCheckVersion", protocol.Int64Value(v), metadata)
		}
		if s.HealthThreshold != nil {
			v := *s.HealthThreshold

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "HealthThreshold", protocol.Int64Value(v), metadata)
		}
		if s.IPAddress != nil {
			v := *s.IPAddress

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "IPAddress", protocol.StringValue(v), metadata)
		}
		if len(s.InsufficientDataHealthStatus) > 0 {
			v := s.InsufficientDataHealthStatus

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "InsufficientDataHealthStatus", v, metadata)
		}
		if s.Inverted != nil {
			v := *s.Inverted

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Inverted", protocol.BoolValue(v), metadata)
		}
		if s.Port != nil {
			v := *s.Port

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Port", protocol.Int64Value(v), metadata)
		}
		if len(s.Regions) > 0 {
			v := s.Regions

			metadata := protocol.Metadata{ListLocationName: "Region"}
			ls0 := e.List(protocol.BodyTarget, "Regions", metadata)
			ls0.Start()
			for _, v1 := range v {
				ls0.ListAddValue(protocol.StringValue(v1))
			}
			ls0.End()

		}
		if len(s.ResetElements) > 0 {
			v := s.ResetElements

			metadata := protocol.Metadata{ListLocationName: "ResettableElementName"}
			ls0 := e.List(protocol.BodyTarget, "ResetElements", metadata)
			ls0.Start()
			for _, v1 := range v {
				ls0.ListAddValue(protocol.StringValue(v1))
			}
			ls0.End()

		}
		if s.ResourcePath != nil {
			v := *s.ResourcePath

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "ResourcePath", protocol.StringValue(v), metadata)
		}
		if s.SearchString != nil {
			v := *s.SearchString

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "SearchString", protocol.StringValue(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.HealthCheckId != nil {
		v := *s.HealthCheckId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "HealthCheckId", protocol.StringValue(v), metadata)
	}
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateHealthCheckResponse
type UpdateHealthCheckOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains the response to an UpdateHealthCheck request.
	//
	// HealthCheck is a required field
	HealthCheck *HealthCheck `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateHealthCheckOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateHealthCheckOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateHealthCheckOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateHealthCheckOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HealthCheck != nil {
		v := s.HealthCheck

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "HealthCheck", v, metadata)
	}
	return nil
}

// A request to update the comment for a hosted zone.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateHostedZoneCommentRequest
type UpdateHostedZoneCommentInput struct {
	_ struct{} `locationName:"UpdateHostedZoneCommentRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// The new comment for the hosted zone. If you don't specify a value for Comment,
	// Amazon Route 53 deletes the existing value of the Comment element, if any.
	Comment *string `type:"string"`

	// The ID for the hosted zone that you want to update the comment for.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateHostedZoneCommentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateHostedZoneCommentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateHostedZoneCommentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateHostedZoneCommentInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateHostedZoneCommentInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "UpdateHostedZoneCommentRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.Comment != nil {
			v := *s.Comment

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains the response to the UpdateHostedZoneComment
// request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateHostedZoneCommentResponse
type UpdateHostedZoneCommentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains the response to the UpdateHostedZoneComment
	// request.
	//
	// HostedZone is a required field
	HostedZone *HostedZone `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateHostedZoneCommentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateHostedZoneCommentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateHostedZoneCommentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateHostedZoneCommentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.HostedZone != nil {
		v := s.HostedZone

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "HostedZone", v, metadata)
	}
	return nil
}

// A complex type that contains information about the traffic policy that you
// want to update the comment for.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateTrafficPolicyCommentRequest
type UpdateTrafficPolicyCommentInput struct {
	_ struct{} `locationName:"UpdateTrafficPolicyCommentRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// The new comment for the specified traffic policy and version.
	//
	// Comment is a required field
	Comment *string `type:"string" required:"true"`

	// The value of Id for the traffic policy that you want to update the comment
	// for.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`

	// The value of Version for the traffic policy that you want to update the comment
	// for.
	//
	// Version is a required field
	Version *int64 `location:"uri" locationName:"Version" min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s UpdateTrafficPolicyCommentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTrafficPolicyCommentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateTrafficPolicyCommentInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateTrafficPolicyCommentInput"}

	if s.Comment == nil {
		invalidParams.Add(aws.NewErrParamRequired("Comment"))
	}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if s.Version == nil {
		invalidParams.Add(aws.NewErrParamRequired("Version"))
	}
	if s.Version != nil && *s.Version < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("Version", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateTrafficPolicyCommentInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "UpdateTrafficPolicyCommentRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.Comment != nil {
			v := *s.Comment

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "Comment", protocol.StringValue(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	if s.Version != nil {
		v := *s.Version

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Version", protocol.Int64Value(v), metadata)
	}
	return nil
}

// A complex type that contains the response information for the traffic policy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateTrafficPolicyCommentResponse
type UpdateTrafficPolicyCommentOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains settings for the specified traffic policy.
	//
	// TrafficPolicy is a required field
	TrafficPolicy *TrafficPolicy `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateTrafficPolicyCommentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTrafficPolicyCommentOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateTrafficPolicyCommentOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateTrafficPolicyCommentOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TrafficPolicy != nil {
		v := s.TrafficPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TrafficPolicy", v, metadata)
	}
	return nil
}

// A complex type that contains information about the resource record sets that
// you want to update based on a specified traffic policy instance.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateTrafficPolicyInstanceRequest
type UpdateTrafficPolicyInstanceInput struct {
	_ struct{} `locationName:"UpdateTrafficPolicyInstanceRequest" type:"structure" xmlURI:"https://route53.amazonaws.com/doc/2013-04-01/"`

	// The ID of the traffic policy instance that you want to update.
	//
	// Id is a required field
	Id *string `location:"uri" locationName:"Id" min:"1" type:"string" required:"true"`

	// The TTL that you want Amazon Route 53 to assign to all of the updated resource
	// record sets.
	//
	// TTL is a required field
	TTL *int64 `type:"long" required:"true"`

	// The ID of the traffic policy that you want Amazon Route 53 to use to update
	// resource record sets for the specified traffic policy instance.
	//
	// TrafficPolicyId is a required field
	TrafficPolicyId *string `min:"1" type:"string" required:"true"`

	// The version of the traffic policy that you want Amazon Route 53 to use to
	// update resource record sets for the specified traffic policy instance.
	//
	// TrafficPolicyVersion is a required field
	TrafficPolicyVersion *int64 `min:"1" type:"integer" required:"true"`
}

// String returns the string representation
func (s UpdateTrafficPolicyInstanceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTrafficPolicyInstanceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateTrafficPolicyInstanceInput) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "UpdateTrafficPolicyInstanceInput"}

	if s.Id == nil {
		invalidParams.Add(aws.NewErrParamRequired("Id"))
	}
	if s.Id != nil && len(*s.Id) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Id", 1))
	}

	if s.TTL == nil {
		invalidParams.Add(aws.NewErrParamRequired("TTL"))
	}

	if s.TrafficPolicyId == nil {
		invalidParams.Add(aws.NewErrParamRequired("TrafficPolicyId"))
	}
	if s.TrafficPolicyId != nil && len(*s.TrafficPolicyId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TrafficPolicyId", 1))
	}

	if s.TrafficPolicyVersion == nil {
		invalidParams.Add(aws.NewErrParamRequired("TrafficPolicyVersion"))
	}
	if s.TrafficPolicyVersion != nil && *s.TrafficPolicyVersion < 1 {
		invalidParams.Add(aws.NewErrParamMinValue("TrafficPolicyVersion", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateTrafficPolicyInstanceInput) MarshalFields(e protocol.FieldEncoder) error {

	e.SetFields(protocol.BodyTarget, "UpdateTrafficPolicyInstanceRequest", protocol.FieldMarshalerFunc(func(e protocol.FieldEncoder) error {
		if s.TTL != nil {
			v := *s.TTL

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "TTL", protocol.Int64Value(v), metadata)
		}
		if s.TrafficPolicyId != nil {
			v := *s.TrafficPolicyId

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "TrafficPolicyId", protocol.StringValue(v), metadata)
		}
		if s.TrafficPolicyVersion != nil {
			v := *s.TrafficPolicyVersion

			metadata := protocol.Metadata{}
			e.SetValue(protocol.BodyTarget, "TrafficPolicyVersion", protocol.Int64Value(v), metadata)
		}
		return nil
	}), protocol.Metadata{XMLNamespaceURI: "https://route53.amazonaws.com/doc/2013-04-01/"})
	if s.Id != nil {
		v := *s.Id

		metadata := protocol.Metadata{}
		e.SetValue(protocol.PathTarget, "Id", protocol.StringValue(v), metadata)
	}
	return nil
}

// A complex type that contains information about the resource record sets that
// Amazon Route 53 created based on a specified traffic policy.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/UpdateTrafficPolicyInstanceResponse
type UpdateTrafficPolicyInstanceOutput struct {
	_ struct{} `type:"structure"`

	responseMetadata aws.Response

	// A complex type that contains settings for the updated traffic policy instance.
	//
	// TrafficPolicyInstance is a required field
	TrafficPolicyInstance *TrafficPolicyInstance `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateTrafficPolicyInstanceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateTrafficPolicyInstanceOutput) GoString() string {
	return s.String()
}

// SDKResponseMetdata return sthe response metadata for the API.
func (s UpdateTrafficPolicyInstanceOutput) SDKResponseMetadata() aws.Response {
	return s.responseMetadata
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s UpdateTrafficPolicyInstanceOutput) MarshalFields(e protocol.FieldEncoder) error {
	if s.TrafficPolicyInstance != nil {
		v := s.TrafficPolicyInstance

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "TrafficPolicyInstance", v, metadata)
	}
	return nil
}

// (Private hosted zones only) A complex type that contains information about
// an Amazon VPC.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/route53-2013-04-01/VPC
type VPC struct {
	_ struct{} `type:"structure"`

	// (Private hosted zones only) The ID of an Amazon VPC.
	VPCId *string `type:"string"`

	// (Private hosted zones only) The region that an Amazon VPC was created in.
	VPCRegion VPCRegion `min:"1" type:"string" enum:"true"`
}

// String returns the string representation
func (s VPC) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s VPC) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *VPC) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "VPC"}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s VPC) MarshalFields(e protocol.FieldEncoder) error {
	if s.VPCId != nil {
		v := *s.VPCId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VPCId", protocol.StringValue(v), metadata)
	}
	if len(s.VPCRegion) > 0 {
		v := s.VPCRegion

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "VPCRegion", v, metadata)
	}
	return nil
}

type AccountLimitType string

// Enum values for AccountLimitType
const (
	AccountLimitTypeMaxHealthChecksByOwner           AccountLimitType = "MAX_HEALTH_CHECKS_BY_OWNER"
	AccountLimitTypeMaxHostedZonesByOwner            AccountLimitType = "MAX_HOSTED_ZONES_BY_OWNER"
	AccountLimitTypeMaxTrafficPolicyInstancesByOwner AccountLimitType = "MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER"
	AccountLimitTypeMaxReusableDelegationSetsByOwner AccountLimitType = "MAX_REUSABLE_DELEGATION_SETS_BY_OWNER"
	AccountLimitTypeMaxTrafficPoliciesByOwner        AccountLimitType = "MAX_TRAFFIC_POLICIES_BY_OWNER"
)

func (enum AccountLimitType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum AccountLimitType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ChangeAction string

// Enum values for ChangeAction
const (
	ChangeActionCreate ChangeAction = "CREATE"
	ChangeActionDelete ChangeAction = "DELETE"
	ChangeActionUpsert ChangeAction = "UPSERT"
)

func (enum ChangeAction) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ChangeAction) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ChangeStatus string

// Enum values for ChangeStatus
const (
	ChangeStatusPending ChangeStatus = "PENDING"
	ChangeStatusInsync  ChangeStatus = "INSYNC"
)

func (enum ChangeStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ChangeStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type CloudWatchRegion string

// Enum values for CloudWatchRegion
const (
	CloudWatchRegionUsEast1      CloudWatchRegion = "us-east-1"
	CloudWatchRegionUsEast2      CloudWatchRegion = "us-east-2"
	CloudWatchRegionUsWest1      CloudWatchRegion = "us-west-1"
	CloudWatchRegionUsWest2      CloudWatchRegion = "us-west-2"
	CloudWatchRegionCaCentral1   CloudWatchRegion = "ca-central-1"
	CloudWatchRegionEuCentral1   CloudWatchRegion = "eu-central-1"
	CloudWatchRegionEuWest1      CloudWatchRegion = "eu-west-1"
	CloudWatchRegionEuWest2      CloudWatchRegion = "eu-west-2"
	CloudWatchRegionEuWest3      CloudWatchRegion = "eu-west-3"
	CloudWatchRegionApSouth1     CloudWatchRegion = "ap-south-1"
	CloudWatchRegionApSoutheast1 CloudWatchRegion = "ap-southeast-1"
	CloudWatchRegionApSoutheast2 CloudWatchRegion = "ap-southeast-2"
	CloudWatchRegionApNortheast1 CloudWatchRegion = "ap-northeast-1"
	CloudWatchRegionApNortheast2 CloudWatchRegion = "ap-northeast-2"
	CloudWatchRegionApNortheast3 CloudWatchRegion = "ap-northeast-3"
	CloudWatchRegionEuNorth1     CloudWatchRegion = "eu-north-1"
	CloudWatchRegionSaEast1      CloudWatchRegion = "sa-east-1"
)

func (enum CloudWatchRegion) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum CloudWatchRegion) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ComparisonOperator string

// Enum values for ComparisonOperator
const (
	ComparisonOperatorGreaterThanOrEqualToThreshold ComparisonOperator = "GreaterThanOrEqualToThreshold"
	ComparisonOperatorGreaterThanThreshold          ComparisonOperator = "GreaterThanThreshold"
	ComparisonOperatorLessThanThreshold             ComparisonOperator = "LessThanThreshold"
	ComparisonOperatorLessThanOrEqualToThreshold    ComparisonOperator = "LessThanOrEqualToThreshold"
)

func (enum ComparisonOperator) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ComparisonOperator) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type HealthCheckRegion string

// Enum values for HealthCheckRegion
const (
	HealthCheckRegionUsEast1      HealthCheckRegion = "us-east-1"
	HealthCheckRegionUsWest1      HealthCheckRegion = "us-west-1"
	HealthCheckRegionUsWest2      HealthCheckRegion = "us-west-2"
	HealthCheckRegionEuWest1      HealthCheckRegion = "eu-west-1"
	HealthCheckRegionApSoutheast1 HealthCheckRegion = "ap-southeast-1"
	HealthCheckRegionApSoutheast2 HealthCheckRegion = "ap-southeast-2"
	HealthCheckRegionApNortheast1 HealthCheckRegion = "ap-northeast-1"
	HealthCheckRegionSaEast1      HealthCheckRegion = "sa-east-1"
)

func (enum HealthCheckRegion) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum HealthCheckRegion) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type HealthCheckType string

// Enum values for HealthCheckType
const (
	HealthCheckTypeHttp             HealthCheckType = "HTTP"
	HealthCheckTypeHttps            HealthCheckType = "HTTPS"
	HealthCheckTypeHttpStrMatch     HealthCheckType = "HTTP_STR_MATCH"
	HealthCheckTypeHttpsStrMatch    HealthCheckType = "HTTPS_STR_MATCH"
	HealthCheckTypeTcp              HealthCheckType = "TCP"
	HealthCheckTypeCalculated       HealthCheckType = "CALCULATED"
	HealthCheckTypeCloudwatchMetric HealthCheckType = "CLOUDWATCH_METRIC"
)

func (enum HealthCheckType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum HealthCheckType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type HostedZoneLimitType string

// Enum values for HostedZoneLimitType
const (
	HostedZoneLimitTypeMaxRrsetsByZone         HostedZoneLimitType = "MAX_RRSETS_BY_ZONE"
	HostedZoneLimitTypeMaxVpcsAssociatedByZone HostedZoneLimitType = "MAX_VPCS_ASSOCIATED_BY_ZONE"
)

func (enum HostedZoneLimitType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum HostedZoneLimitType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type InsufficientDataHealthStatus string

// Enum values for InsufficientDataHealthStatus
const (
	InsufficientDataHealthStatusHealthy         InsufficientDataHealthStatus = "Healthy"
	InsufficientDataHealthStatusUnhealthy       InsufficientDataHealthStatus = "Unhealthy"
	InsufficientDataHealthStatusLastKnownStatus InsufficientDataHealthStatus = "LastKnownStatus"
)

func (enum InsufficientDataHealthStatus) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum InsufficientDataHealthStatus) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type RRType string

// Enum values for RRType
const (
	RRTypeSoa   RRType = "SOA"
	RRTypeA     RRType = "A"
	RRTypeTxt   RRType = "TXT"
	RRTypeNs    RRType = "NS"
	RRTypeCname RRType = "CNAME"
	RRTypeMx    RRType = "MX"
	RRTypeNaptr RRType = "NAPTR"
	RRTypePtr   RRType = "PTR"
	RRTypeSrv   RRType = "SRV"
	RRTypeSpf   RRType = "SPF"
	RRTypeAaaa  RRType = "AAAA"
	RRTypeCaa   RRType = "CAA"
)

func (enum RRType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum RRType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ResettableElementName string

// Enum values for ResettableElementName
const (
	ResettableElementNameFullyQualifiedDomainName ResettableElementName = "FullyQualifiedDomainName"
	ResettableElementNameRegions                  ResettableElementName = "Regions"
	ResettableElementNameResourcePath             ResettableElementName = "ResourcePath"
	ResettableElementNameChildHealthChecks        ResettableElementName = "ChildHealthChecks"
)

func (enum ResettableElementName) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ResettableElementName) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ResourceRecordSetFailover string

// Enum values for ResourceRecordSetFailover
const (
	ResourceRecordSetFailoverPrimary   ResourceRecordSetFailover = "PRIMARY"
	ResourceRecordSetFailoverSecondary ResourceRecordSetFailover = "SECONDARY"
)

func (enum ResourceRecordSetFailover) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ResourceRecordSetFailover) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ResourceRecordSetRegion string

// Enum values for ResourceRecordSetRegion
const (
	ResourceRecordSetRegionUsEast1      ResourceRecordSetRegion = "us-east-1"
	ResourceRecordSetRegionUsEast2      ResourceRecordSetRegion = "us-east-2"
	ResourceRecordSetRegionUsWest1      ResourceRecordSetRegion = "us-west-1"
	ResourceRecordSetRegionUsWest2      ResourceRecordSetRegion = "us-west-2"
	ResourceRecordSetRegionCaCentral1   ResourceRecordSetRegion = "ca-central-1"
	ResourceRecordSetRegionEuWest1      ResourceRecordSetRegion = "eu-west-1"
	ResourceRecordSetRegionEuWest2      ResourceRecordSetRegion = "eu-west-2"
	ResourceRecordSetRegionEuWest3      ResourceRecordSetRegion = "eu-west-3"
	ResourceRecordSetRegionEuCentral1   ResourceRecordSetRegion = "eu-central-1"
	ResourceRecordSetRegionApSoutheast1 ResourceRecordSetRegion = "ap-southeast-1"
	ResourceRecordSetRegionApSoutheast2 ResourceRecordSetRegion = "ap-southeast-2"
	ResourceRecordSetRegionApNortheast1 ResourceRecordSetRegion = "ap-northeast-1"
	ResourceRecordSetRegionApNortheast2 ResourceRecordSetRegion = "ap-northeast-2"
	ResourceRecordSetRegionApNortheast3 ResourceRecordSetRegion = "ap-northeast-3"
	ResourceRecordSetRegionEuNorth1     ResourceRecordSetRegion = "eu-north-1"
	ResourceRecordSetRegionSaEast1      ResourceRecordSetRegion = "sa-east-1"
	ResourceRecordSetRegionCnNorth1     ResourceRecordSetRegion = "cn-north-1"
	ResourceRecordSetRegionCnNorthwest1 ResourceRecordSetRegion = "cn-northwest-1"
	ResourceRecordSetRegionApSouth1     ResourceRecordSetRegion = "ap-south-1"
)

func (enum ResourceRecordSetRegion) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ResourceRecordSetRegion) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type ReusableDelegationSetLimitType string

// Enum values for ReusableDelegationSetLimitType
const (
	ReusableDelegationSetLimitTypeMaxZonesByReusableDelegationSet ReusableDelegationSetLimitType = "MAX_ZONES_BY_REUSABLE_DELEGATION_SET"
)

func (enum ReusableDelegationSetLimitType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum ReusableDelegationSetLimitType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type Statistic string

// Enum values for Statistic
const (
	StatisticAverage     Statistic = "Average"
	StatisticSum         Statistic = "Sum"
	StatisticSampleCount Statistic = "SampleCount"
	StatisticMaximum     Statistic = "Maximum"
	StatisticMinimum     Statistic = "Minimum"
)

func (enum Statistic) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum Statistic) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type TagResourceType string

// Enum values for TagResourceType
const (
	TagResourceTypeHealthcheck TagResourceType = "healthcheck"
	TagResourceTypeHostedzone  TagResourceType = "hostedzone"
)

func (enum TagResourceType) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum TagResourceType) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}

type VPCRegion string

// Enum values for VPCRegion
const (
	VPCRegionUsEast1      VPCRegion = "us-east-1"
	VPCRegionUsEast2      VPCRegion = "us-east-2"
	VPCRegionUsWest1      VPCRegion = "us-west-1"
	VPCRegionUsWest2      VPCRegion = "us-west-2"
	VPCRegionEuWest1      VPCRegion = "eu-west-1"
	VPCRegionEuWest2      VPCRegion = "eu-west-2"
	VPCRegionEuWest3      VPCRegion = "eu-west-3"
	VPCRegionEuCentral1   VPCRegion = "eu-central-1"
	VPCRegionApSoutheast1 VPCRegion = "ap-southeast-1"
	VPCRegionApSoutheast2 VPCRegion = "ap-southeast-2"
	VPCRegionApSouth1     VPCRegion = "ap-south-1"
	VPCRegionApNortheast1 VPCRegion = "ap-northeast-1"
	VPCRegionApNortheast2 VPCRegion = "ap-northeast-2"
	VPCRegionApNortheast3 VPCRegion = "ap-northeast-3"
	VPCRegionEuNorth1     VPCRegion = "eu-north-1"
	VPCRegionSaEast1      VPCRegion = "sa-east-1"
	VPCRegionCaCentral1   VPCRegion = "ca-central-1"
	VPCRegionCnNorth1     VPCRegion = "cn-north-1"
)

func (enum VPCRegion) MarshalValue() (string, error) {
	return string(enum), nil
}

func (enum VPCRegion) MarshalValueBuf(b []byte) ([]byte, error) {
	b = b[0:0]
	return append(b, enum...), nil
}
